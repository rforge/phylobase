<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>NCL: Quirks and Gotchas</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="ncl.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="Gotchas">Quirks and Gotchas </a></h1><ul>
<li><a class="el" href="Gotchas.html#MisleadingNames">Potentially Confusing Names.</a></li>
<li><a class="el" href="Gotchas.html#BlockTypeIDDiscussion">Block Type IDs or Block IDs</a></li>
<li><a class="el" href="Gotchas.html#impliedBlocks">"Implied" blocks</a></li>
<li><a class="el" href="Gotchas.html#taxaBlockScoping">"Scoping" of TAXA blocks</a></li>
<li><a class="el" href="Gotchas.html#memoryManagement">Managing Memory</a></li>
<li><a class="el" href="Gotchas.html#setsAssumptions">NxsAssumptionsBlock reads several types of blocks</a></li>
</ul>
<h2><a class="anchor" id="MisleadingNames">
Potentially Confusing Names.</a></h2>
<p>A few of the names of classes in NCL may cause some confusion:</p>
<ul>
<li><a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> is really a "NEXUS block parser." Instances of this class are responsible for reading a block in a NEXUS, file. After parsing the file content, the instance should hold contents of the block in memory. So <b>after</b> the parse the <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> object naturally maps to the block in a NEXUS file.</li>
<li><a class="el" href="classNxsToken.html">NxsToken</a> should be NxsTokenizer. It wraps a istream and return tokens.</li>
<li><a class="el" href="classNxsAssumptionsBlock.html" title="This class handles reading and storage for the NxsReader block ASSUMPTIONS.">NxsAssumptionsBlock</a> - Instances of this block type actually read commands in the ASSUMPTIONS, SETS, and CODONS blocks. It is common for commands such as CharSets to occur in several different blocks. Because most clients want to treat the information identically regardless of block type, NCL actually uses the same class to process any of these commands that occur in any of these blocks. This terminology is potentially confusing, but it does make it easier for client code to obtain references to all of the associated metadata (rather than having to query specifically for each of the three block types, you can query for the <a class="el" href="classNxsAssumptionsBlock.html" title="This class handles reading and storage for the NxsReader block ASSUMPTIONS.">NxsAssumptionsBlock</a> only. Note the discussion of <a class="el" href="Gotchas.html#BlockTypeIDDiscussion">Block Type IDs or Block IDs</a> for confusion over the "ID."</li>
</ul>
<h2><a class="anchor" id="BlockTypeIDDiscussion">
Block Type IDs or Block IDs</a></h2>
<p>NEXUS files are composed of modules called blocks. Blocks begin with <code>BEGIN blockname;</code> and end with an <code>END;</code> command. The <code>blockname</code> indicates what type of information is in the block; common block names are TAXA, CHARACTERS, and TREES. In NCL, these block names have always been referred to as the ID of the block ( NxsBlock::id data member, and <a class="el" href="classNxsBlock_a43cb2dac4ccc14d798d29670d9dc6017.html#a43cb2dac4ccc14d798d29670d9dc6017" title="Returns the `id` NxsString.">NxsBlock::GetID()</a> method). Perhaps a better name for this concept would be BlockType or BlockTypeID.</p>
<p>These block names are important for NCL, because the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> uses the Block ID to figure out whether a <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> instance can read the next section of a NEXUS file (specifically in <a class="el" href="classNxsReader_a57f6e706bac65d43bf5eb2bba3c58a0e.html#a57f6e706bac65d43bf5eb2bba3c58a0e" title="Reads the NxsReader data file from the input stream provided by `token&#39;.">NxsReader::Execute</a>, when the reader encounters the beginning of the block, it calls NxsBlock::CanReadBlockType() passing in the NEXUS tokenizer that is set to the Block name token; however the base class implementation of CanReadBlockType simply returns true if NxsBlock::id matches the block name token).</p>
<p>Be aware that Mesquite added a BLOCKID command to nexus. This command allows assigns a unique string to a block in a file. This BlockID string from the BLOCKID command is <b>NOT</b> the id that is referred to throughout the NCL documentation. NCL handles and stores the BlockID from the BLOCKID command (see <a class="el" href="classNxsBlock_a1c41388b522d57c51ccbd34404db0531.html#a1c41388b522d57c51ccbd34404db0531" title="This is the argument from the BLOCKID command.">NxsBlock::GetBlockIDCommandString()</a> method).</p>
<p>Mesquite also introduced a TITLE command for a block. The TITLE command is handled by NCL (see NxsBlock::GetTitle() method). Block Titles are not necessarily unique. Unlike the BlockIDs, they are shown to user's as identifiers for the blocks in Mesquite's GUI.</p>
<p>In summary: NEXUS is composed of blocks have different types. In the NCL API (and documentation) these block types correspond to the ID of the <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> instance. To deal with Mesquite extensions to NEXUS, any block can have a TITLE and a BlockID, but these fields are distinct from the ID that NCL refers to in its documentation.</p>
<h2><a class="anchor" id="impliedBlocks">
"Implied" blocks</a></h2>
<p>It is not unusual to see files that refer to taxa without having an explicit TAXA block. For example, it is very common to encounter a file that just has a TREES block; technically such a file is not valid NEXUS, but if NCL is configured correctly (see the NxsTreesBlock::SetAllowImplicitNames() method) it will tolerate these files and generate a TAXA block on-the-fly. NCL v2.1 will create implied taxa block objects during a parse. From the client code's perspective it will seem as if the file contained an explicit TAXA block. This makes it easy to write client code, because one does not have to add special cases for files with DATA blocks or files with just TREES blocks.</p>
<p>See <a class="el" href="Gotchas.html#taxaBlockScoping">"Scoping" of TAXA blocks</a> for a more detaile discussion.</p>
<h2><a class="anchor" id="taxaBlockScoping">
"Scoping" of TAXA blocks</a></h2>
<p>Because Taxa are central to most phylogenetic data, it is crucial that the parser can identify the TAXA that are being referred to when parsing taxa-dependent context.</p>
<p>Unfortunately, the NEXUS specification is silent on the issue of how to deal with multiple instances of blocks of the same type. Mesquite introduced a LINK/TITLE pair of commands so that a file such as this one: </p>
<div class="fragment"><pre class="fragment">    begin taxa;
        TITLE some_title;
    ...
    end;
    begin characters;
        TITLE <span class="stringliteral">&#39;a char block title&#39;</span>;
        LINK Taxa = some_title ;
    ...
</pre></div><p> is explicit about which set of taxa are used in the characters block.</p>
<p>NCL is often having to infer which TAXA block to use. In general, if it finds two possibilities (and there are not LINK commands to disambiguate which block to use) then NCL will raise an exception.</p>
<p>Unfortunately:</p>
<ol type="1">
<li>files with explicit TITLE/LINK commands are rare,</li>
<li>many files are technically illegal because they have a TREES block but no TAXA block. Because the taxon names are embedded in the tree description or the TRANSLATE command, it is feasible to infer an implied TAXA block for such files.</li>
<li>Reading multiple files with the same <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> can mean that there are multiple TAXA blocks in the memory accessible to the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a>. So the parser will generate a <a class="el" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a> when it encounters a taxa-dependent block (despite the fact that each file would have only one TAXA block if it were processed separately).</li>
</ol>
<p>Files without TAXA blocks (problem #2 above) can be dealt with by calling the NxsTreesBlock::SetAllowImplicitNames() method on the <a class="el" href="classNxsTreesBlock.html" title="This class handles reading and storage for the NEXUS block TREES.">NxsTreesBlock</a> that will parse the TREES block (or the block that is the template in the NxsReader's clone factory). Doing this can just exacerbate problem #3, because now a parse will generate even <b>more</b> Taxa blocks.</p>
<p>You can call NxsReader::cullIdenticalTaxaBlocks(true) before parse so that NCL will store only one block when it finds duplicate TAXA blocks (implicit taxa blocks generated by parsing a TREES block will often be identical to a TAXA block mentioned in a separate file, so this function really can cut down on the number of <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> instances that you have to deal with after the parse is done). Note that NEXUS has an ordering to the taxa (and characters and trees), so two TAXA blocks with the same labels, but in different orders are NOT considered to be the identical!</p>
<p>With NCL 2.1.11 and above you can call <a class="el" href="classNxsReader_a9b4a4e2805479cbd6ce909fa63911fee.html#a9b4a4e2805479cbd6ce909fa63911fee" title="Lowers the priority of all read blocks to `priorityLevel`.">NxsReader::DemoteBlocks</a> before each file is read. This will set the "priority" of previously read TAXA blocks to a lower level. So if the next file read has a TAXA block and taxa-dependent block, but no LINK statements, NCL will not be confused. It will assume that the TAXA block in the file is to be used (you can still get errors if the file contains multiple TAXA blocks, but no LINK statements).</p>
<p>Generally the most robust strategy, involves the following calls: </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classMultiFormatReader.html" title="A special class of PublicNexusReader, that can parse.">MultiFormatReader</a> nexusReader(-1, <a class="code" href="classNxsReader_aae1b69753e31aba3ff7e4b48a5afba95.html#aae1b69753e31aba3ff7e4b48a5afba95a0b0c59f3609e43fd90018b8320345a44">NxsReader::WARNINGS_TO_STDERR</a>);
    ...
    <a class="code" href="classNxsTreesBlock.html" title="This class handles reading and storage for the NEXUS block TREES.">NxsTreesBlock</a> * treesB = nexusReader.GetTreesBlockTemplate();
    treesB-&gt;SetAllowImplicitNames(<span class="keyword">true</span>);
    ...
    nexusReader.cullIdenticalTaxaBlocks(<span class="keyword">true</span>);
    ...

    <span class="keywordtype">char</span> * filename = <span class="stringliteral">&quot;test.nex&quot;</span>;
    nexusReader.DemoteBlocks();
    nexusReader.ReadFilepath(argv[argn], MultiFormatReader::NEXUS_FORMAT);
    ...
</pre></div><p>But it is important to recognize that after reading file(s) it is possible that you will have to deal with multiple <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> instances that all contain the same taxa, but in a different order. Currently NCL does not support reordering of the references to taxa, so you will have to disentangle the data if you want to support resolving similar taxa blocks and their corresponding linked data. The taxa-dependent blocks can tell you what <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> instance they used during the parse, so you can tell which blocks refer to the same taxa (see also <a class="el" href="classPublicNexusReader_acebafd1948979c5061cd368cd8506150.html#acebafd1948979c5061cd368cd8506150">PublicNexusReader::GetNumCharactersBlocks()</a> and functions like it which take a <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> pointer and return only NxsCharactersBlocks that refer to that set of taxa).</p>
<h2><a class="anchor" id="memoryManagement">
Managing Memory</a></h2>
<p>Almost all objects in NCL clean up all of the memory that they allocate, so do not present problems.</p>
<p>The only exception to this are the <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> instances that are handled by the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a>. By default the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> will not delete any of the NxsBlocks that it handles. <br/>
 <b>You are responsible for deleting all of the NxsBlocks, that the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> can return to you!</b></p>
<p>The only cases in which the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> trigger deletion of NxsBlocks are:</p>
<ol type="1">
<li>If the client calls <a class="el" href="classNxsReader_a44291c052d7bb75a7918bb1aab5897e1.html#a44291c052d7bb75a7918bb1aab5897e1" title="Deletes the set of blocks that have been created from factories and removes reference...">NxsReader::DeleteBlocksFromFactories()</a>, then the blocks that were created using a <a class="el" href="classNxsBlockFactory.html" title="This abstract class defines the interface for a factory that can generate NxsBlocks...">NxsBlockFactory</a> will be deleted.</li>
<li>If you have called NxsReader::cullIdenticalTaxaBlocks(true), then the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> will delete a new Taxa block if it is identical to a previous <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a></li>
<li>If there is an error from a <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> from a factory during the parse (or the block is disabled), then the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> will inform the factory through (<a class="el" href="classNxsBlockFactory_aac803d1280d8e4ea15b3335d9c253ba0.html#aac803d1280d8e4ea15b3335d9c253ba0" title="base-class implementation deletes the block (the NxsReader will not retain a reference...">NxsBlockFactory::BlockError()</a> or <a class="el" href="classNxsBlockFactory_a32543bdc2f039f17712acfefedca80b6.html#a32543bdc2f039f17712acfefedca80b6" title="base-class implementation deletes the block (the NxsReader will not retain a reference...">NxsBlockFactory::BlockSkipped()</a> methods). In these cases the factory will delete the block, and the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> will not store them.</li>
</ol>
<p>Note that in cases 2 and 3, the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> will not store the block, so the memory management rules for blocks are actually easy to follow. Once again that rule is: <br/>
 <b>You are responsible for deleting all of the NxsBlocks, that the can <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> return to you!</b></p>
<p>Note that if you need to delete a block even if you are not interested in its content. Even if do not ask for the <a class="el" href="classNxsAssumptionsBlock.html" title="This class handles reading and storage for the NxsReader block ASSUMPTIONS.">NxsAssumptionsBlock</a> instances, the <a class="el" href="classMultiFormatReader.html" title="A special class of PublicNexusReader, that can parse.">MultiFormatReader</a> may still have created <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> instances to store the content of blocks, so these <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> instances must be deleted.</p>
<p><a class="el" href="classNxsReader_a44291c052d7bb75a7918bb1aab5897e1.html#a44291c052d7bb75a7918bb1aab5897e1" title="Deletes the set of blocks that have been created from factories and removes reference...">NxsReader::DeleteBlocksFromFactories()</a> is a convenient way to clean-up after a parse. If you want to save some of the blocks, you can "deregister" them from the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> before the <a class="el" href="classNxsReader_a44291c052d7bb75a7918bb1aab5897e1.html#a44291c052d7bb75a7918bb1aab5897e1" title="Deletes the set of blocks that have been created from factories and removes reference...">NxsReader::DeleteBlocksFromFactories()</a> call. The <a class="el" href="classNxsReader_ad05c38b8d256b9acca8be01f645d9f9e.html#ad05c38b8d256b9acca8be01f645d9f9e" title="Removes a block from the NxsReader&#39;s records.">NxsReader::RemoveBlockFromUsedBlockList</a> method is the one to use to make the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> forget about a block.</p>
<p>If you know beforehand that you are not going to be interested in a particular public block, then you can configure the <a class="el" href="classMultiFormatReader.html" title="A special class of PublicNexusReader, that can parse.">MultiFormatReader</a> to skip blocks (see the documentation on the <a class="el" href="classPublicNexusReader_a8ef04630a31b01d5a8b4283a46d79eea.html#a8ef04630a31b01d5a8b4283a46d79eea" title="Creates a new PublicNexusReader.">PublicNexusReader::PublicNexusReader</a> constructor).</p>
<p>The only caveat is that if you register a "singelton" block (using <a class="el" href="classNxsReader_a6d8b9b4cbb59099097a529a4fe6abe39.html#a6d8b9b4cbb59099097a529a4fe6abe39" title="Adds `newBlock&#39; to the end of the list of NxsBlock objects growing from `blockList&#39;...">NxsReader::Add</a>) and the block is used multiple times in the file, then <a class="el" href="classNxsReader_a288fce08baf8efb5c6fc6c36842900b8.html#a288fce08baf8efb5c6fc6c36842900b8" title="Returns a list of all blocks that the NxsReader knows have been read and have NOT...">NxsReader::GetUsedBlocksInOrder()</a> method may return the same pointer multiple times. So make sure that you either do not use <a class="el" href="classNxsReader_a6d8b9b4cbb59099097a529a4fe6abe39.html#a6d8b9b4cbb59099097a529a4fe6abe39" title="Adds `newBlock&#39; to the end of the list of NxsBlock objects growing from `blockList&#39;...">NxsReader::Add</a> or you guard against double deletion of any blocks that are added in this mechanism.</p>
<p>If you do use <a class="el" href="classNxsReader_a6d8b9b4cbb59099097a529a4fe6abe39.html#a6d8b9b4cbb59099097a529a4fe6abe39" title="Adds `newBlock&#39; to the end of the list of NxsBlock objects growing from `blockList&#39;...">NxsReader::Add</a>, then the common usage is to maintain a list of those blocks that you have added. Then you can delete them, and call <a class="el" href="classNxsReader_a44291c052d7bb75a7918bb1aab5897e1.html#a44291c052d7bb75a7918bb1aab5897e1" title="Deletes the set of blocks that have been created from factories and removes reference...">NxsReader::DeleteBlocksFromFactories()</a> to delete all other blocks (without worrying about double-deletion problems).</p>
<h2><a class="anchor" id="setsAssumptions">
NxsAssumptionsBlock reads several types of blocks</a></h2>
<p>Commands like CharSet frequently occur in ASSUMPTIONS blocks (rather than the SETS block). Codon-related commands are also found in ASSUMPTIONS blocks.</p>
<p>To avoid code duplication and forcing the client code to specifically ask for all of the various flavors of meta-data blocks, NCL uses NxsAssumptionsBlocks to read SETS, ASSUMPTIONS, and CODONS blocks.</p>
<p>You can use NxsAssumptionsBlock::GetIDOfBlockTypeIDFromParse to find out what the block in the file was called. But usually you want to deal with the commands in the same way, regardless of what block they occur in, so you rarely need this call.</p>
<h2><a class="anchor" id="mixedDatatypes">
Dealing with Datatype=Mixed</a></h2>
<p>Combined data sets are most cleanly expressed as multiple separate blocks such that each block consists of data of a homogeneous type. Unfortunately, the NEXUS standard was silent on how to accommodate multiple blocks of the same type (The TITLE/LINK mechanism [see <a class="el" href="Gotchas.html#taxaBlockScoping">"Scoping" of TAXA blocks</a>] was not introduced until several years after the standard, and some popular software will only accept a single character block).</p>
<p>An unsatisfactory solution that has been supported for a long time is to augment the list of legal symbols in the CHARACTERS or DATA block. Doing this makes it possible to parse a mixed matrix, but the software cannot necessarily figure out the datatype for each character (eg. the common symbols for DNA are a subset of the amino acid codes, so you can't tell if a column of A's is alanine or adenine).</p>
<p>MrBayes introduced the <code>datatype=MIXED</code> syntax to the Format command of the CHARACTERS block. This is more explicit than the older NEXUS style of simply augmenting the symbols list (without saying which datatype corresponds to which column). The syntax for this is:<br/>
 </p>
<div class="fragment"><pre class="fragment">FORMAT Datatype=MIXED(RNA: 1-516, RNA: 517-1398, Protein: 1399-1692, Standard: 1693-1742)  Gap=-;
</pre></div><h3><a class="anchor" id="enableparsemixed">
Enabling parsing of Mixed datatypes</a></h3>
<p>By default NCL will reject this mixed datatype syntax, but you can enable parsing of this syntax by calling NxsCharactersBlock::SetSupportMixedDatatype(true) on the <a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> and NxsDataBlocks (or the "templates" for these blocks) before the parse.</p>
<p>NCL will also reject the (legal) NEXUS syntax: </p>
<div class="fragment"><pre class="fragment">FORMAT Datatype=DNA symbols=<span class="stringliteral">&quot;01&quot;</span>  Gap=-;
</pre></div><p> To enable augmenting the symbols list of for the sequence types, call <a class="el" href="classNxsCharactersBlock_a03323afe931168034735ad2be8a4ed8c.html#a03323afe931168034735ad2be8a4ed8c" title="Instructs the NxsCharactersBlock to accept extra symbols even if the datatype is...">NxsCharactersBlock::SetAllowAugmentingOfSequenceSymbols()</a> with the argument true. This will allow the Characters block to accept the syntax, but the <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> associated with the matrix will think of itself as a standard datatype. This reflects the uncertainty inherent in this ambiguous syntax. Whenever you find that <a class="el" href="classNxsCharactersBlock_a1feb957ad6d097cc94337d7f57776bb9.html#a1feb957ad6d097cc94337d7f57776bb9" title="Returns datatype listed in the CHARACTERS block.">NxsCharactersBlock::GetOriginalDataType()</a> != <a class="el" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&#39; from the datatype mapper.">NxsCharactersBlock::GetDataType()</a> <br/>
 this means that NCL had to convert a datatype during the parse.</p>
<p>If you also call NxsCharactersBlock::SetConvertAugmentedToMixed(true), the NCL will <b>attempt</b> to separate a sequence datatype with augmented symbols list into a mixed type that has the same sequence type but also has a set of characters that are datatype <code>standard</code>. Note that this will only work if the matrix is a mixture of sequence data and numeric symbols.</p>
<p>If the conversion to mixed cannot be safely done, the matrix will be preserved, but it will be NxsCharactersBlock::standard type matrix.</p>
<h3><a class="anchor" id="accessingMixed">
Accessing data from Mixed datatypes NxsCharactersBlock</a></h3>
<p>If you have enabled parsing of mixed datatypes, then you have to be prepared to deal with <a class="el" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&#39; from the datatype mapper.">NxsCharactersBlock::GetDataType()</a> returning <a class="el" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca53544b6c478de9117d5e98a66e5f20d1" title="indicates `matrix&#39; holds continuous data">NxsCharactersBlock::mixed</a>. Internally the characters block stores each row of the matrix as a vector of integers (the type is NxsDiscreteStateCell which is usually an <code>int</code> see <a class="el" href="Gotchas.html#improveperformance">Improving Performance</a>). Each column of the matrix is associated with a <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a>. There is one mapper for each type of data in a <a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a>. When you have non-mixed there is only one mapper, but with mixed datatypes there will be multiple.</p>
<p>You can get the <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> for a character by calling NxsCharactersBlock::GetDatatypeMapperForChar().</p>
<p>If want to process all of the columns that share a mapper as a group, then you can call <a class="el" href="classNxsCharactersBlock_a886919f70994b6d9339ccae1346c0a08.html#a886919f70994b6d9339ccae1346c0a08">NxsCharactersBlock::GetDatatypeMapForMixedType()</a>. This will return a std::map&lt;DataTypesEnum, NxsUnsignedSet&gt;. This map will be empty if the datatype is not mixed. For mixed datatypes, you can use the map to find the indices of the columns in that matrix that are of the same type (and should thus share the same GetDatatypeMapperForChar).</p>
<p>If you have enable symbols list augmenting, then you should be prepared to deal with characters blocks that report <a class="el" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca53544b6c478de9117d5e98a66e5f20d1" title="indicates `matrix&#39; holds continuous data">NxsCharactersBlock::mixed</a> from <a class="el" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&#39; from the datatype mapper.">NxsCharactersBlock::GetDataType()</a>, but report a molecular sequence type from <a class="el" href="classNxsCharactersBlock_a1feb957ad6d097cc94337d7f57776bb9.html#a1feb957ad6d097cc94337d7f57776bb9" title="Returns datatype listed in the CHARACTERS block.">NxsCharactersBlock::GetOriginalDataType()</a>. This is not too hard, but is tedious. By looking at the symbols list returned from the <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a>, you can figure out the order of symbols in the augmented type and you can interpret any cell of the matrix correctly. Note that this type of matrix can occur even if you call SetConvertAugmentedToMixed(true), because some matrices defy automatic conversion. In such cases, the safest course is usually to use code like this: </p>
<div class="fragment"><pre class="fragment">    ... (after the parsing).
    <a class="code" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> * taxa = reader.GetTaxaBlock(0)
    <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> * charsBlock = reader.GetCharactersBlock(taxa, 0)
    <span class="keywordflow">if</span> (charsBlock-&gt;<a class="code" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&amp;#39; from the datatype mapper.">GetDataType</a>() == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca53544b6c478de9117d5e98a66e5f20d1" title="indicates `matrix&amp;#39; holds continuous data">NxsCharactersBlock::mixed</a>)
        {
        }
    <span class="keywordflow">else</span> {
        <span class="keywordflow">if</span> (charsBlock-&gt;<a class="code" href="classNxsCharactersBlock_a1feb957ad6d097cc94337d7f57776bb9.html#a1feb957ad6d097cc94337d7f57776bb9" title="Returns datatype listed in the CHARACTERS block.">GetOriginalDataType</a>() != charsBlock-&gt;<a class="code" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&amp;#39; from the datatype mapper.">GetDataType</a>())
            <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Sorry the symbols list of a sequence datatype has been augmented with extra symbols, and now I cannot diagnose the datatype.  Please edit the file to separate the different types of data into separace CHARACTERS blocks or to use the:\n FORMAT DATATYPE = MIXED(...)\nsyntax.&quot;</span>);
        <span class="keywordflow">if</span> (charsBlock-&gt;<a class="code" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&amp;#39; from the datatype mapper.">GetDataType</a>() == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca0145b9755a4581acaabe1e4c458d7f73" title="indicates `matrix&amp;#39; holds characters with arbitrarily-assigned, discrete states...">NxsCharactersBlock::dna</a>)
            {
            ...code here to deal with DNA data...
            }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (charsBlock-&gt;<a class="code" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&amp;#39; from the datatype mapper.">GetDataType</a>() == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca9cb7e8ceb8521a96df0b81ecac913814" title="indicates `matrix&amp;#39; holds DNA sequences (states A, C, G, T)">NxsCharactersBlock::rna</a>)
            {
            ...code here to deal with RNA data...
            }
        <span class="keywordflow">else</span> ...
        }
</pre></div><h2><a class="anchor" id="improveperformance">
Improving Performance</a></h2>
<p>To speed up parsing of CHARACTERS blocks (and reduce memory usage):<br/>
 If you compile NCL with the preprocessor flag NCL_SMALL_STATE_CELL, then the typdef NxsDiscreteStateCell will be a <code>signed char</code> instead of <code>int</code>. This can improve performance some (at the cost of making it possible to overflow the number state codes that can be handled).</p>
<p>To speed up processing of TREES blocks see <a class="el" href="classNxsTreesBlock_ade045780deec6888fa06000a10966123.html#ade045780deec6888fa06000a10966123" title="This function allows you to register a callback function that is called after each...">NxsTreesBlock::setValidationCallbacks()</a>.</p>
<h2><a class="anchor" id="indexingObjects">
Indexing objects</a></h2>
<p>Like everything else in C/C++, NCL uses indexing that starts at 0.</p>
<p>The NEXUS file format starts numbering at 1. NCL has the correct behavior as it parses a file, but if you query for an object by passing in the index of the object you should use 0-based numbering. If you query for an object with a string, and the string is a string representation of an integer, then the NEXUS (1-based rules) will be used.</p>
<p>So, <code>NxsTaxaBlock::GetTaxonLabel(0)</code> will return the label for the first taxon in the matrix (the taxon that can also be referred to in a file by the string "1").</p>
<p>NCL uses the (admittedly <em>ad hoc</em>) convention that functions that use the word Number refer to 1-based numbering, and those that use index refer to 0-based numbering scheme.</p>
<hr/>
 Next see <a class="el" href="FAQ.html">NCL FAQ</a> for other common questions</p>
<hr/>
 Brief Directory:<br/>
</p>
<ul>
<li><a class="el" href="index.html#introduction">What is the NCL?</a></li>
<li><a class="el" href="basicAPI.html">The Basics of the NCL API</a></li>
<li><a class="el" href="simpleextract.html">Getting information out of NCL</a></li>
<li><a class="el" href="LessStrict.html">Making NCL less strict</a></li>
<li><a class="el" href="Gotchas.html">Quirks and Gotchas</a></li>
<li><a class="el" href="FAQ.html">NCL FAQ</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Mar 29 16:37:12 2010 for NCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
