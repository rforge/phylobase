<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>NCL: Getting information out of NCL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="ncl.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="simpleextract">Getting information out of NCL </a></h1><ul>
<li><a class="el" href="simpleextract.html#accessblocks">Getting NxsBlock Reader instances from the reader.</a></li>
<li><a class="el" href="simpleextract.html#queryblocks">Getting information out of the NxsBlock objects</a><ul>
<li><a class="el" href="simpleextract.html#NxsTaxaBlockQueries">Getting information out of a NxsTaxaBlock</a></li>
<li><a class="el" href="simpleextract.html#NxsCharactersBlockQueries">Getting information out of a NxsCharactersBlock</a></li>
<li><a class="el" href="simpleextract.html#NxsTreesBlockQueries">Getting information out of a NxsTreesBlock</a></li>
<li><a class="el" href="simpleextract.html#NxsAssumptionsBlockQueries">Getting information out of a NxsAssumptionsBlockBlock</a></li>
<li><a class="el" href="simpleextract.html#NxsUnalignedBlockQueries">Getting information out of a NxsUnalignedBlock</a></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="accessblocks">
Getting NxsBlock Reader instances from the reader.</a></h2>
<p>The <a class="el" href="classMultiFormatReader.html" title="A special class of PublicNexusReader, that can parse.">MultiFormatReader</a> uses factories to read the NEXUS blocks that are encountered. Because we do not know how many NEXUS blocks will be in the file, we now have to figure out how many <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> objects were created. One way to do this would be to call the reader's <a class="el" href="classNxsReader_a288fce08baf8efb5c6fc6c36842900b8.html#a288fce08baf8efb5c6fc6c36842900b8" title="Returns a list of all blocks that the NxsReader knows have been read and have NOT...">NxsReader::GetUsedBlocksInOrder()</a> method, walk through the list of NxsBlocks that were returned, ask each block what type it is (using the GetID() method <a class="el" href="Gotchas.html#BlockTypeIDDiscussion">Block Type IDs or Block IDs</a>), and the up-casting them to the appropriate type.</p>
<p>This procedure works, but is tedious (and the casting by client code makes it not-type-safe).</p>
<p>Almost all data from NEXUS files (or other phylogenetic datasets) is connected in some way to what NEXUS refers to as TAXA. Thus, NCL's <a class="el" href="classPublicNexusReader.html" title="A NxsReader that uses clone factories to read public blocks.">PublicNexusReader</a>, and classes derived from it, also offer an interface for extracting data with reference to a set of taxa. In particular, client code can "ask" the reader how many TAXA blocks were read and then ask how many CHARACTERS, TREES, or ASSUMPTIONS blocks are associated with each TAXA block.</p>
<p>The snippet below demonstrates the use of this API: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classMultiFormatReader.html" title="A special class of PublicNexusReader, that can parse.">MultiFormatReader</a> nexusReader(-1, <a class="code" href="classNxsReader_aae1b69753e31aba3ff7e4b48a5afba95.html#aae1b69753e31aba3ff7e4b48a5afba95a0b0c59f3609e43fd90018b8320345a44">NxsReader::WARNINGS_TO_STDERR</a>);
nexusReader.ReadFilepath(argv[1], MultiFormatReader::NEXUS_FORMAT);

<span class="keywordtype">int</span> numTaxaBlocks = nexusReader.GetNumTaxaBlocks();
std::cout &lt;&lt; numTaxaBlocks &lt;&lt; <span class="stringliteral">&quot; TAXA block(s) read.\n&quot;</span>;
<span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numTaxaBlocks; ++i)
    {
    <a class="code" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> * taxaBlock = nexusReader.GetTaxaBlock(i);
    std::string taxaBlockTitle = taxaBlock-&gt;GetTitle();
    std::cout &lt;&lt; <span class="stringliteral">&quot;Taxa block index &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; has the Title \&quot;&quot;</span> &lt;&lt;
taxaBlockTitle &lt;&lt; <span class="stringliteral">&quot;\&quot;\n&quot;</span>;

    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nCharBlocks = nexusReader.GetNumCharactersBlocks(taxaBlock);
    std::cout  &lt;&lt;  nCharBlocks &lt;&lt; <span class="stringliteral">&quot; CHARACTERS/DATA block(s) refer to this TAXA</span>
<span class="stringliteral">block\n&quot;</span>;
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; nCharBlocks; ++j)
        {
        <span class="keyword">const</span> <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> * charBlock =
nexusReader.GetCharactersBlock(taxaBlock, j);
        std::string charBlockTitle = taxaBlock-&gt;GetTitle();
        std::cout &lt;&lt; <span class="stringliteral">&quot;Taxa block index &quot;</span> &lt;&lt; j &lt;&lt; <span class="stringliteral">&quot; has the Title \&quot;&quot;</span> &lt;&lt;
charBlockTitle &lt;&lt; <span class="stringliteral">&quot;\&quot;\n&quot;</span>;
        }
    }
</pre></div><h3><a class="anchor" id="queryblocks">
Getting information out of the NxsBlock objects</a></h3>
<p>Each specific class of block has its own public API for extracting the block-specific information see:</p>
<ul>
<li><a class="el" href="simpleextract.html#NxsTaxaBlockQueries">Getting information out of a NxsTaxaBlock</a></li>
<li><a class="el" href="simpleextract.html#NxsCharactersBlockQueries">Getting information out of a NxsCharactersBlock</a></li>
<li><a class="el" href="simpleextract.html#NxsTreesBlockQueries">Getting information out of a NxsTreesBlock</a></li>
<li><a class="el" href="simpleextract.html#NxsAssumptionsBlockQueries">Getting information out of a NxsAssumptionsBlockBlock</a></li>
<li><a class="el" href="simpleextract.html#NxsUnalignedBlockQueries">Getting information out of a NxsUnalignedBlock</a></li>
</ul>
<p>The example file at <a href="simpleNCLClient/simpleNCLClient.cpp">simpleNCLClient.cpp</a> demonstrates queries to the <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> and both styles of querying the <a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a>. It can be compiled with <a href="simpleNCLClient/Makefile">Makefile</a>. More functions will be added to this example soon to demonstrate the trees block queries.</p>
<h2><a class="anchor" id="NxsTaxaBlockQueries">
Getting information out of a NxsTaxaBlock</a></h2>
<p>The easiest method to use is <a class="el" href="classNxsTaxaBlockAPI_aaf998f694825a2b7b278b759fcc5ba9f.html#aaf998f694825a2b7b278b759fcc5ba9f">NxsTaxaBlock::GetAllLabels()</a>, but you can also call <a class="el" href="classNxsTaxaBlock_ac378f8124ebabee587ea888034324617.html#ac378f8124ebabee587ea888034324617">NxsTaxaBlock::GetNTax()</a> and then ask for the label of any index in the range [0, nTax), using <a class="el" href="classNxsTaxaBlock_a7158ab9933607eac7f7cad5d2c1573e6.html#a7158ab9933607eac7f7cad5d2c1573e6">NxsTaxaBlock::GetTaxonLabel()</a>.</p>
<p>If you have a taxon label and w, then you can get its index (starting at 0) using the <a class="el" href="classNxsTaxaBlock_ad6d2d18ca9d43e8f001fb989ff50f810.html#ad6d2d18ca9d43e8f001fb989ff50f810" title="Returns a (0-based) index of taxon named &#39;s&#39; in taxonLabels list.">NxsTaxaBlock::FindTaxon()</a> function, but you have to catch NxsX_NoSuchTaxon exceptions to deal with labels that are not known.</p>
<h2><a class="anchor" id="NxsCharactersBlockQueries">
Getting information out of a NxsCharactersBlock</a></h2>
<p>Both CHARACTERS and DATA blocks will be parsed into instances of <a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a>.</p>
<p>The recommended querying functions are NxsCharactersBlock::GetNCharTotal() to get the total number of characters.</p>
<p><a class="el" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&#39; from the datatype mapper.">NxsCharactersBlock::GetDataType()</a> returns a facet of the <a class="el" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290c" title="values used to represent different basic types of data stored in a CHARACTERS block...">NxsCharactersBlock::DataTypesEnum</a> indicated the broad category of datatype that is stored in the matrix. Because NEXUS allows users to add symbols and equate codes, the normal datatypes can be "augmented." So the GetDataType gives you a sense of the <em>minimal</em> number of state codes.</p>
<h3><a class="anchor" id="SimpleCharStateQuery">
The simplest queries of character states</a></h3>
<p>The old (v2.0) style queries used a call to <a class="el" href="classNxsCharactersBlock_a6427d3164f24f1b8ad08f5ecc154874e.html#a6427d3164f24f1b8ad08f5ecc154874e">NxsCharactersBlock::GetSymbols()</a> to get the list of symbols. Then for each cell, the client code had to call <a class="el" href="classNxsCharactersBlock_a844c584f989e09fafd25893973751ade.html#a844c584f989e09fafd25893973751ade" title="Returns true iff taxon `taxInd` has a gap for character `charInd` (both indices 0-based)...">NxsCharactersBlock::IsGapState()</a>, and <a class="el" href="classNxsCharactersBlock_a26a2f859f7b8c0d45a753675cf53d942.html#a26a2f859f7b8c0d45a753675cf53d942" title="Returns true iff taxon `taxInd` has is missing for character `charInd` (both indices...">NxsCharactersBlock::IsMissingState()</a> to check for gaps and missing data. If the cell was not a gap or missing then you would call <a class="el" href="classNxsCharactersBlock_ad04cb5515e9d67d0bc3f8953f78f6439.html#ad04cb5515e9d67d0bc3f8953f78f6439" title="This function is no longer the most efficient way to access parsed data (see notes...">NxsCharactersBlock::GetNumStates()</a> to find the size of the state set, and then a call to <a class="el" href="classNxsCharactersBlock_af0484095c6da5a8d38af1f129d6e5e97.html#af0484095c6da5a8d38af1f129d6e5e97" title="Returns symbol from symbols list representing the state for taxon `i&#39; and character...">NxsCharactersBlock::GetState()</a> to get each state in the state set. For those cells that have multiple states, you would have to call <a class="el" href="classNxsCharactersBlock_ae86148be4403ce70ab5c23b01a7130ee.html#ae86148be4403ce70ab5c23b01a7130ee" title="Returns true iff taxon `taxInd` has is missing for character `charInd` (both indices...">NxsCharactersBlock::IsPolymorphic()</a> to determine if the multiple states represented polymorphism or uncertainty.</p>
<p>So the code to print out a matrix as NEXUS would look like this: </p>
<div class="fragment"><pre class="fragment"><span class="comment">/* Example of the simplest (v2.0) querying for character block content */</span>
<span class="keywordtype">void</span> printMatrixWithoutLabels(std::ostream &amp; out, <span class="keyword">const</span> <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> *cb)
    {
    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nc = cb-&gt;<a class="code" href="classNxsCharactersBlock_a5f984e07256fa1055b04210484301046.html#a5f984e07256fa1055b04210484301046">GetNCharTotal</a>();
    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nt = cb-&gt;GetNTaxTotal()
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; nt
    <span class="keywordflow">if</span> (matrix-&gt;IsMissing(d))
        {
        s[0] = missing;
        s[1] = <span class="charliteral">&#39;\0&#39;</span>;
        }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (matrix-&gt;IsGap(d))
        {
        s[0] = gap;
        s[1] = <span class="charliteral">&#39;\0&#39;</span>;
        }
    <span class="keywordflow">else</span>
        {
        assert(symbols != NULL);
        <span class="keywordtype">unsigned</span> symbolListLen = strlen(symbols);

        <span class="keywordtype">unsigned</span> numStates = matrix-&gt;GetNumStates(d);
        <span class="keywordtype">unsigned</span> numCharsNeeded = numStates;
        <span class="keywordflow">if</span> (numStates &gt; 1)
            numCharsNeeded += 2;
        assert(slen &gt; numCharsNeeded);

        <span class="keywordflow">if</span> (numStates == 1)
            {
            <span class="keywordtype">unsigned</span> v = matrix-&gt;GetState(d);
            assert(v &lt; symbolListLen);
            s[0] = symbols[v];
            s[1] = <span class="charliteral">&#39;\0&#39;</span>;
            }

        <span class="keywordflow">else</span>
            {
            <span class="comment">// numStates must be greater than 1</span>
            <span class="comment">//</span>
            <span class="keywordtype">unsigned</span> i = 0;
            <span class="keywordflow">if</span> (matrix-&gt;IsPolymorphic(d))
                s[i++] = <span class="charliteral">&#39;(&#39;</span>;
            <span class="keywordflow">else</span>
                s[i++] = <span class="charliteral">&#39;{&#39;</span>;
            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 0; k &lt; numStates; k++)
                {
                <span class="keywordtype">unsigned</span> v = matrix-&gt;GetState(d, k);
                assert(v &lt; symbolListLen);
                s[i++] = symbols[v];
                s[i] = <span class="charliteral">&#39;\0&#39;</span>;
                }
            <span class="keywordflow">if</span> (matrix-&gt;IsPolymorphic(d))
                s[i++] = <span class="charliteral">&#39;)&#39;</span>;
            <span class="keywordflow">else</span>
                s[i++] = <span class="charliteral">&#39;}&#39;</span>;
            s[i] = <span class="charliteral">&#39;\0&#39;</span>;
            }
        }
</pre></div><p> This API is still supported. However:</p>
<ul>
<li>It is possible for NEXUS file contain a matrix without symbols. Since GetState, returns the symbol, This API will not work on such matrices.</li>
<li>the API is less effcient than the newer api (it results in a lot more function calling).</li>
</ul>
<h3><a class="anchor" id="newerCharQueries">
Efficient character queries.</a></h3>
<p>If you need to extract large amounts of data out of NCL, you often need something more efficient than the code described in the "<a class="el" href="simpleextract.html#SimpleCharStateQuery">The simplest queries of character states</a>" section. This usually occurs with applications that support sequence data sets.</p>
<p>In version 2.1 and higher of NCL, you can asked for a reference to the internal storage of the character data. If you need to convert the NCL storage into your own format, you can the efficiently walk down the array of state codes and get the information that you need. This requires that you know a little bit about how NCL stores the data.</p>
<p>Internally the cells of the matrix are stored as integers that are referred to in the library as "state codes." State codes include the "fundamental states" for a type (such as 0=&gt;"A", 1=&gt;"C", 2=&gt;"G", 3=&gt;"T" for DNA), but also the ambiguity codes (4="{ACGT}" for DNA).</p>
<p>The Missing data concept and the Gap concept have their own state codes. Use NXS_MISSING_CODE and NXS_GAP_STATE_CODE to refer to these states. But you can rely on the fact that these codes are -1 and -2 respectively.</p>
<p>To decode these internal state codes into the symbols that occur in a file to describe a datatype, NCL stores a <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> object. The <a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> "knows" which <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> instance applies to each column of the matrix. When you do not have a "mixed" datatype, then the same <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> instance will apply to every column.</p>
<h3><a class="anchor" id="GettingMapper">
The role of the NxsDiscreteDatatypeMapper</a></h3>
<p>NEXUS allows users to add symbols and equates (which are like macros) to a datatypes. In NCL, addition of symbols to a sequence type is only supported if you have called <a class="el" href="classNxsCharactersBlock_a03323afe931168034735ad2be8a4ed8c.html#a03323afe931168034735ad2be8a4ed8c" title="Instructs the NxsCharactersBlock to accept extra symbols even if the datatype is...">NxsCharactersBlock::SetAllowAugmentingOfSequenceSymbols()</a> with the argument true before parsing the file. This will result in the datatype becoming "standard" type if extra symbols are found (see <a class="el" href="Gotchas.html#mixedDatatypes">Dealing with Datatype=Mixed</a>).</p>
<p>Because datatypes in NEXUS are actually richer than a simple enumeration, you often need to deal with the a <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> object. You can call NxsCharactersBlock::GetDatatypeMapperForChar() to get the mapper for a particular column. If the datatype is not mixed, then this function will return the same mapper object for every column.</p>
<p>If you do want to support mixed datatype, then you can call: <a class="el" href="classNxsCharactersBlock_a35de45b0d15c97f9b68043d5e8dd2705.html#a35de45b0d15c97f9b68043d5e8dd2705">NxsCharactersBlock::GetAllDatatypeMappers()</a> to get all of the mappers used in a matrix, and then use the result of <a class="el" href="classNxsCharactersBlock_a886919f70994b6d9339ccae1346c0a08.html#a886919f70994b6d9339ccae1346c0a08">NxsCharactersBlock::GetDatatypeMapForMixedType()</a> to figure out what set of characters is used by each mapper (this is equivalent to asking for the mapper for each character, but it is often easier to deal with the data by walking through the characters associated with each mapper.</p>
<p>If you just want to support the molecular sequence types, you still have to be aware that the user may have added new equates that generate new state codes, and that polymorphism codes can occur in the matrix. So there can be some extra state codes to deal with. An equate is usually "syntactic sugar" that gives users another way to express the same content (for example, "Y" instead of "{TC}"). By default, the molecular sequence types come with some equates to represent these ambiguity codes. But the user can introduce new equates that represent polymorphism: in NEXUS "(TC)" means a taxon is polymorphic for T and C, while "{TC}" means that a taxon could have either state ("partially ambiguous").</p>
<p>Many applications want to parse only the molecular sequence datatypes and do not want to go through the trouble of supporting additional state code. The easiest way to tell if the characters block is going to require "special handling" is to create a default block of the same general type using the NxsDiscreteDatatypeMapper(NxsDatatypeEnum, bool) constructor, and then compare it to the NxsCharactersBlock's mapper using <a class="el" href="classNxsDiscreteDatatypeMapper_a495505622d8540b88cd03c0f41ac8154.html#a495505622d8540b88cd03c0f41ac8154">NxsDiscreteDatatypeMapper::IsSemanticallyEquivalent()</a>. If that function returns true, then you may treat the state codes from the matrix as if they were the unmodified datatype (the NEXUS file might contain some syntactic equates, if the mappers are syntactically equivalent the matrix will not contain polymorphic codes. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> *mapper = charBlock.GetDatatypeMapperForChar(0);
            <span class="keyword">const</span> <span class="keywordtype">bool</span> hasGaps = charBlock.<a class="code" href="classNxsCharactersBlock_a25f1d2be3465fd9dafb97be50d8e2601.html#a25f1d2be3465fd9dafb97be50d8e2601" title="Returns the gap symbol currently in effect.">GetGapSymbol</a>() != <span class="charliteral">&#39;\0&#39;</span>;

            <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> defaultMapper(<a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca0145b9755a4581acaabe1e4c458d7f73" title="indicates `matrix&amp;#39; holds characters with arbitrarily-assigned, discrete states...">NxsCharactersBlock::dna</a>, hasGaps);
            <span class="keywordflow">if</span> (mapper-&gt;<a class="code" href="classNxsDiscreteDatatypeMapper_a495505622d8540b88cd03c0f41ac8154.html#a495505622d8540b88cd03c0f41ac8154">IsSemanticallyEquivalent</a>(&amp;defaultMapper))
                {
                <span class="comment">// the datatype has not been changed in a substantive way.</span>
                }
            <span class="keywordflow">else</span>
                {
                <span class="comment">// new state codes have been introduced, so routines that do not</span>
                <span class="comment">//  interrogate the mapper to check the mapper about the status of all of the</span>
                <span class="comment">//  states may fail.</span>
                }
</pre></div><h3><a class="anchor" id="GettingStateCodes">
Getting access to the state codes.</a></h3>
<p>You can obtain a <a class="el" href="classNxsCharactersBlock_a2840b32dd8053a925a9c777911f6b659.html#a2840b32dd8053a925a9c777911f6b659">NxsCharactersBlock::GetDiscreteMatrixRow()</a></p>
<p>The example file at <a href="simpleNCLClient/simpleNCLClient.cpp">simpleNCLClient.cpp</a> demonstrates queries to the <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> and both styles of querying the <a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a>. It can be compiled with <a href="simpleNCLClient/Makefile">Makefile</a></p>
<h3><a class="anchor" id="OtherCharQuery">
useful NxsCharactersBlock queries</a></h3>
<p><a class="el" href="classNxsCharactersBlock_a5d2cc904b64a099693654b8844a82e75.html#a5d2cc904b64a099693654b8844a82e75" title="Returns true If character `taxInd&#39; has some stored character state.">NxsCharactersBlock::TaxonIndHasData()</a> can be used to see if an entire row is present in the matrix (if false, then the taxon had no data read).</p>
<p>Characters can be flagged is inactive (aka "excluded" or "eliminated" - unfortunately, these three terms are synonymous in NCL), by <a class="el" href="classNxsCharactersBlock_ae724d86e3ec64f4ee56962e69eabdb0b.html#ae724d86e3ec64f4ee56962e69eabdb0b" title="excludes all of the indices in exset.">NxsCharactersBlock::ApplyExset()</a>. They can be reincluded by <a class="el" href="classNxsCharactersBlock_a39d83d6ddebf1b5abeda386812577d04.html#a39d83d6ddebf1b5abeda386812577d04" title="includes all of the indices in exset.">NxsCharactersBlock::ApplyIncludeset()</a>. To exclude/include a single character (rather than a set) use <a class="el" href="classNxsCharactersBlock_a5c12fb5d3295cce9292839d9fe774e1b.html#a5c12fb5d3295cce9292839d9fe774e1b" title="excludes character `i`">NxsCharactersBlock::ExcludeCharacter()</a> and <a class="el" href="classNxsCharactersBlock_a77cae32fe241edccb568c974f84f4d6e.html#a77cae32fe241edccb568c974f84f4d6e" title="includes character `i`">NxsCharactersBlock::IncludeCharacter()</a>. The accessors <a class="el" href="classNxsCharactersBlock_a70ac339754cea27d384d18a3835c446d.html#a70ac339754cea27d384d18a3835c446d" title="Returns the number of characters that have not been exclude (via exset or eliminate...">NxsCharactersBlock::GetNumActiveChar()</a>, <a class="el" href="classNxsCharactersBlock_a62d5344a796517202436048b6befeeef.html#a62d5344a796517202436048b6befeeef">NxsCharactersBlock::GetExcludedIndexSet()</a>, and <a class="el" href="classNxsCharactersBlock_a1a2ac1c77126d46dab11200bc1869258.html#a1a2ac1c77126d46dab11200bc1869258">NxsCharactersBlock::IsActiveChar()</a> are useful for determining which columns are currently flagged as excluded.</p>
<p>Character labels (and state labels) are supported see <a class="el" href="classNxsCharactersBlock_a8091ed0c604ab1783eb8fd2ea92cb0f8.html#a8091ed0c604ab1783eb8fd2ea92cb0f8" title="Returns true if at least one character has charlabels.">NxsCharactersBlock::HasCharLabels()</a> and <a class="el" href="classNxsCharactersBlock_a99fc213df068594d9ee09fe7751d3c67.html#a99fc213df068594d9ee09fe7751d3c67" title="Returns label for character `i&#39; (starting at zero), if a label has been specified...">NxsCharactersBlock::GetCharLabel()</a>.</p>
<p>The instruction on how gaps should be interpretted in analyses such as parsimony tree scoring is contained in the <code>Options</code> command of the ASSUMPTIONS block, but when read the block will "inform" the <a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> instance. The setting can be retrieved <a class="el" href="classNxsCharactersBlock_aeca34234f6ae4752d85738f9435eb36b.html#aeca34234f6ae4752d85738f9435eb36b">NxsCharactersBlock::GetGapModeSetting()</a>. StepMatrices can be retreived by requesting the NxsCharactersBlock's "TransformationManager" (using the NxsCharactersBlock::GetNxsTransformationManagerRef() method) and querying that object.</p>
<p>To interpret and query for cells of continuous data matrices, use <a class="el" href="classNxsCharactersBlock_ae86ee83384065f3c9a95e7670c7ebd78.html#ae86ee83384065f3c9a95e7670c7ebd78">NxsCharactersBlock::GetStatesFormat()</a> to figure out if the cells represent states or individuals. <a class="el" href="classNxsCharactersBlock_ad72498c30823755d76f7f1c47cac1dec.html#ad72498c30823755d76f7f1c47cac1dec" title="Returns the list of items that will be in each cell.">NxsCharactersBlock::GetItems()</a> to get the vector of the items (or "keys" stored for each cell. Then to retreive the value for a item at a particular cell, use <a class="el" href="classNxsCharactersBlock_a156b6cbe87a34912da7fb46dcb599b86.html#a156b6cbe87a34912da7fb46dcb599b86" title="Accessor for getting the list of continuous values associated with an &quot;ITEM...">NxsCharactersBlock::GetContinuousValues()</a>.</p>
<h2><a class="anchor" id="NxsTreesBlockQueries">
Getting information out of a NxsTreesBlock</a></h2>
<p>The recommended functions to be called are: <a class="el" href="classNxsTreesBlock_ab8482cf659047135f64473ae241eae70.html#ab8482cf659047135f64473ae241eae70" title="Returns the number of trees stored in this NxsTreesBlock object.">NxsTreesBlock::GetNumTrees</a> and <a class="el" href="classNxsTreesBlock_a10a948bdee7dc2c228fc62241ddd7f37.html#a10a948bdee7dc2c228fc62241ddd7f37">NxsTreesBlock::GetFullTreeDescription()</a>.</p>
<p>The tree is validated during the parse and then stored as a <a class="el" href="classNxsFullTreeDescription.html" title="A class that encapsulates a newick string description of a tree and metadata about...">NxsFullTreeDescription</a> object which will hold the newick string.</p>
<p>See <a class="el" href="Gotchas.html#improveperformance">Improving Performance</a> for a discussion of the setValidationCallbacks function that can be used to improve the efficiency of the parsing of files with large TREES blocks.</p>
<h3><a class="anchor" id="processingTrees">
"Processed" trees</a></h3>
<p>By default, in v2.1 the trees block will "process" trees so that the newick string will have numbers rather than names. The numbers in the tree string start at 1 (like other NEXUS numbering), but they are simply 1 + the taxon index. If trees have been processed then the client code does not have to worry about using the translate table or even calls to the taxa block associated with the <a class="el" href="classNxsTreesBlock.html" title="This class handles reading and storage for the NEXUS block TREES.">NxsTreesBlock</a> in order to decode the taxon labels.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>In previous versions of NCL (before v2.1), the client code would have to use the translate table to convert the newick string into the taxon numbers. As of v2.1, NCL now does this translation for you. This means that code must be adapted to the new API! If the translation table registers numubers that are not in agreement with the taxon numbering, then the old style <a class="el" href="classNxsTreesBlock_aa00e91e2ff1a4482d6c162ccc3486eef.html#aa00e91e2ff1a4482d6c162ccc3486eef">NxsTreesBlock::GetTreeDescription()</a> would return untranslated aliases, the v2.1 API's <a class="el" href="classNxsTreesBlock_aa00e91e2ff1a4482d6c162ccc3486eef.html#aa00e91e2ff1a4482d6c162ccc3486eef">NxsTreesBlock::GetTreeDescription()</a> will return a tree string that has translated the tree into taxon numbers. The old-style parsing can be enabled by calling <a class="el" href="classNxsTreesBlock_afddf08b5cb137819969c582beddd5c7e.html#afddf08b5cb137819969c582beddd5c7e" title="If true then the block will use the v2.1 style of parsing in which the tree is interpretted...">NxsTreesBlock::SetProcessAllTreesDuringParse()</a> with false as an argument.</dd></dl>
<p>This non-backward compatible change was made because it is actually quite tricky to do the name translation: code has to check the translate table first. If the taxon string is not found then you have to taxset names, then the taxon labels, then interpret the label as a number (that is correct, while you can use a TRANSLATE command to register short numeric aliases of taxa, NEXUS's implicit numbering means that you can use numbers for taxa even if there is no TRANSLATE table). The other reason is that in order to generate implicit TAXA blocks, NCL needed to interpret the tree strings.</p>
<p>The up-side of this change is that it is much easier for new client code to deal with the multiplicity of ways of expressing a tree. NCL will return an more normalized newick string.</p>
<p>Also note that <a class="el" href="classNxsTreesBlock_aad4276c6d0813bfafb138f55a6f42ad5.html#aad4276c6d0813bfafb138f55a6f42ad5" title="Returns the description of the tree with index `i&#39; where i is in [0..ntrees)...">NxsTreesBlock::GetTranslatedTreeDescription()</a> has not changed. The downside of this function, is that the client code has to do a full NEXUS parse of the string, because the newick string returned may have names with spaces and other weird characters that complicate simple parsing.</p>
<h3><a class="anchor" id="treeRooting">
Tree rooting</a></h3>
<p>NCL uses the convention that the TREE command means a rooted tree while the UTREE command means an unrooted tree. However the presence of a rooting "command comment" ([&amp;U] for unrooted or [&amp;R] for rooted) before the tree will override this behavior.</p>
<p>Unfortunately, if the <a class="el" href="classNxsFullTreeDescription.html" title="A class that encapsulates a newick string description of a tree and metadata about...">NxsFullTreeDescription</a> reports that it is rooted, it is currently impossible for the client code to detect whether that rooting interpretation is simply the default for the tree or whether it was assigned based on a command comment.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>{In the future we will store a separate flag that indicates whether or not the rooting interpretation is based on an explicit syntax in the file.}</dd></dl>
<h3><a class="anchor" id="NHXcomments">
NHX style comments.</a></h3>
<p>NCL has some limited support for New Hampshire extended comments (see <a href="http://www.phylosoft.org/NHX">http://www.phylosoft.org/NHX</a>). If you create a <a class="el" href="classNxsSimpleTree.html" title="A simple tree class.">NxsSimpleTree</a> object, from a <a class="el" href="classNxsFullTreeDescription.html" title="A class that encapsulates a newick string description of a tree and metadata about...">NxsFullTreeDescription</a>, then the <a class="el" href="classNxsSimpleEdge.html" title="The edge used by the NxsSimpleTree class.">NxsSimpleEdge</a> objects of the tree will have mappings of NHX keys to strings that are generated from the NHX comments in the tree string. See <a class="el" href="classNxsSimpleEdge_acb16cfb8f0f30ce1892904bbc779a8b4.html#acb16cfb8f0f30ce1892904bbc779a8b4">NxsSimpleEdge::GetInfo()</a>.</p>
<p>Only the key-value NHX comment information is parsed (the bare tag and branch length syntax are not supported).</p>
<h2><a class="anchor" id="NxsAssumptionsBlockQueries">
Getting information out of a NxsAssumptionsBlockBlock</a></h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>{docs needed}</dd></dl>
<h2><a class="anchor" id="NxsUnalignedBlockQueries">
Getting information out of a NxsUnalignedBlock</a></h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>{docs needed}</dd></dl>
<hr/>
 Next see <a class="el" href="LessStrict.html">Making NCL less strict</a> for info on how to get NCL to accept more files</p>
<hr/>
 Brief Directory:<br/>
</p>
<ul>
<li><a class="el" href="index.html#introduction">What is the NCL?</a></li>
<li><a class="el" href="basicAPI.html">The Basics of the NCL API</a></li>
<li><a class="el" href="simpleextract.html">Getting information out of NCL</a></li>
<li><a class="el" href="LessStrict.html">Making NCL less strict</a></li>
<li><a class="el" href="Gotchas.html">Quirks and Gotchas</a></li>
<li><a class="el" href="FAQ.html">NCL FAQ</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Mar 29 16:37:12 2010 for NCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
