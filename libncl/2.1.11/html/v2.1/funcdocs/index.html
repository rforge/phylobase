<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>NCL: NCL v2.1 Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>NCL v2.1 Documentation </h1><h3 class="version">2.1 </h3><hr/>
 <h2><a class="anchor" id="TOC">
Table of contents</a></h2>
<ul>
<li><a class="el" href="index.html#introduction">What is the NCL?</a></li>
<li><a class="el" href="index.html#v2_0_to_2_1">Versions of the library.</a><ul>
<li><a class="el" href="index.html#backward">Backward compatibility</a></li>
<li><a class="el" href="index.html#whyDiff">Why is version 2.1 so different from version 2.0?</a></li>
<li><a class="el" href="index.html#v2_2">Version 2.2</a></li>
</ul>
</li>
<li><a class="el" href="index.html#download">Obtaining the NCL?</a><ul>
<li><a class="el" href="index.html#portability">Portability</a></li>
<li><a class="el" href="index.html#crossplatform">Cross-platform features</a></li>
</ul>
</li>
<li><a class="el" href="index.html#NexusCoverage">What parts of NEXUS are supported by NCL ?</a></li>
<li><a class="el" href="index.html#basicAPI">The Basics of the NCL API</a></li>
<li><a class="el" href="index.html#simpleparse">Simplest example of reading</a></li>
<li><a class="el" href="index.html#nonNexus">Reading non-NEXUS file formats</a></li>
<li><a class="el" href="index.html#simpleextract">Getting information out of NCL</a><ul>
<li><a class="el" href="index.html#accessblocks">Getting NxsBlock Reader instances from the reader.</a></li>
<li><a class="el" href="index.html#queryblocks">Getting information out of the NxsBlock objects</a><ul>
<li><a class="el" href="index.html#NxsTaxaBlockQueries">Getting information out of a NxsTaxaBlock</a></li>
<li><a class="el" href="index.html#NxsCharactersBlockQueries">Getting information out of a NxsCharactersBlock</a></li>
<li><a class="el" href="index.html#NxsTreesBlockQueries">Getting information out of a NxsTreesBlock</a></li>
<li><a class="el" href="index.html#NxsAssumptionsBlockQueries">Getting information out of a NxsAssumptionsBlockBlock</a></li>
<li><a class="el" href="index.html#NxsUnalignedBlockQueries">Getting information out of a NxsUnalignedBlock</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><a class="el" href="index.html#LessStrict">Making NCL less strict</a></li>
<li><a class="el" href="index.html#Gotchas">Quirks, Gotchas</a><ul>
<li><a class="el" href="index.html#MisleadingNames">Potentially Confusing Names.</a></li>
<li><a class="el" href="index.html#BlockTypeIDDiscussion">Block Type IDs or Block IDs</a></li>
<li><a class="el" href="index.html#impliedBlocks">"Implied" blocks</a></li>
<li><a class="el" href="index.html#taxaBlockScoping">"Scoping" of TAXA blocks</a></li>
<li><a class="el" href="index.html#memoryManagement">Managing Memory</a></li>
<li><a class="el" href="index.html#setsAssumptions">NxsAssumptionsBlock reads several types of blocks</a></li>
</ul>
</li>
<li><a class="el" href="index.html#FAQ">Frequently asked questions</a></li>
</ul>
<h2><a class="anchor" id="introduction">
What is the NCL?</a></h2>
<p>The NEXUS Class Library (NCL) is an integrated collection of C++ classes that parses several file formats used in evolutionary biology (NEXUS, PHYLIP, relaxed PHYLIP, and FASTA). NCL does not diagnose the file format, but if you configure a parser to read several formats, then you will be able to parse multiple formats and extract the data from NCL's data structures using the same API regardless of the file format.</p>
<p>This documentation is written for C++ programmers.</p>
<p>Version 2.0 of NCL itself was published as:</p>
<p>Lewis, P. O. 2003. NCL: a C++ class library for interpreting data files in NEXUS format. <em>Bioinformatics</em> <b>19</b> (17): 2330-2331. <a href="http://bioinformatics.oxfordjournals.org/cgi/content/abstract/19/17/2330?ijkey=80ZQtEjeuXmEU&amp;keytype=ref">[link to online resource]</a></p>
<p>See <a href="http://hydrodictyon.eeb.uconn.edu/ncl">http://hydrodictyon.eeb.uconn.edu/ncl</a> for documentation on version 2.0.</p>
<p>The NEXUS data file format was specified in the publication cited below (<a href="http://sysbio.oxfordjournals.org/cgi/reprint/46/4/590.pdf">this is a link to pdf of that paper</a>). Please read this paper for further information about the format specification itself; the documentation for the NCL does not attempt to explain the structure of a NEXUS data file.</p>
<p>Maddison, D. R., D. L. Swofford, and Wayne P. Maddison. 1997. NEXUS: an extensible file format for systematic information. <em>Systematic Biology</em> 46(4): 590-621.</p>
<hr/>
 <h2><a class="anchor" id="v2_0_to_2_1">
Versions of the library.</a></h2>
<h3><a class="anchor" id="backward">
Backward compatibility</a></h3>
<p>Despite several fundamental changes in the implementation of the library, we strive to keep NCL v2.1 backward compatible with version 2.0. A programmer that relied on version 2.0 should still work. If you discover that your client code works with version 2.0 of NCL, but not 2.1 please let us know.</p>
<hr/>
 <h3><a class="anchor" id="whyDiff">
Why is version 2.1 so different from version 2.0?</a></h3>
<p>Version 2.1 extends the functionality significantly by allowing NCL to parse files that use extended forms of NEXUS. Both Mesquite and MrBayes rely on extensions to NEXUS. Particularly difficult to handle are Mesquite's support for multiple blocks of the same type within a file (accompanied by linking blocks by title).</p>
<p>Version 2.0 of NCL followed a model of creating a <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> object and adding <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> objects which handle parsing of particular types of NEXUS content. Client code would typically inherit from base classes such as <a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a>, or would extract the information when a block was completely read. The <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> instance would be reset (by <a class="el" href="classNxsBlock_a3642d732dd82298ef2f35a7b83b97719.html#a3642d732dd82298ef2f35a7b83b97719" title="This virtual function should be overridden for each derived class to completely reset...">NxsBlock::Reset</a> call) before it was asked to handle another block.</p>
<p>Unfortunately, not all NEXUS blocks are autonomous (for example commands in an ASSUMPTIONS block may rely on information in a CHARACTERS block). Combining inter-block dependencies with the need to store information from multiple blocks of the same type means that NCL's version 2.0 API can be quite cumbersome. To read a file with a single instance of a <a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a>, the client code must carefully offload all of the information in a block before allowing parsing to proceed to the next block. Subsequent references between blocks have to be corrected so that blocks refer to the new location of the information (rather than the <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> instance that originally held the data).</p>
<p>A more natural design pattern for processing files which may have multiple blocks of the same type is to use a factory method. Users of NCL v2.1 can register <a class="el" href="classNxsBlockFactory.html" title="This abstract class defines the interface for a factory that can generate NxsBlocks...">NxsBlockFactory</a> instances with a <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a>. Then the reader can parse an entire file before having to pull the parsed information from the blocks.</p>
<hr/>
 <h3><a class="anchor" id="v2_2">
Version 2.2</a></h3>
<p>The svn branch for version 2.2 is very similar to 2.1. It only contains changes necessary to allow NCL to be callable from other languages via <a href="http://www.swig.org/">SWIG</a>. Some of the changes needed to ensure this were not backward-compatible. So they were added to branch 2.2.</p>
<p>C++ programmers should probably use 2.1 (although their code will almost certainly work on v2.2 as well)</p>
<hr/>
 <h2><a class="anchor" id="download">
Obtaining the NCL?</a></h2>
<p>The best link to use to get the latest (stable) version of NCL is from the <a href="http://sourceforge.net/projects/ncl/">sourceforge NCL project page.</a></p>
<p>If you want SVN access to the latest code, please use branches/v2.1 from the SVN checkout on Sourceforge.</p>
<hr/>
 <h3><a class="anchor" id="portability">
Portability</a></h3>
<p>The NCL has been designed to be as portable as possible for a C++ class library. Please let us know if you find a (reasonably modern) compiler that does not accept NCL.</p>
<hr/>
 <h3><a class="anchor" id="crossplatform">
Cross-platform features</a></h3>
<p>NCL does not rely on any external libraries. There are hooks (such as <a class="el" href="classNxsToken_a8bcc10cb8b852257dc0449491e74cbff.html#a8bcc10cb8b852257dc0449491e74cbff">NxsToken::OutputComment</a>) that allow client code to intercept messages that you may want to display as standard output (in commandline executables) or a graphical window (in GUIs).</p>
<hr/>
 <h2><a class="anchor" id="NexusCoverage">
What parts of NEXUS are supported by NCL ?</a></h2>
<p>NCL can interpret the following Blocks and commands.</p>
<p>Note that TITLE, BLOCKID are handle by all block types. LINK commands are handled where appropriate.</p>
<table class="doxtable">
<tr>
<td>Block Type ID </td><td>Commands</td><td>NCL Block Reader type </td></tr>
<tr>
<td>ASSUMPTIONS </td><td>CharPartition, CharSet, CodeSet, CodonPosSet, Options, TaxSet, TaxPartition, TreeSet, TreePartition, TypeSet, UserType, WtSet</td><td><a class="el" href="classNxsAssumptionsBlock.html" title="This class handles reading and storage for the NxsReader block ASSUMPTIONS.">NxsAssumptionsBlock</a> </td></tr>
<tr>
<td>CHARACTERS </td><td>Dimensions, Format, TaxLabels, CharStateLabels, CharLabels, StateLabels, Matrix</td><td><a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> </td></tr>
<tr>
<td>CODONS </td><td>(same as ASSUMPTIONS)</td><td><a class="el" href="classNxsAssumptionsBlock.html" title="This class handles reading and storage for the NxsReader block ASSUMPTIONS.">NxsAssumptionsBlock</a> </td></tr>
<tr>
<td>DATA </td><td>(same as CHARACTERS)</td><td><a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> </td></tr>
<tr>
<td>DISTANCES </td><td>Dimensions, Format, TaxLabels, Matrix</td><td><a class="el" href="classNxsDistancesBlock.html" title="This class handles reading and storage for the NEXUS block DISTANCES.">NxsDistancesBlock</a> </td></tr>
<tr>
<td>SETS </td><td>(same as ASSUMPTIONS)</td><td><a class="el" href="classNxsAssumptionsBlock.html" title="This class handles reading and storage for the NxsReader block ASSUMPTIONS.">NxsAssumptionsBlock</a> </td></tr>
<tr>
<td>TAXA </td><td>Dimensions, TaxLabels</td><td><a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> </td></tr>
<tr>
<td>TREES </td><td>Translate, Trees</td><td><a class="el" href="classNxsTreesBlock.html" title="This class handles reading and storage for the NEXUS block TREES.">NxsTreesBlock</a> </td></tr>
<tr>
<td>UNALIGNED </td><td>Dimensions, Format, TaxLabels, Matrix</td><td><a class="el" href="classNxsUnalignedBlock.html" title="This class handles reading and storage for the NEXUS block UNALIGNED.">NxsUnalignedBlock</a> </td></tr>
</table>
<hr/>
 <h2><a class="anchor" id="basicAPI">
The Basics of the NCL API</a></h2>
<p>The core API has not changed from version 2.0 to 2.1. NCL parses an std::istream by creating a <a class="el" href="classNxsToken.html">NxsToken</a> object around the stream (a better name for the class would be NxsTokenizer). Rather than using a low-level C++ istream operations, the <a class="el" href="classNxsToken.html">NxsToken</a> allows you to process a file by the NEXUS tokenizing rules - comments are skipped and NEXUS's quoting rules are obeyed.</p>
<p>A <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> instance is capable of reading an entire stream (usually a file) by interacting with the <a class="el" href="classNxsToken.html">NxsToken</a> until EOF is reached. The NxsReader's job is to identify the blocks in a file, and hand off the procesing of each block to an appropriate block reader (or skip the block if no reader is found).</p>
<p>The objects that read each block are instances of <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> (perhaps a better name for this class would be NxsBlockReader). After the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> chooses which block should handle a portion of NEXUS file, it will call the <a class="el" href="classNxsBlock_a3b7a229312d9182c6a7a3823d0e46a69.html#a3b7a229312d9182c6a7a3823d0e46a69" title="This virtual function must be overridden for each derived class to provide the ability...">NxsBlock::Read</a> function and pass in the <a class="el" href="classNxsToken.html">NxsToken</a> object which is poised to return tokens for the block that is to be read next.</p>
<p>Client code uses NCL by: </p>
<ul>
<li>creating a <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> object, </li>
<li>registering the <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> objects that will process all of the NEXUS blocks that are not to be skipped, </li>
<li>create a <a class="el" href="classNxsToken.html">NxsToken</a> object around the istream to be read, </li>
<li>calling the Execute(NxsToken) method of the reader, and </li>
<li>retrieving the parsed information from the NxsBlocks In version 2.0 of the API, the client would have to retrieve the information from <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> in hooks (such as NxsBlock::ExitingBlock) during the parse.</li>
</ul>
<p>The main extensions to this basic structure that are new to version 2.1 are </p>
<ul>
<li>The ability to register <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> factories rather than NxsBlocks (this enables parsing of the entire file, rather than requiring the client to harvest all of the information via hooks called during the parse); </li>
<li>public blocks have been extended to deal with the TITLE and LINK commands introduced by Mesquite; </li>
<li>other formats can be parsed by a special version of the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> called a <a class="el" href="classMultiFormatReader.html" title="A special class of PublicNexusReader, that can parse.">MultiFormatReader</a>; </li>
<li>various extensions to individual blocks (such as full implementation of ASSUMPTIONS block, and the addition of MrBayes' "Datatype=Mixed..." subcommand in the Characters block's FORMAT command; </li>
<li>"implied" blocks are now created during some parses</li>
</ul>
<hr/>
 <h2><a class="anchor" id="simpleparse">
Simplest example of reading</a></h2>
<p>The simplest (and admittedly least useful) NCL client that uses the version 2.1 API would be the following fragment:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;ncl/nxsmultiformat.h&quot;</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
<a class="code" href="classMultiFormatReader.html" title="A special class of PublicNexusReader, that can parse.">MultiFormatReader</a> nexusReader(-1, <a class="code" href="classNxsReader_aae1b69753e31aba3ff7e4b48a5afba95.html#aae1b69753e31aba3ff7e4b48a5afba95a0b0c59f3609e43fd90018b8320345a44">NxsReader::WARNINGS_TO_STDERR</a>);
<span class="keywordflow">try</span> {
    nexusReader.ReadFilepath(argv[1], MultiFormatReader::NEXUS_FORMAT);
    }
<span class="keywordflow">catch</span>(...)
    {
    nexusReader.DeleteBlocksFromFactories();
    <span class="keywordflow">throw</span>;
    }
nexusReader.DeleteBlocksFromFactories();

<span class="keywordflow">return</span> 0;
}
</pre></div><p>If you were to save this file as "simpleNCLClient.cpp" and save this <a href="simpleNCLClient/Makefile">Makefile</a> in the same directory then you could build the client. You would also need to specify the location of your NCL installation (see notes in the Makefile about NCL_INSTALL_DIR)</p>
<hr/>
 <h2><a class="anchor" id="nonNexus">
Reading non-NEXUS file formats</a></h2>
<p>Despite the name "Nexus Class Library" NCL will actually read other file formats. NCL does not diagnose file format type. However, if you have data in PHYLIP, relaxed FASTA, ALN format or trees in Newick file then you can ask the <a class="el" href="classMultiFormatReader.html" title="A special class of PublicNexusReader, that can parse.">MultiFormatReader</a> to parse these files by passing in the appropriate <a class="el" href="classMultiFormatReader_a81e7bd3fb7ed488d7d443d3d75b8e6b4.html#a81e7bd3fb7ed488d7d443d3d75b8e6b4" title="enumeration of all of the formats supported by MultiFormatReader">MultiFormatReader::DataFormatType</a> or format name (see the <a class="el" href="classMultiFormatReader_acb70d749d174b83607981dcf304915b8.html#acb70d749d174b83607981dcf304915b8">MultiFormatReader::getFormatNames()</a> method).</p>
<p>NCL actually coerces inforamation from these sources into <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a>, NxsCharactersBlocks..., so the user of library does not have to change the code associated with querying NCL for information in order to support these formats.</p>
<p>Support for PhyloXML and nexml are planned.</p>
<hr/>
 <h2><a class="anchor" id="simpleextract">
Getting information out of NCL</a></h2>
<h3><a class="anchor" id="accessblocks">
Getting NxsBlock Reader instances from the reader.</a></h3>
<p>The <a class="el" href="classMultiFormatReader.html" title="A special class of PublicNexusReader, that can parse.">MultiFormatReader</a> uses factories to read the NEXUS blocks that are encountered. Because we do not know how many NEXUS blocks will be in the file, we now have to figure out how many <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> objects were created. One way to do this would be to call the reader's <a class="el" href="classNxsReader_a288fce08baf8efb5c6fc6c36842900b8.html#a288fce08baf8efb5c6fc6c36842900b8" title="Returns a list of all blocks that the NxsReader knows have been read and have NOT...">NxsReader::GetUsedBlocksInOrder()</a> method, walk through the list of NxsBlocks that were returned, ask each block what type it is (using the GetID() method <a class="el" href="index.html#BlockTypeIDDiscussion">Block Type IDs or Block IDs</a>), and the up-casting them to the appropriate type.</p>
<p>This procedure works, but is tedious (and the casting by client code makes it not-type-safe).</p>
<p>Almost all data from NEXUS files (or other phylogenetic datasets) is connected in some way to what NEXUS refers to as TAXA. Thus, NCL's <a class="el" href="classPublicNexusReader.html" title="A NxsReader that uses clone factories to read public blocks.">PublicNexusReader</a>, and classes derived from it, also offer an interface for extracting data with reference to a set of taxa. In particular, client code can "ask" the reader how many TAXA blocks were read and then ask how many CHARACTERS, TREES, or ASSUMPTIONS blocks are associated with each TAXA block.</p>
<p>The snippet below demonstrates the use of this API: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classMultiFormatReader.html" title="A special class of PublicNexusReader, that can parse.">MultiFormatReader</a> nexusReader(-1, <a class="code" href="classNxsReader_aae1b69753e31aba3ff7e4b48a5afba95.html#aae1b69753e31aba3ff7e4b48a5afba95a0b0c59f3609e43fd90018b8320345a44">NxsReader::WARNINGS_TO_STDERR</a>);
nexusReader.ReadFilepath(argv[1], MultiFormatReader::NEXUS_FORMAT);

<span class="keywordtype">int</span> numTaxaBlocks = nexusReader.GetNumTaxaBlocks();
std::cout &lt;&lt; numTaxaBlocks &lt;&lt; <span class="stringliteral">&quot; TAXA block(s) read.\n&quot;</span>;
<span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numTaxaBlocks; ++i)
    {
    <a class="code" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> * taxaBlock = nexusReader.GetTaxaBlock(i);
    std::string taxaBlockTitle = taxaBlock-&gt;GetTitle();
    std::cout &lt;&lt; <span class="stringliteral">&quot;Taxa block index &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; has the Title \&quot;&quot;</span> &lt;&lt;
taxaBlockTitle &lt;&lt; <span class="stringliteral">&quot;\&quot;\n&quot;</span>;

    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nCharBlocks = nexusReader.GetNumCharactersBlocks(taxaBlock);
    std::cout  &lt;&lt;  nCharBlocks &lt;&lt; <span class="stringliteral">&quot; CHARACTERS/DATA block(s) refer to this TAXA</span>
<span class="stringliteral">block\n&quot;</span>;
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; nCharBlocks; ++j)
        {
        <span class="keyword">const</span> <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> * charBlock =
nexusReader.GetCharactersBlock(taxaBlock, j);
        std::string charBlockTitle = taxaBlock-&gt;GetTitle();
        std::cout &lt;&lt; <span class="stringliteral">&quot;Taxa block index &quot;</span> &lt;&lt; j &lt;&lt; <span class="stringliteral">&quot; has the Title \&quot;&quot;</span> &lt;&lt;
charBlockTitle &lt;&lt; <span class="stringliteral">&quot;\&quot;\n&quot;</span>;
        }
    }
</pre></div><h4><a class="anchor" id="queryblocks">
Getting information out of the NxsBlock objects</a></h4>
<p>Each specific class of block has its own public API for extracting the block-specific information see:</p>
<ul>
<li><a class="el" href="index.html#NxsTaxaBlockQueries">Getting information out of a NxsTaxaBlock</a></li>
<li><a class="el" href="index.html#NxsCharactersBlockQueries">Getting information out of a NxsCharactersBlock</a></li>
<li><a class="el" href="index.html#NxsTreesBlockQueries">Getting information out of a NxsTreesBlock</a></li>
<li><a class="el" href="index.html#NxsAssumptionsBlockQueries">Getting information out of a NxsAssumptionsBlockBlock</a></li>
<li><a class="el" href="index.html#NxsUnalignedBlockQueries">Getting information out of a NxsUnalignedBlock</a></li>
</ul>
<p>The example file at <a href="simpleNCLClient/simpleNCLClient.cpp">simpleNCLClient.cpp</a> demonstrates queries to the <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> and both styles of querying the <a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a>. It can be compiled with <a href="simpleNCLClient/Makefile">Makefile</a>. More functions will be added to this example soon to demonstrate the trees block queries.</p>
<hr/>
 <h3><a class="anchor" id="NxsTaxaBlockQueries">
Getting information out of a NxsTaxaBlock</a></h3>
<p>The easiest method to use is <a class="el" href="classNxsTaxaBlockAPI_aaf998f694825a2b7b278b759fcc5ba9f.html#aaf998f694825a2b7b278b759fcc5ba9f">NxsTaxaBlock::GetAllLabels()</a>, but you can also call <a class="el" href="classNxsTaxaBlock_ac378f8124ebabee587ea888034324617.html#ac378f8124ebabee587ea888034324617">NxsTaxaBlock::GetNTax()</a> and then ask for the label of any index in the range [0, nTax), using <a class="el" href="classNxsTaxaBlock_a7158ab9933607eac7f7cad5d2c1573e6.html#a7158ab9933607eac7f7cad5d2c1573e6">NxsTaxaBlock::GetTaxonLabel()</a>.</p>
<p>If you have a taxon label and w, then you can get its index (starting at 0) using the <a class="el" href="classNxsTaxaBlock_ad6d2d18ca9d43e8f001fb989ff50f810.html#ad6d2d18ca9d43e8f001fb989ff50f810" title="Returns a (0-based) index of taxon named &#39;s&#39; in taxonLabels list.">NxsTaxaBlock::FindTaxon()</a> function, but you have to catch NxsX_NoSuchTaxon exceptions to deal with labels that are not known.</p>
<hr/>
 <h3><a class="anchor" id="NxsCharactersBlockQueries">
Getting information out of a NxsCharactersBlock</a></h3>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>{docs needed} The recommended querying functions are NxsCharactersBlock::GetNCharTotal() to get the total number of characters.</dd></dl>
<p><a class="el" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&#39; from the datatype mapper.">NxsCharactersBlock::GetDataType()</a> returns a facet of the <a class="el" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290c" title="values used to represent different basic types of data stored in a CHARACTERS block...">NxsCharactersBlock::DataTypesEnum</a> indicated the broad category of datatype that is stored in the matrix. Because NEXUS allows users to add symbols and equate codes, the normal datatypes can be "augmented." So the GetDataType gives you a sense of the <em>minimal</em> number of state codes.</p>
<h4><a class="anchor" id="SimpleCharStateQuery">
The simplest queries of character states</a></h4>
<p>The old (v2.0) style queries used a call to <a class="el" href="classNxsCharactersBlock_a6427d3164f24f1b8ad08f5ecc154874e.html#a6427d3164f24f1b8ad08f5ecc154874e">NxsCharactersBlock::GetSymbols()</a> to get the list of symbols. Then for each cell, the client code had to call <a class="el" href="classNxsCharactersBlock_a844c584f989e09fafd25893973751ade.html#a844c584f989e09fafd25893973751ade" title="Returns true iff taxon `taxInd` has a gap for character `charInd` (both indices 0-based)...">NxsCharactersBlock::IsGapState()</a>, and <a class="el" href="classNxsCharactersBlock_a26a2f859f7b8c0d45a753675cf53d942.html#a26a2f859f7b8c0d45a753675cf53d942" title="Returns true iff taxon `taxInd` has is missing for character `charInd` (both indices...">NxsCharactersBlock::IsMissingState()</a> to check for gaps and missing data. If the cell was not a gap or missing then you would call <a class="el" href="classNxsCharactersBlock_ad04cb5515e9d67d0bc3f8953f78f6439.html#ad04cb5515e9d67d0bc3f8953f78f6439" title="This function is no longer the most efficient way to access parsed data (see notes...">NxsCharactersBlock::GetNumStates()</a> to find the size of the state set, and then a call to <a class="el" href="classNxsCharactersBlock_af0484095c6da5a8d38af1f129d6e5e97.html#af0484095c6da5a8d38af1f129d6e5e97" title="Returns symbol from symbols list representing the state for taxon `i&#39; and character...">NxsCharactersBlock::GetState()</a> to get each state in the state set. For those cells that have multiple states, you would have to call <a class="el" href="classNxsCharactersBlock_ae86148be4403ce70ab5c23b01a7130ee.html#ae86148be4403ce70ab5c23b01a7130ee" title="Returns true iff taxon `taxInd` has is missing for character `charInd` (both indices...">NxsCharactersBlock::IsPolymorphic()</a> to determine if the multiple states represented polymorphism or uncertainty.</p>
<p>So the code to print out a matrix as NEXUS would look like this: </p>
<div class="fragment"><pre class="fragment"><span class="comment">/* Example of the simplest (v2.0) querying for character block content */</span>
<span class="keywordtype">void</span> printMatrixWithoutLabels(std::ostream &amp; out, <span class="keyword">const</span> <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> *cb)
    {
    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nc = cb-&gt;<a class="code" href="classNxsCharactersBlock_a5f984e07256fa1055b04210484301046.html#a5f984e07256fa1055b04210484301046">GetNCharTotal</a>();
    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nt = cb-&gt;GetNTaxTotal()
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; nt
    <span class="keywordflow">if</span> (matrix-&gt;IsMissing(d))
        {
        s[0] = missing;
        s[1] = <span class="charliteral">&#39;\0&#39;</span>;
        }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (matrix-&gt;IsGap(d))
        {
        s[0] = gap;
        s[1] = <span class="charliteral">&#39;\0&#39;</span>;
        }
    <span class="keywordflow">else</span>
        {
        assert(symbols != NULL);
        <span class="keywordtype">unsigned</span> symbolListLen = strlen(symbols);

        <span class="keywordtype">unsigned</span> numStates = matrix-&gt;GetNumStates(d);
        <span class="keywordtype">unsigned</span> numCharsNeeded = numStates;
        <span class="keywordflow">if</span> (numStates &gt; 1)
            numCharsNeeded += 2;
        assert(slen &gt; numCharsNeeded);

        <span class="keywordflow">if</span> (numStates == 1)
            {
            <span class="keywordtype">unsigned</span> v = matrix-&gt;GetState(d);
            assert(v &lt; symbolListLen);
            s[0] = symbols[v];
            s[1] = <span class="charliteral">&#39;\0&#39;</span>;
            }

        <span class="keywordflow">else</span>
            {
            <span class="comment">// numStates must be greater than 1</span>
            <span class="comment">//</span>
            <span class="keywordtype">unsigned</span> i = 0;
            <span class="keywordflow">if</span> (matrix-&gt;IsPolymorphic(d))
                s[i++] = <span class="charliteral">&#39;(&#39;</span>;
            <span class="keywordflow">else</span>
                s[i++] = <span class="charliteral">&#39;{&#39;</span>;
            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 0; k &lt; numStates; k++)
                {
                <span class="keywordtype">unsigned</span> v = matrix-&gt;GetState(d, k);
                assert(v &lt; symbolListLen);
                s[i++] = symbols[v];
                s[i] = <span class="charliteral">&#39;\0&#39;</span>;
                }
            <span class="keywordflow">if</span> (matrix-&gt;IsPolymorphic(d))
                s[i++] = <span class="charliteral">&#39;)&#39;</span>;
            <span class="keywordflow">else</span>
                s[i++] = <span class="charliteral">&#39;}&#39;</span>;
            s[i] = <span class="charliteral">&#39;\0&#39;</span>;
            }
        }
</pre></div><p> This API is still supported. However:</p>
<ul>
<li>It is possible for NEXUS file contain a matrix without symbols. Since GetState, returns the symbol, This API will not work on such matrices.</li>
<li>the API is less effcient than the newer api (it results in a lot more function calling).</li>
</ul>
<h4><a class="anchor" id="newerCharQueries">
Efficient character queries.</a></h4>
<p>If you need to extract large amounts of data out of NCL, you often need something more efficient than the code described in the "<a class="el" href="index.html#SimpleCharStateQuery">The simplest queries of character states</a>" section. This usually occurs with applications that support sequence data sets.</p>
<p>In version 2.1 and higher of NCL, you can asked for a reference to the internal storage of the character data. If you need to convert the NCL storage into your own format, you can the efficiently walk down the array of state codes and get the information that you need. This requires that you know a little bit about how NCL stores the data.</p>
<p>Internally the cells of the matrix are stored as integers that are referred to in the library as "state codes." State codes include the "fundamental states" for a type (such as 0=&gt;"A", 1=&gt;"C", 2=&gt;"G", 3=&gt;"T" for DNA), but also the ambiguity codes (4="{ACGT}" for DNA).</p>
<p>The Missing data concept and the Gap concept have their own state codes. Use NXS_MISSING_CODE and NXS_GAP_STATE_CODE to refer to these states. But you can rely on the fact that these codes are -1 and -2 respectively.</p>
<p>To decode these internal state codes into the symbols that occur in a file to describe a datatype, NCL stores a <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> object. The <a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> "knows" which <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> instance applies to each column of the matrix. When you do not have a "mixed" datatype, then the same <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> instance will apply to every column.</p>
<h4><a class="anchor" id="GettingMapper">
The role of the NxsDiscreteDatatypeMapper</a></h4>
<p>NEXUS allows users to add symbols and equates (which are like macros) to a datatypes. In NCL, addition of symbols to a sequence type is only supported if you have called <a class="el" href="classNxsCharactersBlock_a03323afe931168034735ad2be8a4ed8c.html#a03323afe931168034735ad2be8a4ed8c" title="Instructs the NxsCharactersBlock to accept extra symbols even if the datatype is...">NxsCharactersBlock::SetAllowAugmentingOfSequenceSymbols()</a> with the argument true before parsing the file. This will result in the datatype becoming "standard" type if extra symbols are found (see <a class="el" href="index.html#mixedDatatypes">Dealing with Datatype=Mixed</a>).</p>
<p>Because datatypes in NEXUS are actually richer than a simple enumeration, you often need to deal with the a <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> object. You can call NxsCharactersBlock::GetDatatypeMapperForChar() to get the mapper for a particular column. If the datatype is not mixed, then this function will return the same mapper object for every column.</p>
<p>If you do want to support mixed datatype, then you can call: <a class="el" href="classNxsCharactersBlock_a35de45b0d15c97f9b68043d5e8dd2705.html#a35de45b0d15c97f9b68043d5e8dd2705">NxsCharactersBlock::GetAllDatatypeMappers()</a> to get all of the mappers used in a matrix, and then use the result of <a class="el" href="classNxsCharactersBlock_a886919f70994b6d9339ccae1346c0a08.html#a886919f70994b6d9339ccae1346c0a08">NxsCharactersBlock::GetDatatypeMapForMixedType()</a> to figure out what set of characters is used by each mapper (this is equivalent to asking for the mapper for each character, but it is often easier to deal with the data by walking through the characters associated with each mapper.</p>
<p>If you just want to support the molecular sequence types, you still have to be aware that the user may have added new equates that generate new state codes, and that polymorphism codes can occur in the matrix. So there can be some extra state codes to deal with. An equate is usually "syntactic sugar" that gives users another way to express the same content (for example, "Y" instead of "{TC}"). By default, the molecular sequence types come with some equates to represent these ambiguity codes. But the user can introduce new equates that represent polymorphism: in NEXUS "(TC)" means a taxon is polymorphic for T and C, while "{TC}" means that a taxon could have either state ("partially ambiguous").</p>
<p>Many applications want to parse only the molecular sequence datatypes and do not want to go through the trouble of supporting additional state code. The easiest way to tell if the characters block is going to require "special handling" is to create a default block of the same general type using the NxsDiscreteDatatypeMapper(NxsDatatypeEnum, bool) constructor, and then compare it to the NxsCharactersBlock's mapper using <a class="el" href="classNxsDiscreteDatatypeMapper_a495505622d8540b88cd03c0f41ac8154.html#a495505622d8540b88cd03c0f41ac8154">NxsDiscreteDatatypeMapper::IsSemanticallyEquivalent()</a>. If that function returns true, then you may treat the state codes from the matrix as if they were the unmodified datatype (the NEXUS file might contain some syntactic equates, if the mappers are syntactically equivalent the matrix will not contain polymorphic codes. </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> *mapper = charBlock.GetDatatypeMapperForChar(0);
            <span class="keyword">const</span> <span class="keywordtype">bool</span> hasGaps = charBlock.<a class="code" href="classNxsCharactersBlock_a25f1d2be3465fd9dafb97be50d8e2601.html#a25f1d2be3465fd9dafb97be50d8e2601" title="Returns the gap symbol currently in effect.">GetGapSymbol</a>() != <span class="charliteral">&#39;\0&#39;</span>;

            <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> defaultMapper(<a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca0145b9755a4581acaabe1e4c458d7f73" title="indicates `matrix&amp;#39; holds characters with arbitrarily-assigned, discrete states...">NxsCharactersBlock::dna</a>, hasGaps);
            <span class="keywordflow">if</span> (mapper-&gt;<a class="code" href="classNxsDiscreteDatatypeMapper_a495505622d8540b88cd03c0f41ac8154.html#a495505622d8540b88cd03c0f41ac8154">IsSemanticallyEquivalent</a>(&amp;defaultMapper))
                {
                <span class="comment">// the datatype has not been changed in a substantive way.</span>
                }
            <span class="keywordflow">else</span>
                {
                <span class="comment">// new state codes have been introduced, so routines that do not</span>
                <span class="comment">//  interrogate the mapper to check the mapper about the status of all of the</span>
                <span class="comment">//  states may fail.</span>
                }
</pre></div><h4><a class="anchor" id="GettingStateCodes">
Getting access to the state codes.</a></h4>
<p>You can obtain a <a class="el" href="classNxsCharactersBlock_a2840b32dd8053a925a9c777911f6b659.html#a2840b32dd8053a925a9c777911f6b659">NxsCharactersBlock::GetDiscreteMatrixRow()</a></p>
<p>The example file at <a href="simpleNCLClient/simpleNCLClient.cpp">simpleNCLClient.cpp</a> demonstrates queries to the <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> and both styles of querying the <a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a>. It can be compiled with <a href="simpleNCLClient/Makefile">Makefile</a></p>
<h4><a class="anchor" id="OtherCharQuery">
useful NxsCharactersBlock queries</a></h4>
<p><a class="el" href="classNxsCharactersBlock_a5d2cc904b64a099693654b8844a82e75.html#a5d2cc904b64a099693654b8844a82e75" title="Returns true If character `taxInd&#39; has some stored character state.">NxsCharactersBlock::TaxonIndHasData()</a> can be used to see if an entire row is present in the matrix (if false, then the taxon had no data read).</p>
<p>Characters can be flagged is inactive (aka "excluded" or "eliminated" - unfortunately, these three terms are synonymous in NCL), by <a class="el" href="classNxsCharactersBlock_ae724d86e3ec64f4ee56962e69eabdb0b.html#ae724d86e3ec64f4ee56962e69eabdb0b" title="excludes all of the indices in exset.">NxsCharactersBlock::ApplyExset()</a>. They can be reincluded by <a class="el" href="classNxsCharactersBlock_a39d83d6ddebf1b5abeda386812577d04.html#a39d83d6ddebf1b5abeda386812577d04" title="includes all of the indices in exset.">NxsCharactersBlock::ApplyIncludeset()</a>. To exclude/include a single character (rather than a set) use <a class="el" href="classNxsCharactersBlock_a5c12fb5d3295cce9292839d9fe774e1b.html#a5c12fb5d3295cce9292839d9fe774e1b" title="excludes character `i`">NxsCharactersBlock::ExcludeCharacter()</a> and <a class="el" href="classNxsCharactersBlock_a77cae32fe241edccb568c974f84f4d6e.html#a77cae32fe241edccb568c974f84f4d6e" title="includes character `i`">NxsCharactersBlock::IncludeCharacter()</a>. The accessors <a class="el" href="classNxsCharactersBlock_a70ac339754cea27d384d18a3835c446d.html#a70ac339754cea27d384d18a3835c446d" title="Returns the number of characters that have not been exclude (via exset or eliminate...">NxsCharactersBlock::GetNumActiveChar()</a>, <a class="el" href="classNxsCharactersBlock_a62d5344a796517202436048b6befeeef.html#a62d5344a796517202436048b6befeeef">NxsCharactersBlock::GetExcludedIndexSet()</a>, and <a class="el" href="classNxsCharactersBlock_a1a2ac1c77126d46dab11200bc1869258.html#a1a2ac1c77126d46dab11200bc1869258">NxsCharactersBlock::IsActiveChar()</a> are useful for determining which columns are currently flagged as excluded.</p>
<p>Character labels (and state labels) are supported see <a class="el" href="classNxsCharactersBlock_a8091ed0c604ab1783eb8fd2ea92cb0f8.html#a8091ed0c604ab1783eb8fd2ea92cb0f8" title="Returns true if at least one character has charlabels.">NxsCharactersBlock::HasCharLabels()</a> and <a class="el" href="classNxsCharactersBlock_a99fc213df068594d9ee09fe7751d3c67.html#a99fc213df068594d9ee09fe7751d3c67" title="Returns label for character `i&#39; (starting at zero), if a label has been specified...">NxsCharactersBlock::GetCharLabel()</a>.</p>
<p>The instruction on how gaps should be interpretted in analyses such as parsimony tree scoring is contained in the <code>Options</code> command of the ASSUMPTIONS block, but when read the block will "inform" the <a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> instance. The setting can be retrieved <a class="el" href="classNxsCharactersBlock_aeca34234f6ae4752d85738f9435eb36b.html#aeca34234f6ae4752d85738f9435eb36b">NxsCharactersBlock::GetGapModeSetting()</a>. StepMatrices can be retreived by requesting the NxsCharactersBlock's "TransformationManager" (using the NxsCharactersBlock::GetNxsTransformationManagerRef() method) and querying that object.</p>
<p>To interpret and query for cells of continuous data matrices, use <a class="el" href="classNxsCharactersBlock_ae86ee83384065f3c9a95e7670c7ebd78.html#ae86ee83384065f3c9a95e7670c7ebd78">NxsCharactersBlock::GetStatesFormat()</a> to figure out if the cells represent states or individuals. <a class="el" href="classNxsCharactersBlock_ad72498c30823755d76f7f1c47cac1dec.html#ad72498c30823755d76f7f1c47cac1dec" title="Returns the list of items that will be in each cell.">NxsCharactersBlock::GetItems()</a> to get the vector of the items (or "keys" stored for each cell. Then to retreive the value for a item at a particular cell, use <a class="el" href="classNxsCharactersBlock_a156b6cbe87a34912da7fb46dcb599b86.html#a156b6cbe87a34912da7fb46dcb599b86" title="Accessor for getting the list of continuous values associated with an &quot;ITEM...">NxsCharactersBlock::GetContinuousValues()</a>.</p>
<hr/>
 <h3><a class="anchor" id="NxsTreesBlockQueries">
Getting information out of a NxsTreesBlock</a></h3>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>{docs needed}</dd></dl>
<hr/>
 <h3><a class="anchor" id="NxsAssumptionsBlockQueries">
Getting information out of a NxsAssumptionsBlockBlock</a></h3>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>{docs needed}</dd></dl>
<hr/>
 <h3><a class="anchor" id="NxsUnalignedBlockQueries">
Getting information out of a NxsUnalignedBlock</a></h3>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>{docs needed}</dd></dl>
<hr/>
 <h2><a class="anchor" id="LessStrict">
Making NCL less strict</a></h2>
<p>The NEXUS standard is very specific about some requirements of input file. In many cases these requirements are necessary for the semantics to be clear, but in some cases an invalid file is not ambiguous. By default NCL is pretty strict about the rules, but this can be frustrating for users who are constantly having their files rejected (fortunately, NCL's error messages are usually helpful; see <a class="el" href="index.html#rockinErrorMessages">Why are the error messages that NCL generates because of invalid files so crystal-clear and helpful?</a>).</p>
<p>There are several ways to make the NexusReader more forgiving than it normally is. Some of these methods involve calling functions (mentioned below) that are in methods of some <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> subclass. To make your <a class="el" href="classPublicNexusReader.html" title="A NxsReader that uses clone factories to read public blocks.">PublicNexusReader</a> instance use blocks that have been modified you will have to get the template for each type of block (see <a class="el" href="classPublicNexusReader_ab4f3cd4c449247ac07200b4b0c17a27a.html#ab4f3cd4c449247ac07200b4b0c17a27a">PublicNexusReader::GetTreesBlockTemplate()</a> for example).</p>
<ul>
<li>It is very common to encounter a file without a TREES block but no TAXA block. If you call NxsTreesBlock::SetAllowImplicitNames(true) on the <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> template instance, then any NxsTreeBlocks cloned from this instance will generate an "implied" Taxa block when they are read (if there is no taxa block in memory). See <a class="el" href="index.html#impliedBlocks">"Implied" blocks</a> and <a class="el" href="index.html#taxaBlockScoping">"Scoping" of TAXA blocks</a>.</li>
<li>The use of NxsReader::cullIdenticalTaxaBlocks(true) can help avoid redundant <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> instances. See <a class="el" href="index.html#taxaBlockScoping">"Scoping" of TAXA blocks</a></li>
<li>If you are going to reuse a <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a>, you may want to call <a class="el" href="classNxsReader_a9b4a4e2805479cbd6ce909fa63911fee.html#a9b4a4e2805479cbd6ce909fa63911fee" title="Lowers the priority of all read blocks to `priorityLevel`.">NxsReader::DemoteBlocks()</a> before each execution/reading of a file. This will give the blocks from previous files lower priority (see <a class="el" href="index.html#taxaBlockScoping">"Scoping" of TAXA blocks</a>).</li>
<li><a class="el" href="classNxsCharactersBlock_a03323afe931168034735ad2be8a4ed8c.html#a03323afe931168034735ad2be8a4ed8c" title="Instructs the NxsCharactersBlock to accept extra symbols even if the datatype is...">NxsCharactersBlock::SetAllowAugmentingOfSequenceSymbols()</a> with the argmunte true will cause NCL to accept characters matrices with symbols added on to the standard symbols. See <a class="el" href="classNxsCharactersBlock_a786e8f176921b556115b11f9a9801653.html#a786e8f176921b556115b11f9a9801653" title="Instructs the NxsCharactersBlock to convert sequence data character blocks that have...">NxsCharactersBlock::SetConvertAugmentedToMixed()</a> for a discussion of how such character blocks are dealt with after the parse.</li>
<li>Any reader derived from <a class="el" href="classPublicNexusReader.html" title="A NxsReader that uses clone factories to read public blocks.">PublicNexusReader</a> will raise an <a class="el" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a> when the parser encounters syntax that causes a warning that is given a level of PROBABLY_INCORRECT_CONTENT_WARNING or higher. You can make NCL issue warnings instead of errors by calling reader-&gt;SetWarningToErrorThreshold(NxsReader::FATAL_WARNING). Or you can make the parser generate NxsExceptions for milder warnings if you pass in an argument associated with a less severe warning (see the <a class="el" href="classNxsReader_a409e01dc0baecef7ed471879c0692978.html#a409e01dc0baecef7ed471879c0692978">NxsReader::NxsWarnLevel</a></li>
<li>MrBayes introduced the <code>datatype=MIXED</code> syntax to the Format command of the CHARACTERS block. This is more explicit than the older NEXUS style of simply augmenting the symbols list (without saying which datatype corresponds to which column). Use NxsCharactersBlock::SetSupportMixedDatatype(true) to enable this features.</li>
</ul>
<p>If you also call NxsCharactersBlock::SetConvertAugmentedToMixed(true), the NCL will attempt to separate a sequence datatype with augmented symbols list into a mixed type that has the same sequence type but also has a set of characters that are datatype <code>standard</code>. See <a class="el" href="index.html#mixedDatatypes">Dealing with Datatype=Mixed</a> discussion. enum)</p>
<hr/>
 <h2><a class="anchor" id="Gotchas">
Quirks, Gotchas</a></h2>
<hr/>
 <h3><a class="anchor" id="MisleadingNames">
Potentially Confusing Names.</a></h3>
<p>A few of the names of classes in NCL may cause some confusion:</p>
<ul>
<li><a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> is really a "NEXUS block parser." Instances of this class are responsible for reading a block in a NEXUS, file. After parsing the file content, the instance should hold contents of the block in memory. So <b>after</b> the parse the <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> object naturally maps to the block in a NEXUS file.</li>
<li><a class="el" href="classNxsToken.html">NxsToken</a> should be NxsTokenizer. It wraps a istream and return tokens.</li>
<li><a class="el" href="classNxsAssumptionsBlock.html" title="This class handles reading and storage for the NxsReader block ASSUMPTIONS.">NxsAssumptionsBlock</a> - Instances of this block type actually read commands in the ASSUMPTIONS, SETS, and CODONS blocks. It is common for commands such as CharSets to occur in several different blocks. Because most clients want to treat the information identically regardless of block type, NCL actually uses the same class to process any of these commands that occur in any of these blocks. This terminology is potentially confusing, but it does make it easier for client code to obtain references to all of the associated metadata (rather than having to query specifically for each of the three block types, you can query for the <a class="el" href="classNxsAssumptionsBlock.html" title="This class handles reading and storage for the NxsReader block ASSUMPTIONS.">NxsAssumptionsBlock</a> only. Note the discussion of <a class="el" href="index.html#BlockTypeIDDiscussion">Block Type IDs or Block IDs</a> for confusion over the "ID."</li>
</ul>
<hr/>
 <h3><a class="anchor" id="BlockTypeIDDiscussion">
Block Type IDs or Block IDs</a></h3>
<p>NEXUS files are composed of modules called blocks. Blocks begin with <code>BEGIN blockname;</code> and end with an <code>END;</code> command. The <code>blockname</code> indicates what type of information is in the block; common block names are TAXA, CHARACTERS, and TREES. In NCL, these block names have always been referred to as the ID of the block ( NxsBlock::id data member, and <a class="el" href="classNxsBlock_a43cb2dac4ccc14d798d29670d9dc6017.html#a43cb2dac4ccc14d798d29670d9dc6017" title="Returns the `id` NxsString.">NxsBlock::GetID()</a> method). Perhaps a better name for this concept would be BlockType or BlockTypeID.</p>
<p>These block names are important for NCL, because the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> uses the Block ID to figure out whether a <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> instance can read the next section of a NEXUS file (specifically in <a class="el" href="classNxsReader_a57f6e706bac65d43bf5eb2bba3c58a0e.html#a57f6e706bac65d43bf5eb2bba3c58a0e" title="Reads the NxsReader data file from the input stream provided by `token&#39;.">NxsReader::Execute</a>, when the reader encounters the beginning of the block, it calls NxsBlock::CanReadBlockType() passing in the NEXUS tokenizer that is set to the Block name token; however the base class implementation of CanReadBlockType simply returns true if NxsBlock::id matches the block name token).</p>
<p>Be aware that Mesquite added a BLOCKID command to nexus. This command allows assigns a unique string to a block in a file. This BlockID string from the BLOCKID command is <b>NOT</b> the id that is referred to throughout the NCL documentation. NCL handles and stores the BlockID from the BLOCKID command (see <a class="el" href="classNxsBlock_a1c41388b522d57c51ccbd34404db0531.html#a1c41388b522d57c51ccbd34404db0531" title="This is the argument from the BLOCKID command.">NxsBlock::GetBlockIDCommandString()</a> method).</p>
<p>Mesquite also introduced a TITLE command for a block. The TITLE command is handled by NCL (see NxsBlock::GetTitle() method). Block Titles are not necessarily unique. Unlike the BlockIDs, they are shown to user's as identifiers for the blocks in Mesquite's GUI.</p>
<p>In summary: NEXUS is composed of blocks have different types. In the NCL API (and documentation) these block types correspond to the ID of the <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> instance. To deal with Mesquite extensions to NEXUS, any block can have a TITLE and a BlockID, but these fields are distinct from the ID that NCL refers to in its documentation.</p>
<hr/>
 <h3><a class="anchor" id="impliedBlocks">
"Implied" blocks</a></h3>
<p>It is not unusual to see files that refer to taxa without having an explicit TAXA block. For example, it is very common to encounter a file that just has a TREES block; technically such a file is not valid NEXUS, but if NCL is configured correctly (see the NxsTreesBlock::SetAllowImplicitNames() method) it will tolerate these files and generate a TAXA block on-the-fly. NCL v2.1 will create implied taxa block objects during a parse. From the client code's perspective it will seem as if the file contained an explicit TAXA block. This makes it easy to write client code, because one does not have to add special cases for files with DATA blocks or files with just TREES blocks.</p>
<p>See <a class="el" href="index.html#taxaBlockScoping">"Scoping" of TAXA blocks</a> for a more detaile discussion.</p>
<hr/>
 <h3><a class="anchor" id="taxaBlockScoping">
"Scoping" of TAXA blocks</a></h3>
<p>Because Taxa are central to most phylogenetic data, it is crucial that the parser can identify the TAXA that are being referred to when parsing taxa-dependent context.</p>
<p>Unfortunately, the NEXUS specification is silent on the issue of how to deal with multiple instances of blocks of the same type. Mesquite introduced a LINK/TITLE pair of commands so that a file such as this one: </p>
<div class="fragment"><pre class="fragment">    begin taxa;
        TITLE some_title;
    ...
    end;
    begin characters;
        TITLE <span class="stringliteral">&#39;a char block title&#39;</span>;
        LINK Taxa = some_title ;
    ...
</pre></div><p> is explicit about which set of taxa are used in the characters block.</p>
<p>NCL is often having to infer which TAXA block to use. In general, if it finds two possibilities (and there are not LINK commands to disambiguate which block to use) then NCL will raise an exception.</p>
<p>Unfortunately:</p>
<ol type="1">
<li>files with explicit TITLE/LINK commands are rare,</li>
<li>many files are technically illegal because they have a TREES block but no TAXA block. Because the taxon names are embedded in the tree description or the TRANSLATE command, it is feasible to infer an implied TAXA block for such files.</li>
<li>Reading multiple files with the same <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> can mean that there are multiple TAXA blocks in the memory accessible to the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a>. So the parser will generate a <a class="el" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a> when it encounters a taxa-dependent block (despite the fact that each file would have only one TAXA block if it were processed separately).</li>
</ol>
<p>Files without TAXA blocks (problem #2 above) can be dealt with by calling the NxsTreesBlock::SetAllowImplicitNames() method on the <a class="el" href="classNxsTreesBlock.html" title="This class handles reading and storage for the NEXUS block TREES.">NxsTreesBlock</a> that will parse the TREES block (or the block that is the template in the NxsReader's clone factory). Doing this can just exacerbate problem #3, because now a parse will generate even <b>more</b> Taxa blocks.</p>
<p>You can call NxsReader::cullIdenticalTaxaBlocks(true) before parse so that NCL will store only one block when it finds duplicate TAXA blocks (implicit taxa blocks generated by parsing a TREES block will often be identical to a TAXA block mentioned in a separate file, so this function really can cut down on the number of <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> instances that you have to deal with after the parse is done). Note that NEXUS has an ordering to the taxa (and characters and trees), so two TAXA blocks with the same labels, but in different orders are NOT considered to be the identical!</p>
<p>With NCL 2.1.11 and above you can call <a class="el" href="classNxsReader_a9b4a4e2805479cbd6ce909fa63911fee.html#a9b4a4e2805479cbd6ce909fa63911fee" title="Lowers the priority of all read blocks to `priorityLevel`.">NxsReader::DemoteBlocks</a> before each file is read. This will set the "priority" of previously read TAXA blocks to a lower level. So if the next file read has a TAXA block and taxa-dependent block, but no LINK statements, NCL will not be confused. It will assume that the TAXA block in the file is to be used (you can still get errors if the file contains multiple TAXA blocks, but no LINK statements).</p>
<p>Generally the most robust strategy, involves the following calls: </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classMultiFormatReader.html" title="A special class of PublicNexusReader, that can parse.">MultiFormatReader</a> nexusReader(-1, <a class="code" href="classNxsReader_aae1b69753e31aba3ff7e4b48a5afba95.html#aae1b69753e31aba3ff7e4b48a5afba95a0b0c59f3609e43fd90018b8320345a44">NxsReader::WARNINGS_TO_STDERR</a>);
    ...
    <a class="code" href="classNxsTreesBlock.html" title="This class handles reading and storage for the NEXUS block TREES.">NxsTreesBlock</a> * treesB = nexusReader.GetTreesBlockTemplate();
    treesB-&gt;SetAllowImplicitNames(<span class="keyword">true</span>);
    ...
    nexusReader.cullIdenticalTaxaBlocks(<span class="keyword">true</span>);
    ...

    <span class="keywordtype">char</span> * filename = <span class="stringliteral">&quot;test.nex&quot;</span>;
    nexusReader.DemoteBlocks();
    nexusReader.ReadFilepath(argv[argn], MultiFormatReader::NEXUS_FORMAT);
    ...
</pre></div><p>But it is important to recognize that after reading file(s) it is possible that you will have to deal with multiple <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> instances that all contain the same taxa, but in a different order. Currently NCL does not support reordering of the references to taxa, so you will have to disentangle the data if you want to support resolving similar taxa blocks and their corresponding linked data. The taxa-dependent blocks can tell you what <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> instance they used during the parse, so you can tell which blocks refer to the same taxa (see also <a class="el" href="classPublicNexusReader_acebafd1948979c5061cd368cd8506150.html#acebafd1948979c5061cd368cd8506150">PublicNexusReader::GetNumCharactersBlocks()</a> and functions like it which take a <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> pointer and return only NxsCharactersBlocks that refer to that set of taxa).</p>
<hr/>
 <h3><a class="anchor" id="memoryManagement">
Managing Memory</a></h3>
<p>Almost all objects in NCL clean up all of the memory that they allocate, so do not present problems.</p>
<p>The only exception to this are the <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> instances that are handled by the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a>. By default the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> will not delete any of the NxsBlocks that it handles. <br/>
 <b>You are responsible for deleting all of the NxsBlocks, that the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> can return to you!</b></p>
<p>The only cases in which the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> trigger deletion of NxsBlocks are:</p>
<ol type="1">
<li>If the client calls <a class="el" href="classNxsReader_a44291c052d7bb75a7918bb1aab5897e1.html#a44291c052d7bb75a7918bb1aab5897e1" title="Deletes the set of blocks that have been created from factories and removes reference...">NxsReader::DeleteBlocksFromFactories()</a>, then the blocks that were created using a <a class="el" href="classNxsBlockFactory.html" title="This abstract class defines the interface for a factory that can generate NxsBlocks...">NxsBlockFactory</a> will be deleted.</li>
<li>If you have called NxsReader::cullIdenticalTaxaBlocks(true), then the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> will delete a new Taxa block if it is identical to a previous <a class="el" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a></li>
<li>If there is an error from a <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> from a factory during the parse (or the block is disabled), then the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> will inform the factory through (<a class="el" href="classNxsBlockFactory_aac803d1280d8e4ea15b3335d9c253ba0.html#aac803d1280d8e4ea15b3335d9c253ba0" title="base-class implementation deletes the block (the NxsReader will not retain a reference...">NxsBlockFactory::BlockError()</a> or <a class="el" href="classNxsBlockFactory_a32543bdc2f039f17712acfefedca80b6.html#a32543bdc2f039f17712acfefedca80b6" title="base-class implementation deletes the block (the NxsReader will not retain a reference...">NxsBlockFactory::BlockSkipped()</a> methods). In these cases the factory will delete the block, and the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> will not store them.</li>
</ol>
<p>Note that in cases 2 and 3, the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> will not store the block, so the memory management rules for blocks are actually easy to follow. Once again that rule is: <br/>
 <b>You are responsible for deleting all of the NxsBlocks, that the can <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> return to you!</b></p>
<p>Note that if you need to delete a block even if you are not interested in its content. Even if do not ask for the <a class="el" href="classNxsAssumptionsBlock.html" title="This class handles reading and storage for the NxsReader block ASSUMPTIONS.">NxsAssumptionsBlock</a> instances, the <a class="el" href="classMultiFormatReader.html" title="A special class of PublicNexusReader, that can parse.">MultiFormatReader</a> may still have created <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> instances to store the content of blocks, so these <a class="el" href="classNxsBlock.html" title="This is the base class from which all block classes are derived.">NxsBlock</a> instances must be deleted.</p>
<p><a class="el" href="classNxsReader_a44291c052d7bb75a7918bb1aab5897e1.html#a44291c052d7bb75a7918bb1aab5897e1" title="Deletes the set of blocks that have been created from factories and removes reference...">NxsReader::DeleteBlocksFromFactories()</a> is a convenient way to clean-up after a parse. If you want to save some of the blocks, you can "deregister" them from the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> before the <a class="el" href="classNxsReader_a44291c052d7bb75a7918bb1aab5897e1.html#a44291c052d7bb75a7918bb1aab5897e1" title="Deletes the set of blocks that have been created from factories and removes reference...">NxsReader::DeleteBlocksFromFactories()</a> call. The <a class="el" href="classNxsReader_ad05c38b8d256b9acca8be01f645d9f9e.html#ad05c38b8d256b9acca8be01f645d9f9e" title="Removes a block from the NxsReader&#39;s records.">NxsReader::RemoveBlockFromUsedBlockList</a> method is the one to use to make the <a class="el" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> forget about a block.</p>
<p>If you know beforehand that you are not going to be interested in a particular public block, then you can configure the <a class="el" href="classMultiFormatReader.html" title="A special class of PublicNexusReader, that can parse.">MultiFormatReader</a> to skip blocks (see the documentation on the <a class="el" href="classPublicNexusReader_a8ef04630a31b01d5a8b4283a46d79eea.html#a8ef04630a31b01d5a8b4283a46d79eea" title="Creates a new PublicNexusReader.">PublicNexusReader::PublicNexusReader</a> constructor).</p>
<p>The only caveat is that if you register a "singelton" block (using <a class="el" href="classNxsReader_a6d8b9b4cbb59099097a529a4fe6abe39.html#a6d8b9b4cbb59099097a529a4fe6abe39" title="Adds `newBlock&#39; to the end of the list of NxsBlock objects growing from `blockList&#39;...">NxsReader::Add</a>) and the block is used multiple times in the file, then <a class="el" href="classNxsReader_a288fce08baf8efb5c6fc6c36842900b8.html#a288fce08baf8efb5c6fc6c36842900b8" title="Returns a list of all blocks that the NxsReader knows have been read and have NOT...">NxsReader::GetUsedBlocksInOrder()</a> method may return the same pointer multiple times. So make sure that you either do not use <a class="el" href="classNxsReader_a6d8b9b4cbb59099097a529a4fe6abe39.html#a6d8b9b4cbb59099097a529a4fe6abe39" title="Adds `newBlock&#39; to the end of the list of NxsBlock objects growing from `blockList&#39;...">NxsReader::Add</a> or you guard against double deletion of any blocks that are added in this mechanism.</p>
<p>If you do use <a class="el" href="classNxsReader_a6d8b9b4cbb59099097a529a4fe6abe39.html#a6d8b9b4cbb59099097a529a4fe6abe39" title="Adds `newBlock&#39; to the end of the list of NxsBlock objects growing from `blockList&#39;...">NxsReader::Add</a>, then the common usage is to maintain a list of those blocks that you have added. Then you can delete them, and call <a class="el" href="classNxsReader_a44291c052d7bb75a7918bb1aab5897e1.html#a44291c052d7bb75a7918bb1aab5897e1" title="Deletes the set of blocks that have been created from factories and removes reference...">NxsReader::DeleteBlocksFromFactories()</a> to delete all other blocks (without worrying about double-deletion problems).</p>
<hr/>
 <h3><a class="anchor" id="setsAssumptions">
NxsAssumptionsBlock reads several types of blocks</a></h3>
<p>Commands like CharSet frequently occur in ASSUMPTIONS blocks (rather than the SETS block). Codon-related commands are also found in ASSUMPTIONS blocks.</p>
<p>To avoid code duplication and forcing the client code to specifically ask for all of the various flavors of meta-data blocks, NCL uses NxsAssumptionsBlocks to read SETS, ASSUMPTIONS, and CODONS blocks.</p>
<p>You can use NxsAssumptionsBlock::GetIDOfBlockTypeIDFromParse to find out what the block in the file was called. But usually you want to deal with the commands in the same way, regardless of what block they occur in, so you rarely need this call.</p>
<hr/>
 <h3><a class="anchor" id="mixedDatatypes">
Dealing with Datatype=Mixed</a></h3>
<p>Combined data sets are most cleanly expressed as multiple separate blocks such that each block consists of data of a homogeneous type. Unfortunately, the NEXUS standard was silent on how to accommodate multiple blocks of the same type (The TITLE/LINK mechanism [see <a class="el" href="index.html#taxaBlockScoping">"Scoping" of TAXA blocks</a>] was not introduced until several years after the standard, and some popular software will only accept a single character block).</p>
<p>An unsatisfactory solution that has been supported for a long time is to augment the list of legal symbols in the CHARACTERS or DATA block. Doing this makes it possible to parse a mixed matrix, but the software cannot necessarily figure out the datatype for each character (eg. the common symbols for DNA are a subset of the amino acid codes, so you can't tell if a column of A's is alanine or adenine).</p>
<p>MrBayes introduced the <code>datatype=MIXED</code> syntax to the Format command of the CHARACTERS block. This is more explicit than the older NEXUS style of simply augmenting the symbols list (without saying which datatype corresponds to which column). The syntax for this is:<br/>
 </p>
<div class="fragment"><pre class="fragment">FORMAT Datatype=MIXED(RNA: 1-516, RNA: 517-1398, Protein: 1399-1692, Standard: 1693-1742)  Gap=-;
</pre></div><h4><a class="anchor" id="enableparsemixed">
Enabling parsing of Mixed datatypes</a></h4>
<p>By default NCL will reject this mixed datatype syntax, but you can enable parsing of this syntax by calling NxsCharactersBlock::SetSupportMixedDatatype(true) on the <a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> and NxsDataBlocks (or the "templates" for these blocks) before the parse.</p>
<p>NCL will also reject the (legal) NEXUS syntax: </p>
<div class="fragment"><pre class="fragment">FORMAT Datatype=DNA symbols=<span class="stringliteral">&quot;01&quot;</span>  Gap=-;
</pre></div><p> To enable augmenting the symbols list of for the sequence types, call <a class="el" href="classNxsCharactersBlock_a03323afe931168034735ad2be8a4ed8c.html#a03323afe931168034735ad2be8a4ed8c" title="Instructs the NxsCharactersBlock to accept extra symbols even if the datatype is...">NxsCharactersBlock::SetAllowAugmentingOfSequenceSymbols()</a> with the argument true. This will allow the Characters block to accept the syntax, but the <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> associated with the matrix will think of itself as a standard datatype. This reflects the uncertainty inherent in this ambiguous syntax. Whenever you find that <a class="el" href="classNxsCharactersBlock_a1feb957ad6d097cc94337d7f57776bb9.html#a1feb957ad6d097cc94337d7f57776bb9" title="Returns datatype listed in the CHARACTERS block.">NxsCharactersBlock::GetOriginalDataType()</a> != <a class="el" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&#39; from the datatype mapper.">NxsCharactersBlock::GetDataType()</a> <br/>
 this means that NCL had to convert a datatype during the parse.</p>
<p>If you also call NxsCharactersBlock::SetConvertAugmentedToMixed(true), the NCL will <b>attempt</b> to separate a sequence datatype with augmented symbols list into a mixed type that has the same sequence type but also has a set of characters that are datatype <code>standard</code>. Note that this will only work if the matrix is a mixture of sequence data and numeric symbols.</p>
<p>If the conversion to mixed cannot be safely done, the matrix will be preserved, but it will be NxsCharactersBlock::standard type matrix.</p>
<h4><a class="anchor" id="accessingMixed">
Accessing data from Mixed datatypes NxsCharactersBlock</a></h4>
<p>If you have enabled parsing of mixed datatypes, then you have to be prepared to deal with <a class="el" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&#39; from the datatype mapper.">NxsCharactersBlock::GetDataType()</a> returning <a class="el" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca53544b6c478de9117d5e98a66e5f20d1" title="indicates `matrix&#39; holds continuous data">NxsCharactersBlock::mixed</a>. Internally the characters block stores each row of the matrix as a vector of integers (the type is NxsDiscreteStateCell which is usually an <code>int</code> see <a class="el" href="index.html#improveperformance">Improving Performance</a>). Each column of the matrix is associated with a <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a>. There is one mapper for each type of data in a <a class="el" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a>. When you have non-mixed there is only one mapper, but with mixed datatypes there will be multiple.</p>
<p>You can get the <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> for a character by calling NxsCharactersBlock::GetDatatypeMapperForChar().</p>
<p>If want to process all of the columns that share a mapper as a group, then you can call <a class="el" href="classNxsCharactersBlock_a886919f70994b6d9339ccae1346c0a08.html#a886919f70994b6d9339ccae1346c0a08">NxsCharactersBlock::GetDatatypeMapForMixedType()</a>. This will return a std::map&lt;DataTypesEnum, NxsUnsignedSet&gt;. This map will be empty if the datatype is not mixed. For mixed datatypes, you can use the map to find the indices of the columns in that matrix that are of the same type (and should thus share the same GetDatatypeMapperForChar).</p>
<p>If you have enable symbols list augmenting, then you should be prepared to deal with characters blocks that report <a class="el" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca53544b6c478de9117d5e98a66e5f20d1" title="indicates `matrix&#39; holds continuous data">NxsCharactersBlock::mixed</a> from <a class="el" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&#39; from the datatype mapper.">NxsCharactersBlock::GetDataType()</a>, but report a molecular sequence type from <a class="el" href="classNxsCharactersBlock_a1feb957ad6d097cc94337d7f57776bb9.html#a1feb957ad6d097cc94337d7f57776bb9" title="Returns datatype listed in the CHARACTERS block.">NxsCharactersBlock::GetOriginalDataType()</a>. This is not too hard, but is tedious. By looking at the symbols list returned from the <a class="el" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a>, you can figure out the order of symbols in the augmented type and you can interpret any cell of the matrix correctly. Note that this type of matrix can occur even if you call SetConvertAugmentedToMixed(true), because some matrices defy automatic conversion. In such cases, the safest course is usually to use code like this: </p>
<div class="fragment"><pre class="fragment">    ... (after the parsing).
    <a class="code" href="classNxsTaxaBlock.html" title="The default implementation of the NxsTaxaBlockAPI that is used to parse TAXA blocks...">NxsTaxaBlock</a> * taxa = reader.GetTaxaBlock(0)
    <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> * charsBlock = reader.GetCharactersBlock(taxa, 0)
    <span class="keywordflow">if</span> (charsBlock-&gt;<a class="code" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&amp;#39; from the datatype mapper.">GetDataType</a>() == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca53544b6c478de9117d5e98a66e5f20d1" title="indicates `matrix&amp;#39; holds continuous data">NxsCharactersBlock::mixed</a>)
        {
        }
    <span class="keywordflow">else</span> {
        <span class="keywordflow">if</span> (charsBlock-&gt;<a class="code" href="classNxsCharactersBlock_a1feb957ad6d097cc94337d7f57776bb9.html#a1feb957ad6d097cc94337d7f57776bb9" title="Returns datatype listed in the CHARACTERS block.">GetOriginalDataType</a>() != charsBlock-&gt;<a class="code" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&amp;#39; from the datatype mapper.">GetDataType</a>())
            <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Sorry the symbols list of a sequence datatype has been augmented with extra symbols, and now I cannot diagnose the datatype.  Please edit the file to separate the different types of data into separace CHARACTERS blocks or to use the:\n FORMAT DATATYPE = MIXED(...)\nsyntax.&quot;</span>);
        <span class="keywordflow">if</span> (charsBlock-&gt;<a class="code" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&amp;#39; from the datatype mapper.">GetDataType</a>() == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca0145b9755a4581acaabe1e4c458d7f73" title="indicates `matrix&amp;#39; holds characters with arbitrarily-assigned, discrete states...">NxsCharactersBlock::dna</a>)
            {
            ...code here to deal with DNA data...
            }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (charsBlock-&gt;<a class="code" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&amp;#39; from the datatype mapper.">GetDataType</a>() == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca9cb7e8ceb8521a96df0b81ecac913814" title="indicates `matrix&amp;#39; holds DNA sequences (states A, C, G, T)">NxsCharactersBlock::rna</a>)
            {
            ...code here to deal with RNA data...
            }
        <span class="keywordflow">else</span> ...
        }
</pre></div><h3><a class="anchor" id="improveperformance">
Improving Performance</a></h3>
<p>To speed up parsing of CHARACTERS blocks (and reduce memory usage):<br/>
 If you compile NCL with the preprocessor flag NCL_SMALL_STATE_CELL, then the typdef NxsDiscreteStateCell will be a <code>signed char</code> instead of <code>int</code>. This can improve performance some (at the cost of making it possible to overflow the numuber state codes that can be handled).</p>
<p>To speed up processing of TREES blocks see <a class="el" href="classNxsTreesBlock_ade045780deec6888fa06000a10966123.html#ade045780deec6888fa06000a10966123" title="This function allows you to register a callback function that is called after each...">NxsTreesBlock::setValidationCallbacks()</a>.</p>
<h3><a class="anchor" id="indexingObjects">
Indexing objects</a></h3>
<p>Like everything else in C/C++, NCL uses indexing that starts at 0.</p>
<p>The NEXUS file format starts numbering at 1. NCL has the correct behavior as it parses a file, but if you query for an object by passing in the index of the object you should use 0-based numbering. If you query for an object with a string, and the string is a string representation of an integer, then the NEXUS (1-based rules) will be used.</p>
<p>So, <code>NxsTaxaBlock::GetTaxonLabel(0)</code> will return the label for the first taxon in the matrix (the taxon that can also be referred to in a file by the string "1").</p>
<p>NCL uses the (admittedly <em>ad hoc</em>) convention that functions that use the word Number refer to 1-based numbering, and those that use index refer to 0-based numbering scheme.</p>
<hr/>
 <h2><a class="anchor" id="FAQ">
Frequently asked questions</a></h2>
<ul>
<li><a class="el" href="index.html#performance">Is NCL efficient (time and memory) enough to handle large datasets?</a></li>
<li><a class="el" href="index.html#rockinErrorMessages">Why are the error messages that NCL generates because of invalid files so crystal-clear and helpful?</a></li>
<li><a class="el" href="index.html#crypticErrorMessages">Why do the error messages that NCL generates because of invalid files have the wrong column number?</a></li>
<li><a class="el" href="index.html#whyNxsString">Why is there a special NxsString class?</a></li>
<li><a class="el" href="index.html#whyNxsStringArg">Why do some methods take/return a NxsString while others take a std::string ?</a></li>
<li><a class="el" href="index.html#whyNoNamespaces">Why don't you use namespaces instead of the Nxs prefix?</a></li>
<li><a class="el" href="index.html#whyDumpStdNamespace">Why does NCL include use the "using namespace std;" statement? I don't want all definitions from std in my namespace!</a></li>
<li><a class="el" href="index.html#whyNotConst">Why aren't all of the functions/variables that could be declared as "const" actually declared to be "const"?</a></li>
<li><a class="el" href="index.html#whatisNCL_COULD_BE_CONST">What is NCL_COULD_BE_CONST all about?</a></li>
<li><a class="el" href="index.html#mixedDatypeSupport">Does NCL support MrBayes' <code>datatype=mixed</code> extension?</a></li>
</ul>
<hr/>
 <h3><a class="anchor" id="performance">
Is NCL efficient (time and memory) enough to handle large datasets?</a></h3>
<p>The short answer is "Yes."</p>
<p>Of course, the running time depends on exactly how big the dataset is. NCL's character matrix parsing speed is about as fast as PAUP*'s parsing (and we NCL writers are very proud of that), and its tree reading is slower that PAUP's but not terribly slow.</p>
<p>v2.1 and later are much more efficient than previous versions. On a 2.6GHz i386 MacBook (with 4GB of RAM), Mark Holder obtained the following benchmark results for parsing a file (with comparisons to previous versions of NCL and PAUP* for reference): </p>
<ul>
<li>4.4 seconds for a file with 262,144 taxa (about 90x faster than previous NCL versions. NCL v2.1 parses taxa-only files faster than PAUP on this machine) </li>
<li>3.3 seconds for a file with 16 taxa and just over 1 million DNA sites (about 40x faster than earlier versions, and slightly faster than PAUP). </li>
<li>12.8 seconds for a file with 4,096 taxa and 16,384 characters (once again about 40x faster than earlier versions, and slightly faster than PAUP). </li>
<li>7.9 seconds and 17.8 seconds for a files with 512 taxa and 4,096 trees. The first file had no branch lengths, and the second did have branch lengths (roughly 10-20x speedup compared to previous NCL versions, but 5-10x slower than PAUP*).</li>
</ul>
<hr/>
 <h3><a class="anchor" id="rockinErrorMessages">
Why are the error messages that  NCL generates because of invalid files so crystal-clear and helpful?</a></h3>
<p>Because NCL rocks!</p>
<p>Seriously, we do try hard to make the error messages helpful and have them accurately describe where the error occurs. This is definitely a strength of the library, and we strive to maintain it. Please let us know if you find a file that generates cryptic/unhelpful error messages (Also see <a class="el" href="index.html#crypticErrorMessages">Why do the error messages that NCL generates because of invalid files have the wrong column number?</a>)</p>
<hr/>
 <h3><a class="anchor" id="crypticErrorMessages">
Why do the error messages that  NCL generates because of invalid files have the wrong column number?</a></h3>
<p>So despite our generally rockin' error messages, there are some warts. It is tough to get accurate column numbers for errors. We try to support reporting of column numbers of errors because extremely long lines are common in TREES and CHARACTERS blocks. Let us know if you find misleading column numbers (check tab characters, first; NCL counts characters since the last newline. A tabstops are assumed to be set to 4, but this is admittedly arbitrary.</p>
<hr/>
 <h3><a class="anchor" id="whyNxsString">
Why is there a special NxsString class?</a></h3>
<p>Short answer: convenient appending to strings (including overloads of the "put
to" operator).</p>
<p>It is usually considered unsafe to derive from a class (such as std::string) that lacks a virtual destructor. <a class="el" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> does not have any additional data members that std::string does not, so we have gotten away with it. It is too late to reverse the decision to bundle a new string class. It is probably best to avoid using it when you don't have to.</p>
<hr/>
 <h3><a class="anchor" id="whyNxsStringArg">
Why do some methods take/return a NxsString while others take a std::string ?</a></h3>
<p>At one point we were going to abandon the use of <a class="el" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>, so newer functions take and return std::string objects. But we <b>really</b> don't want to break old code, so we are not going to complete the migration away from <a class="el" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> just for the sake of consistency of the API.</p>
<p>Sorry about that, we realize that it makes the library harder to use for newer users.</p>
<hr/>
 <h3><a class="anchor" id="whyNoNamespaces">
Why don't you use namespaces instead of the Nxs prefix?</a></h3>
<p>No good reason - history and backwards compatibility</p>
<hr/>
 <h3><a class="anchor" id="whyDumpStdNamespace">
Why does NCL include use the "using namespace std;" statement? I don't want all definitions from std in my namespace!</a></h3>
<p>It is only the convenience header <a class="el" href="ncl_8h_source.html">ncl.h</a> that does this. Either do not include this file (and simply include the headers of the parts of ncl that you do use), or define a preprocessor macro NCL_AVOID_USING_STD to keep the contents of the std namespace from being "dumped" into your code's namespace.</p>
<hr/>
 <h3><a class="anchor" id="whyNotConst">
Why aren't all of the functions/variables that could be declared as "const" actually declared to be "const"?</a></h3>
<p>No good reason - history and backwards compatibility <hr/>
 <h3><a class="anchor" id="whatisNCL_COULD_BE_CONST">
What is NCL_COULD_BE_CONST all about?</a></h3>
<p>We were trying to declare functions that should be const, but that would break old code. So if you compile NCL without any special preprocessor directives, then NCL_COULD_BE_CONST will be converted to an empty string. But if you compile with the NCL_CONST_FUNCS preprocessor flag defined(-DNCL_CONST_FUNCS for most compilers), then NCL_COULD_BE_CONST will be replaced with the word const.</p>
<p>In short if you want const-correctness checking, make sure that NCL_CONST_FUNCS is defined when you build NCL (the --with-constfuncs argument to configure will do this ), and that NCL_CONST_FUNCS is defined when you build your application.</p>
<p>If you are not obsessive compulsive, don't worry about out it.</p>
<p>Yes, we know that some more functions should be decorated with NCL_COULD_BE_CONST to improve const checking (and yes, it bugs us).</p>
<hr/>
 <h3><a class="anchor" id="mixedDatypeSupport">
Does NCL support MrBayes' &lt;tt&gt;datatype=mixed&lt;/tt&gt; extension?</a></h3>
<p>Yes. See <a class="el" href="index.html#mixedDatatypes">Dealing with Datatype=Mixed</a> discussion. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Sat Mar 27 13:49:18 2010 for NCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
