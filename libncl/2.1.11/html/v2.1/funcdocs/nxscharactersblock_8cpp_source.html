<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>NCL: nxscharactersblock.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>nxscharactersblock.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//  Copyright (C) 1999-2003 Paul O. Lewis</span>
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">//  This file is part of NCL (Nexus Class Library) version 2.0.</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">//  NCL is free software; you can redistribute it and/or modify</span>
<a name="l00006"></a>00006 <span class="comment">//  it under the terms of the GNU General Public License as published by</span>
<a name="l00007"></a>00007 <span class="comment">//  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00008"></a>00008 <span class="comment">//  (at your option) any later version.</span>
<a name="l00009"></a>00009 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment">//  NCL is distributed in the hope that it will be useful,</span>
<a name="l00011"></a>00011 <span class="comment">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<a name="l00013"></a>00013 <span class="comment">//  GNU General Public License for more details.</span>
<a name="l00014"></a>00014 <span class="comment">//</span>
<a name="l00015"></a>00015 <span class="comment">//  You should have received a copy of the GNU General Public License</span>
<a name="l00016"></a>00016 <span class="comment">//  along with NCL; if not, write to the Free Software Foundation, Inc.,</span>
<a name="l00017"></a>00017 <span class="comment">//  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<a name="l00018"></a>00018 <span class="comment">//</span>
<a name="l00023"></a>00023 <span class="comment"></span><span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;climits&gt;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;ncl/nxscharactersblock.h&quot;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;ncl/nxsreader.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;ncl/nxsassumptionsblock.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;ncl/nxssetreader.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00032"></a>00032 <span class="keyword">using namespace </span>std;
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 CodonRecodingStruct getCodonRecodingStruct(NxsGeneticCodesEnum gCode);
<a name="l00035"></a>00035 std::vector&lt;NxsDiscreteStateCell&gt; getToCodonRecodingMapper(NxsGeneticCodesEnum gCode);
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 
<a name="l00038"></a><a class="code" href="classNxsDiscreteDatatypeMapper_a862efedc401f0314fee6fb0ea6e8a88a.html#a862efedc401f0314fee6fb0ea6e8a88a">00038</a> <span class="keywordtype">void</span> <a class="code" href="classNxsDiscreteDatatypeMapper_a862efedc401f0314fee6fb0ea6e8a88a.html#a862efedc401f0314fee6fb0ea6e8a88a" title="can be used to &amp;quot;See&amp;quot; the mapping while debugging">NxsDiscreteDatatypeMapper::DebugWriteMapperFields</a>(std::ostream &amp; out)<span class="keyword"> const</span>
<a name="l00039"></a>00039 <span class="keyword"></span>{
<a name="l00040"></a>00040     out &lt;&lt; nStates &lt;&lt; <span class="stringliteral">&quot;\&quot;fundamental\&quot; states\n&quot;</span>;
<a name="l00041"></a>00041     out &lt;&lt; <span class="stringliteral">&quot;Symbols = \&quot;&quot;</span> &lt;&lt; symbols &lt;&lt; <span class="stringliteral">&quot;\&quot;\n&quot;</span>;
<a name="l00042"></a>00042     <span class="keywordflow">if</span> (respectCase)
<a name="l00043"></a>00043         out &lt;&lt; <span class="stringliteral">&quot;Symbol comparison respects case (is case-sensitive)\n&quot;</span>;
<a name="l00044"></a>00044     <span class="keywordflow">else</span>
<a name="l00045"></a>00045         out &lt;&lt; <span class="stringliteral">&quot;Symbol comparison does not respect case (is case-insensitive)\n&quot;</span>;
<a name="l00046"></a>00046     <span class="keywordflow">if</span> (gapChar == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l00047"></a>00047         out &lt;&lt; <span class="stringliteral">&quot;No Gaps\n&quot;</span>;
<a name="l00048"></a>00048     <span class="keywordflow">else</span>
<a name="l00049"></a>00049         out &lt;&lt; <span class="stringliteral">&quot;Gap char is &quot;</span> &lt;&lt; gapChar &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00050"></a>00050 
<a name="l00051"></a>00051     out &lt;&lt; <span class="stringliteral">&quot;State codes:\n&quot;</span>;
<a name="l00052"></a>00052     <span class="keywordtype">int</span> nsc = (int)<a class="code" href="classNxsDiscreteDatatypeMapper_a5c4a4c64c5a1fc2484c48134912471b6.html#a5c4a4c64c5a1fc2484c48134912471b6">GetNumStateCodes</a>();
<a name="l00053"></a>00053     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> scc = 0; scc &lt; nsc; ++scc)
<a name="l00054"></a>00054         {
<a name="l00055"></a>00055         <span class="keywordtype">int</span> sc = scc + sclOffset;
<a name="l00056"></a>00056         out &lt;&lt; sc &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l00057"></a>00057         <span class="keywordflow">if</span> (sc == NXS_MISSING_CODE)
<a name="l00058"></a>00058             out &lt;&lt; missing &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l00059"></a>00059         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sc == NXS_GAP_STATE_CODE)
<a name="l00060"></a>00060             out &lt;&lt; gapChar &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l00061"></a>00061         <span class="keywordflow">else</span>
<a name="l00062"></a>00062             {
<a name="l00063"></a>00063             <span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt; &amp; ssfc(<a class="code" href="classNxsDiscreteDatatypeMapper_ad39cdce419be460c3a197dfa07a96c80.html#ad39cdce419be460c3a197dfa07a96c80" title="Returns the set of state indices that correspond to the states of state code `c`...">GetStateSetForCode</a>(sc));
<a name="l00064"></a>00064             std::set&lt;NxsDiscreteStateCell&gt;::const_iterator sIt = ssfc.begin();
<a name="l00065"></a>00065             <span class="keywordflow">if</span> (ssfc.size() == 1)
<a name="l00066"></a>00066                 {
<a name="l00067"></a>00067                 out &lt;&lt; symbols[*sIt];
<a name="l00068"></a>00068                 }
<a name="l00069"></a>00069             <span class="keywordflow">else</span>
<a name="l00070"></a>00070                 {
<a name="l00071"></a>00071                 <span class="keywordflow">if</span> (<a class="code" href="classNxsDiscreteDatatypeMapper_afe4f8b3edb65863211bcd5a2746215e3.html#afe4f8b3edb65863211bcd5a2746215e3" title="Returns true if the state code maps to a collection of states that were flagged as...">IsPolymorphic</a>(sc))
<a name="l00072"></a>00072                     out &lt;&lt; <span class="charliteral">&#39;(&#39;</span>;
<a name="l00073"></a>00073                 <span class="keywordflow">else</span>
<a name="l00074"></a>00074                     out &lt;&lt; <span class="charliteral">&#39;{&#39;</span>;
<a name="l00075"></a>00075                 <span class="keywordflow">for</span> (; sIt != ssfc.end(); ++sIt)
<a name="l00076"></a>00076                     {
<a name="l00077"></a>00077                     <span class="keywordflow">if</span> (*sIt == NXS_MISSING_CODE)
<a name="l00078"></a>00078                         out &lt;&lt; missing;
<a name="l00079"></a>00079                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*sIt == NXS_GAP_STATE_CODE)
<a name="l00080"></a>00080                         out &lt;&lt; gapChar;
<a name="l00081"></a>00081                     <span class="keywordflow">else</span>
<a name="l00082"></a>00082                         out &lt;&lt; symbols[*sIt];
<a name="l00083"></a>00083                     }
<a name="l00084"></a>00084                 <span class="keywordflow">if</span> (<a class="code" href="classNxsDiscreteDatatypeMapper_afe4f8b3edb65863211bcd5a2746215e3.html#afe4f8b3edb65863211bcd5a2746215e3" title="Returns true if the state code maps to a collection of states that were flagged as...">IsPolymorphic</a>(sc))
<a name="l00085"></a>00085                     out &lt;&lt; <span class="charliteral">&#39;)&#39;</span>;
<a name="l00086"></a>00086                 <span class="keywordflow">else</span>
<a name="l00087"></a>00087                     out &lt;&lt; <span class="charliteral">&#39;}&#39;</span>;
<a name="l00088"></a>00088                 }
<a name="l00089"></a>00089             out &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l00090"></a>00090             }
<a name="l00091"></a>00091         }
<a name="l00092"></a>00092 
<a name="l00093"></a>00093     std::map&lt;char, NxsString&gt;::const_iterator eeIt = extraEquates.begin();
<a name="l00094"></a>00094     <span class="keywordflow">if</span> (eeIt != extraEquates.end())
<a name="l00095"></a>00095         {
<a name="l00096"></a>00096         out &lt;&lt; <span class="stringliteral">&quot;Extra equates:\n&quot;</span>;
<a name="l00097"></a>00097         <span class="keywordflow">for</span> (; eeIt != extraEquates.end(); ++eeIt)
<a name="l00098"></a>00098             out &lt;&lt; eeIt-&gt;first  &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; eeIt-&gt;second &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l00099"></a>00099         }
<a name="l00100"></a>00100     out.flush();
<a name="l00101"></a>00101 }
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lcBaseToInd(<span class="keywordtype">char</span> );
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lcBaseToInd(<span class="keywordtype">char</span> c) {
<a name="l00106"></a>00106     <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;a&#39;</span>)
<a name="l00107"></a>00107         <span class="keywordflow">return</span> 0;
<a name="l00108"></a>00108     <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;c&#39;</span>)
<a name="l00109"></a>00109         <span class="keywordflow">return</span> 1;
<a name="l00110"></a>00110     <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;g&#39;</span>)
<a name="l00111"></a>00111         <span class="keywordflow">return</span> 2;
<a name="l00112"></a>00112     <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;t&#39;</span>)
<a name="l00113"></a>00113         <span class="keywordflow">return</span> 3;
<a name="l00114"></a>00114     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Expecting a DNA base&quot;</span>);
<a name="l00115"></a>00115 }
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 NxsCodonTriplet::NxsCodonTriplet(<span class="keyword">const</span> <span class="keywordtype">char</span> *triplet)
<a name="l00118"></a>00118 {
<a name="l00119"></a>00119     std::string s(triplet);
<a name="l00120"></a>00120     <span class="keywordflow">if</span> (s.length() != 3)
<a name="l00121"></a>00121         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Expecting a triplet of bases&quot;</span>);
<a name="l00122"></a>00122     <a class="code" href="classNxsString_a8a226fa743e246c3b2b65880deaa81db.html#a8a226fa743e246c3b2b65880deaa81db" title="Capitalizes every character in s.">NxsString::to_lower</a>(s);
<a name="l00123"></a>00123     this-&gt;firstPos = lcBaseToInd(s[0]);
<a name="l00124"></a>00124     this-&gt;secondPos = lcBaseToInd(s[1]);
<a name="l00125"></a>00125     this-&gt;thirdPos = lcBaseToInd(s[2]);
<a name="l00126"></a>00126 }
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 NxsCodonTriplet::MutDescription NxsCodonTriplet::getSingleMut(<span class="keyword">const</span> NxsCodonTriplet &amp; other)<span class="keyword"> const </span>{
<a name="l00130"></a>00130     <span class="keywordflow">if</span> (firstPos == other.firstPos) {
<a name="l00131"></a>00131         <span class="keywordflow">if</span> (secondPos == other.secondPos) {
<a name="l00132"></a>00132             <span class="keywordflow">if</span> (thirdPos == other.thirdPos)
<a name="l00133"></a>00133                 <span class="keywordflow">return</span> MutDescription(0,0);
<a name="l00134"></a>00134             <span class="keywordflow">return</span> MutDescription((<span class="keywordtype">int</span>)thirdPos, (<span class="keywordtype">int</span>)other.thirdPos);
<a name="l00135"></a>00135         }
<a name="l00136"></a>00136         <span class="keywordflow">if</span> (thirdPos == other.thirdPos)
<a name="l00137"></a>00137             <span class="keywordflow">return</span> MutDescription((<span class="keywordtype">int</span>)secondPos, (<span class="keywordtype">int</span>)other.secondPos);
<a name="l00138"></a>00138         <span class="keywordflow">return</span> MutDescription(-1, -1);
<a name="l00139"></a>00139     }
<a name="l00140"></a>00140     <span class="keywordflow">if</span> (secondPos == other.secondPos) {
<a name="l00141"></a>00141         <span class="keywordflow">if</span> (thirdPos == other.thirdPos)
<a name="l00142"></a>00142             <span class="keywordflow">return</span> MutDescription((<span class="keywordtype">int</span>)firstPos, (<span class="keywordtype">int</span>)other.firstPos);
<a name="l00143"></a>00143         <span class="keywordflow">return</span> MutDescription(-1, -1);
<a name="l00144"></a>00144     }
<a name="l00145"></a>00145     <span class="keywordflow">return</span> MutDescription(-1, -1);
<a name="l00146"></a>00146 }
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="comment">/*******************************************************************************</span>
<a name="l00150"></a>00150 <span class="comment"> * deletes &quot;fundamental&quot; states (rather than gaps or ambiguity codes) from a</span>
<a name="l00151"></a>00151 <span class="comment"> * datatype mapper.</span>
<a name="l00152"></a>00152 <span class="comment"> * Equates (default or user-defined) are not supported in the current version of the function</span>
<a name="l00153"></a>00153 <span class="comment"> *  (so this will only work on standard or codons data).</span>
<a name="l00154"></a>00154 <span class="comment"> */</span>
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 <span class="keywordtype">void</span> NxsDiscreteDatatypeMapper::DeleteStateIndices(<span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt; &amp; deletedInds)
<a name="l00157"></a>00157 {
<a name="l00158"></a>00158     <span class="keywordflow">if</span> (deletedInds.empty())
<a name="l00159"></a>00159         <span class="keywordflow">return</span>;
<a name="l00160"></a>00160     <span class="keywordflow">if</span> (*(deletedInds.begin()) &lt; 0 || *(deletedInds.rbegin()) &gt;= (NxsDiscreteStateCell)this-&gt;nStates)
<a name="l00161"></a>00161         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;DeleteStateIndices can only delete fundamental states&quot;</span>);
<a name="l00162"></a>00162     <span class="keywordflow">if</span> (!(NxsCharactersBlock::GetDefaultEquates(this-&gt;datatype).empty() &amp;&amp; extraEquates.empty()))
<a name="l00163"></a>00163         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;DeleteStateIndices can not currently work on datatypes with equates&quot;</span>);
<a name="l00164"></a>00164     std::vector&lt;NxsDiscreteStateCell&gt; remap;
<a name="l00165"></a>00165     NxsDiscreteStateCell newIndex = 0;
<a name="l00166"></a>00166     std::string nsym;
<a name="l00167"></a>00167     <span class="keywordflow">for</span> (NxsDiscreteStateCell i = 0; i &lt; (NxsDiscreteStateCell) this-&gt;nStates; ++i)
<a name="l00168"></a>00168         {
<a name="l00169"></a>00169         <span class="keywordflow">if</span> (deletedInds.find(i) == deletedInds.end())
<a name="l00170"></a>00170             {
<a name="l00171"></a>00171             remap.push_back(newIndex++);
<a name="l00172"></a>00172             nsym.append(1, symbols[i]);
<a name="l00173"></a>00173             }
<a name="l00174"></a>00174         <span class="keywordflow">else</span>
<a name="l00175"></a>00175             remap.push_back(NXS_INVALID_STATE_CODE);
<a name="l00176"></a>00176         }
<a name="l00177"></a>00177     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> oldNStates = nStates;
<a name="l00178"></a>00178     std::vector&lt;NxsDiscreteStateSetInfo&gt; oldStateSetsVec = this-&gt;stateSetsVec;
<a name="l00179"></a>00179     symbols = nsym;
<a name="l00180"></a>00180 
<a name="l00181"></a>00181     this-&gt;RefreshMappings(0L);
<a name="l00182"></a>00182 
<a name="l00183"></a>00183     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = oldNStates - sclOffset; i &lt; oldStateSetsVec.size(); ++i)
<a name="l00184"></a>00184         {
<a name="l00185"></a>00185         <span class="keyword">const</span> NxsDiscreteStateSetInfo &amp; ssi = oldStateSetsVec[i];
<a name="l00186"></a>00186         std::set&lt;NxsDiscreteStateCell&gt; stSet;
<a name="l00187"></a>00187         <span class="keywordflow">for</span> (std::set&lt;NxsDiscreteStateCell&gt;::const_iterator s = ssi.states.begin(); s != ssi.states.end(); ++s)
<a name="l00188"></a>00188             {
<a name="l00189"></a>00189             NxsDiscreteStateCell u = *s;
<a name="l00190"></a>00190             <span class="keywordflow">if</span> (u &lt; 0)
<a name="l00191"></a>00191                 stSet.insert(u);
<a name="l00192"></a>00192             <span class="keywordflow">else</span>
<a name="l00193"></a>00193                 {
<a name="l00194"></a>00194                 NxsDiscreteStateCell r = remap.at(u);
<a name="l00195"></a>00195                 <span class="keywordflow">if</span> (r &gt;= 0)
<a name="l00196"></a>00196                     stSet.insert(r);
<a name="l00197"></a>00197                 }
<a name="l00198"></a>00198             }
<a name="l00199"></a>00199         <span class="comment">// We have to add every &quot;extra&quot; state set, so that the indexing for the higher state codes is just shifted by the number of states deleted</span>
<a name="l00200"></a>00200         AddStateSet(stSet, ssi.nexusSymbol, <span class="keyword">true</span>, ssi.isPolymorphic);
<a name="l00201"></a>00201         }
<a name="l00202"></a>00202 }
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 std::vector&lt;NxsDiscreteStateCell&gt; getToCodonRecodingMapper(NxsGeneticCodesEnum gCode)
<a name="l00205"></a>00205 {
<a name="l00206"></a>00206     std::vector&lt;NxsDiscreteStateCell&gt; v;
<a name="l00207"></a>00207     <span class="keywordflow">if</span>(gCode == NXS_GCODE_STANDARD) {
<a name="l00208"></a>00208         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_standard[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, -1, 48, -1, 49, 50, 51, 52, 53, -1, 54, 55, 56, 57, 58, 59, 60};
<a name="l00209"></a>00209         std::copy(trnxs_gcode_standard, trnxs_gcode_standard + 64, back_inserter(v));
<a name="l00210"></a>00210         <span class="keywordflow">return</span> v;
<a name="l00211"></a>00211     }
<a name="l00212"></a>00212     <span class="keywordflow">if</span>(gCode == NXS_GCODE_VERT_MITO) {
<a name="l00213"></a>00213         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_vert_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, -1, 8, -1, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, -1, 46, -1, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59};
<a name="l00214"></a>00214         std::copy(trnxs_gcode_vert_mito, trnxs_gcode_vert_mito + 64, back_inserter(v));
<a name="l00215"></a>00215         <span class="keywordflow">return</span> v;
<a name="l00216"></a>00216     }
<a name="l00217"></a>00217     <span class="keywordflow">if</span>(gCode == NXS_GCODE_YEAST_MITO) {
<a name="l00218"></a>00218         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_yeast_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, -1, 48, -1, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61};
<a name="l00219"></a>00219         std::copy(trnxs_gcode_yeast_mito, trnxs_gcode_yeast_mito + 64, back_inserter(v));
<a name="l00220"></a>00220         <span class="keywordflow">return</span> v;
<a name="l00221"></a>00221     }
<a name="l00222"></a>00222     <span class="keywordflow">if</span>(gCode == NXS_GCODE_MOLD_MITO) {
<a name="l00223"></a>00223         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_mold_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, -1, 48, -1, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61};
<a name="l00224"></a>00224         std::copy(trnxs_gcode_mold_mito, trnxs_gcode_mold_mito + 64, back_inserter(v));
<a name="l00225"></a>00225         <span class="keywordflow">return</span> v;
<a name="l00226"></a>00226     }
<a name="l00227"></a>00227     <span class="keywordflow">if</span>(gCode == NXS_GCODE_INVERT_MITO) {
<a name="l00228"></a>00228         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_invert_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, -1, 48, -1, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61};
<a name="l00229"></a>00229         std::copy(trnxs_gcode_invert_mito, trnxs_gcode_invert_mito + 64, back_inserter(v));
<a name="l00230"></a>00230         <span class="keywordflow">return</span> v;
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232     <span class="keywordflow">if</span>(gCode == NXS_GCODE_CILIATE) {
<a name="l00233"></a>00233         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_ciliate[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, -1, 56, 57, 58, 59, 60, 61, 62};
<a name="l00234"></a>00234         std::copy(trnxs_gcode_ciliate, trnxs_gcode_ciliate + 64, back_inserter(v));
<a name="l00235"></a>00235         <span class="keywordflow">return</span> v;
<a name="l00236"></a>00236     }
<a name="l00237"></a>00237     <span class="keywordflow">if</span>(gCode == NXS_GCODE_ECHINO_MITO) {
<a name="l00238"></a>00238         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_echino_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, -1, 48, -1, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61};
<a name="l00239"></a>00239         std::copy(trnxs_gcode_echino_mito, trnxs_gcode_echino_mito + 64, back_inserter(v));
<a name="l00240"></a>00240         <span class="keywordflow">return</span> v;
<a name="l00241"></a>00241     }
<a name="l00242"></a>00242     <span class="keywordflow">if</span>(gCode == NXS_GCODE_EUPLOTID) {
<a name="l00243"></a>00243         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_euplotid[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, -1, 48, -1, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61};
<a name="l00244"></a>00244         std::copy(trnxs_gcode_euplotid, trnxs_gcode_euplotid + 64, back_inserter(v));
<a name="l00245"></a>00245         <span class="keywordflow">return</span> v;
<a name="l00246"></a>00246     }
<a name="l00247"></a>00247     <span class="keywordflow">if</span>(gCode == NXS_GCODE_PLANT_PLASTID) {
<a name="l00248"></a>00248         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_plant_plastid[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, -1, 48, -1, 49, 50, 51, 52, 53, -1, 54, 55, 56, 57, 58, 59, 60};
<a name="l00249"></a>00249         std::copy(trnxs_gcode_plant_plastid, trnxs_gcode_plant_plastid + 64, back_inserter(v));
<a name="l00250"></a>00250         <span class="keywordflow">return</span> v;
<a name="l00251"></a>00251     }
<a name="l00252"></a>00252     <span class="keywordflow">if</span>(gCode == NXS_GCODE_ALT_YEAST) {
<a name="l00253"></a>00253         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_alt_yeast[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, -1, 48, -1, 49, 50, 51, 52, 53, -1, 54, 55, 56, 57, 58, 59, 60};
<a name="l00254"></a>00254         std::copy(trnxs_gcode_alt_yeast, trnxs_gcode_alt_yeast + 64, back_inserter(v));
<a name="l00255"></a>00255         <span class="keywordflow">return</span> v;
<a name="l00256"></a>00256     }
<a name="l00257"></a>00257     <span class="keywordflow">if</span>(gCode == NXS_GCODE_ASCIDIAN_MITO) {
<a name="l00258"></a>00258         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_ascidian_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, -1, 48, -1, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61};
<a name="l00259"></a>00259         std::copy(trnxs_gcode_ascidian_mito, trnxs_gcode_ascidian_mito + 64, back_inserter(v));
<a name="l00260"></a>00260         <span class="keywordflow">return</span> v;
<a name="l00261"></a>00261     }
<a name="l00262"></a>00262     <span class="keywordflow">if</span>(gCode == NXS_GCODE_ALT_FLATWORM_MITO) {
<a name="l00263"></a>00263         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_alt_flatworm_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, -1, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62};
<a name="l00264"></a>00264         std::copy(trnxs_gcode_alt_flatworm_mito, trnxs_gcode_alt_flatworm_mito + 64, back_inserter(v));
<a name="l00265"></a>00265         <span class="keywordflow">return</span> v;
<a name="l00266"></a>00266     }
<a name="l00267"></a>00267     <span class="keywordflow">if</span>(gCode == NXS_GCODE_BLEPHARISMA_MACRO) {
<a name="l00268"></a>00268         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_blepharisma_macro[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, -1, 48, 49, 50, 51, 52, 53, 54, -1, 55, 56, 57, 58, 59, 60, 61};
<a name="l00269"></a>00269         std::copy(trnxs_gcode_blepharisma_macro, trnxs_gcode_blepharisma_macro + 64, back_inserter(v));
<a name="l00270"></a>00270         <span class="keywordflow">return</span> v;
<a name="l00271"></a>00271     }
<a name="l00272"></a>00272     <span class="keywordflow">if</span>(gCode == NXS_GCODE_CHLOROPHYCEAN_MITO) {
<a name="l00273"></a>00273         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_chlorophycean_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, -1, 48, 49, 50, 51, 52, 53, 54, -1, 55, 56, 57, 58, 59, 60, 61};
<a name="l00274"></a>00274         std::copy(trnxs_gcode_chlorophycean_mito, trnxs_gcode_chlorophycean_mito + 64, back_inserter(v));
<a name="l00275"></a>00275         <span class="keywordflow">return</span> v;
<a name="l00276"></a>00276     }
<a name="l00277"></a>00277     <span class="keywordflow">if</span>(gCode == NXS_GCODE_TREMATODE_MITO) {
<a name="l00278"></a>00278         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_trematode_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, -1, 48, -1, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61};
<a name="l00279"></a>00279         std::copy(trnxs_gcode_trematode_mito, trnxs_gcode_trematode_mito + 64, back_inserter(v));
<a name="l00280"></a>00280         <span class="keywordflow">return</span> v;
<a name="l00281"></a>00281     }
<a name="l00282"></a>00282     <span class="keywordflow">if</span>(gCode == NXS_GCODE_SCENEDESMUS_MITO) {
<a name="l00283"></a>00283         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_scenedesmus_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, -1, 48, 49, 50, -1, 51, 52, 53, -1, 54, 55, 56, 57, 58, 59, 60};
<a name="l00284"></a>00284         std::copy(trnxs_gcode_scenedesmus_mito, trnxs_gcode_scenedesmus_mito + 64, back_inserter(v));
<a name="l00285"></a>00285         <span class="keywordflow">return</span> v;
<a name="l00286"></a>00286     }
<a name="l00287"></a>00287     <span class="keywordflow">if</span>(gCode == NXS_GCODE_THRAUSTOCHYTRIUM_MITO) {
<a name="l00288"></a>00288         <span class="keyword">const</span> NxsDiscreteStateCell trnxs_gcode_thraustochytrium_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, -1, 48, -1, 49, 50, 51, 52, 53, -1, 54, 55, 56, -1, 57, 58, 59};
<a name="l00289"></a>00289         std::copy(trnxs_gcode_thraustochytrium_mito, trnxs_gcode_thraustochytrium_mito + 64, back_inserter(v));
<a name="l00290"></a>00290         <span class="keywordflow">return</span> v;
<a name="l00291"></a>00291     }
<a name="l00292"></a>00292     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Unrecognized genetic code.&quot;</span>);
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 CodonRecodingStruct getCodonRecodingStruct(NxsGeneticCodesEnum gCode)
<a name="l00297"></a>00297 {
<a name="l00298"></a>00298     CodonRecodingStruct c;
<a name="l00299"></a>00299     <span class="keywordtype">unsigned</span> n;
<a name="l00300"></a>00300 
<a name="l00301"></a>00301     <span class="keywordflow">if</span>(gCode == NXS_GCODE_STANDARD) {
<a name="l00302"></a>00302         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_standard[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 63};
<a name="l00303"></a>00303         n = 61;
<a name="l00304"></a>00304         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_standard[] = {8, 11, 8, 11, 16, 16, 16, 16, 14, 15, 14, 15, 7, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 19, 15, 15, 15, 15, 1, 18, 1, 9, 4, 9, 4};
<a name="l00305"></a>00305         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_standard[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00306"></a>00306         std::copy(ccitacnxs_gcode_standard, ccitacnxs_gcode_standard + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00307"></a>00307         std::copy(caaindnxs_gcode_standard, caaindnxs_gcode_standard + n, back_inserter(c.aaInd));
<a name="l00308"></a>00308         std::copy(ccodstrnxs_gcode_standard, ccodstrnxs_gcode_standard + n, back_inserter(c.codonStrings));
<a name="l00309"></a>00309         <span class="keywordflow">return</span> c;
<a name="l00310"></a>00310     }
<a name="l00311"></a>00311     <span class="keywordflow">if</span>(gCode == NXS_GCODE_VERT_MITO) {
<a name="l00312"></a>00312         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_vert_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63};
<a name="l00313"></a>00313         n = 60;
<a name="l00314"></a>00314         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_vert_mito[] = {8, 11, 8, 11, 16, 16, 16, 16, 15, 15, 10, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 19, 15, 15, 15, 15, 18, 1, 18, 1, 9, 4, 9, 4};
<a name="l00315"></a>00315         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_vert_mito[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGA&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00316"></a>00316         std::copy(ccitacnxs_gcode_vert_mito, ccitacnxs_gcode_vert_mito + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00317"></a>00317         std::copy(caaindnxs_gcode_vert_mito, caaindnxs_gcode_vert_mito + n, back_inserter(c.aaInd));
<a name="l00318"></a>00318         std::copy(ccodstrnxs_gcode_vert_mito, ccodstrnxs_gcode_vert_mito + n, back_inserter(c.codonStrings));
<a name="l00319"></a>00319         <span class="keywordflow">return</span> c;
<a name="l00320"></a>00320     }
<a name="l00321"></a>00321     <span class="keywordflow">if</span>(gCode == NXS_GCODE_YEAST_MITO) {
<a name="l00322"></a>00322         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_yeast_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63};
<a name="l00323"></a>00323         n = 62;
<a name="l00324"></a>00324         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_yeast_mito[] = {8, 11, 8, 11, 16, 16, 16, 16, 14, 15, 14, 15, 7, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 19, 15, 15, 15, 15, 18, 1, 18, 1, 9, 4, 9, 4};
<a name="l00325"></a>00325         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_yeast_mito[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGA&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00326"></a>00326         std::copy(ccitacnxs_gcode_yeast_mito, ccitacnxs_gcode_yeast_mito + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00327"></a>00327         std::copy(caaindnxs_gcode_yeast_mito, caaindnxs_gcode_yeast_mito + n, back_inserter(c.aaInd));
<a name="l00328"></a>00328         std::copy(ccodstrnxs_gcode_yeast_mito, ccodstrnxs_gcode_yeast_mito + n, back_inserter(c.codonStrings));
<a name="l00329"></a>00329         <span class="keywordflow">return</span> c;
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331     <span class="keywordflow">if</span>(gCode == NXS_GCODE_MOLD_MITO) {
<a name="l00332"></a>00332         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_mold_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63};
<a name="l00333"></a>00333         n = 62;
<a name="l00334"></a>00334         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_mold_mito[] = {8, 11, 8, 11, 16, 16, 16, 16, 14, 15, 14, 15, 7, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 19, 15, 15, 15, 15, 18, 1, 18, 1, 9, 4, 9, 4};
<a name="l00335"></a>00335         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_mold_mito[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGA&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00336"></a>00336         std::copy(ccitacnxs_gcode_mold_mito, ccitacnxs_gcode_mold_mito + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00337"></a>00337         std::copy(caaindnxs_gcode_mold_mito, caaindnxs_gcode_mold_mito + n, back_inserter(c.aaInd));
<a name="l00338"></a>00338         std::copy(ccodstrnxs_gcode_mold_mito, ccodstrnxs_gcode_mold_mito + n, back_inserter(c.codonStrings));
<a name="l00339"></a>00339         <span class="keywordflow">return</span> c;
<a name="l00340"></a>00340     }
<a name="l00341"></a>00341     <span class="keywordflow">if</span>(gCode == NXS_GCODE_INVERT_MITO) {
<a name="l00342"></a>00342         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_invert_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63};
<a name="l00343"></a>00343         n = 62;
<a name="l00344"></a>00344         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_invert_mito[] = {8, 11, 8, 11, 16, 16, 16, 16, 15, 15, 15, 15, 10, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 19, 15, 15, 15, 15, 18, 1, 18, 1, 9, 4, 9, 4};
<a name="l00345"></a>00345         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_invert_mito[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGA&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00346"></a>00346         std::copy(ccitacnxs_gcode_invert_mito, ccitacnxs_gcode_invert_mito + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00347"></a>00347         std::copy(caaindnxs_gcode_invert_mito, caaindnxs_gcode_invert_mito + n, back_inserter(c.aaInd));
<a name="l00348"></a>00348         std::copy(ccodstrnxs_gcode_invert_mito, ccodstrnxs_gcode_invert_mito + n, back_inserter(c.codonStrings));
<a name="l00349"></a>00349         <span class="keywordflow">return</span> c;
<a name="l00350"></a>00350     }
<a name="l00351"></a>00351     <span class="keywordflow">if</span>(gCode == NXS_GCODE_CILIATE) {
<a name="l00352"></a>00352         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_ciliate[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 63};
<a name="l00353"></a>00353         n = 63;
<a name="l00354"></a>00354         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_ciliate[] = {8, 11, 8, 11, 16, 16, 16, 16, 14, 15, 14, 15, 7, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 13, 19, 13, 19, 15, 15, 15, 15, 1, 18, 1, 9, 4, 9, 4};
<a name="l00355"></a>00355         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_ciliate[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAA&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAG&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00356"></a>00356         std::copy(ccitacnxs_gcode_ciliate, ccitacnxs_gcode_ciliate + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00357"></a>00357         std::copy(caaindnxs_gcode_ciliate, caaindnxs_gcode_ciliate + n, back_inserter(c.aaInd));
<a name="l00358"></a>00358         std::copy(ccodstrnxs_gcode_ciliate, ccodstrnxs_gcode_ciliate + n, back_inserter(c.codonStrings));
<a name="l00359"></a>00359         <span class="keywordflow">return</span> c;
<a name="l00360"></a>00360     }
<a name="l00361"></a>00361     <span class="keywordflow">if</span>(gCode == NXS_GCODE_ECHINO_MITO) {
<a name="l00362"></a>00362         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_echino_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63};
<a name="l00363"></a>00363         n = 62;
<a name="l00364"></a>00364         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_echino_mito[] = {11, 11, 8, 11, 16, 16, 16, 16, 15, 15, 15, 15, 7, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 19, 15, 15, 15, 15, 18, 1, 18, 1, 9, 4, 9, 4};
<a name="l00365"></a>00365         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_echino_mito[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGA&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00366"></a>00366         std::copy(ccitacnxs_gcode_echino_mito, ccitacnxs_gcode_echino_mito + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00367"></a>00367         std::copy(caaindnxs_gcode_echino_mito, caaindnxs_gcode_echino_mito + n, back_inserter(c.aaInd));
<a name="l00368"></a>00368         std::copy(ccodstrnxs_gcode_echino_mito, ccodstrnxs_gcode_echino_mito + n, back_inserter(c.codonStrings));
<a name="l00369"></a>00369         <span class="keywordflow">return</span> c;
<a name="l00370"></a>00370     }
<a name="l00371"></a>00371     <span class="keywordflow">if</span>(gCode == NXS_GCODE_EUPLOTID) {
<a name="l00372"></a>00372         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_euplotid[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63};
<a name="l00373"></a>00373         n = 62;
<a name="l00374"></a>00374         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_euplotid[] = {8, 11, 8, 11, 16, 16, 16, 16, 14, 15, 14, 15, 7, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 19, 15, 15, 15, 15, 1, 1, 18, 1, 9, 4, 9, 4};
<a name="l00375"></a>00375         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_euplotid[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGA&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00376"></a>00376         std::copy(ccitacnxs_gcode_euplotid, ccitacnxs_gcode_euplotid + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00377"></a>00377         std::copy(caaindnxs_gcode_euplotid, caaindnxs_gcode_euplotid + n, back_inserter(c.aaInd));
<a name="l00378"></a>00378         std::copy(ccodstrnxs_gcode_euplotid, ccodstrnxs_gcode_euplotid + n, back_inserter(c.codonStrings));
<a name="l00379"></a>00379         <span class="keywordflow">return</span> c;
<a name="l00380"></a>00380     }
<a name="l00381"></a>00381     <span class="keywordflow">if</span>(gCode == NXS_GCODE_PLANT_PLASTID) {
<a name="l00382"></a>00382         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_plant_plastid[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 63};
<a name="l00383"></a>00383         n = 61;
<a name="l00384"></a>00384         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_plant_plastid[] = {8, 11, 8, 11, 16, 16, 16, 16, 14, 15, 14, 15, 7, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 19, 15, 15, 15, 15, 1, 18, 1, 9, 4, 9, 4};
<a name="l00385"></a>00385         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_plant_plastid[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00386"></a>00386         std::copy(ccitacnxs_gcode_plant_plastid, ccitacnxs_gcode_plant_plastid + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00387"></a>00387         std::copy(caaindnxs_gcode_plant_plastid, caaindnxs_gcode_plant_plastid + n, back_inserter(c.aaInd));
<a name="l00388"></a>00388         std::copy(ccodstrnxs_gcode_plant_plastid, ccodstrnxs_gcode_plant_plastid + n, back_inserter(c.codonStrings));
<a name="l00389"></a>00389         <span class="keywordflow">return</span> c;
<a name="l00390"></a>00390     }
<a name="l00391"></a>00391     <span class="keywordflow">if</span>(gCode == NXS_GCODE_ALT_YEAST) {
<a name="l00392"></a>00392         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_alt_yeast[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 63};
<a name="l00393"></a>00393         n = 61;
<a name="l00394"></a>00394         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_alt_yeast[] = {8, 11, 8, 11, 16, 16, 16, 16, 14, 15, 14, 15, 7, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 15, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 19, 15, 15, 15, 15, 1, 18, 1, 9, 4, 9, 4};
<a name="l00395"></a>00395         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_alt_yeast[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00396"></a>00396         std::copy(ccitacnxs_gcode_alt_yeast, ccitacnxs_gcode_alt_yeast + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00397"></a>00397         std::copy(caaindnxs_gcode_alt_yeast, caaindnxs_gcode_alt_yeast + n, back_inserter(c.aaInd));
<a name="l00398"></a>00398         std::copy(ccodstrnxs_gcode_alt_yeast, ccodstrnxs_gcode_alt_yeast + n, back_inserter(c.codonStrings));
<a name="l00399"></a>00399         <span class="keywordflow">return</span> c;
<a name="l00400"></a>00400     }
<a name="l00401"></a>00401     <span class="keywordflow">if</span>(gCode == NXS_GCODE_ASCIDIAN_MITO) {
<a name="l00402"></a>00402         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_ascidian_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63};
<a name="l00403"></a>00403         n = 62;
<a name="l00404"></a>00404         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_ascidian_mito[] = {8, 11, 8, 11, 16, 16, 16, 16, 5, 15, 5, 15, 10, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 19, 15, 15, 15, 15, 18, 1, 18, 1, 9, 4, 9, 4};
<a name="l00405"></a>00405         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_ascidian_mito[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGA&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00406"></a>00406         std::copy(ccitacnxs_gcode_ascidian_mito, ccitacnxs_gcode_ascidian_mito + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00407"></a>00407         std::copy(caaindnxs_gcode_ascidian_mito, caaindnxs_gcode_ascidian_mito + n, back_inserter(c.aaInd));
<a name="l00408"></a>00408         std::copy(ccodstrnxs_gcode_ascidian_mito, ccodstrnxs_gcode_ascidian_mito + n, back_inserter(c.codonStrings));
<a name="l00409"></a>00409         <span class="keywordflow">return</span> c;
<a name="l00410"></a>00410     }
<a name="l00411"></a>00411     <span class="keywordflow">if</span>(gCode == NXS_GCODE_ALT_FLATWORM_MITO) {
<a name="l00412"></a>00412         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_alt_flatworm_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63};
<a name="l00413"></a>00413         n = 63;
<a name="l00414"></a>00414         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_alt_flatworm_mito[] = {11, 11, 8, 11, 16, 16, 16, 16, 15, 15, 15, 15, 7, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 19, 19, 15, 15, 15, 15, 18, 1, 18, 1, 9, 4, 9, 4};
<a name="l00415"></a>00415         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_alt_flatworm_mito[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAA&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGA&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00416"></a>00416         std::copy(ccitacnxs_gcode_alt_flatworm_mito, ccitacnxs_gcode_alt_flatworm_mito + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00417"></a>00417         std::copy(caaindnxs_gcode_alt_flatworm_mito, caaindnxs_gcode_alt_flatworm_mito + n, back_inserter(c.aaInd));
<a name="l00418"></a>00418         std::copy(ccodstrnxs_gcode_alt_flatworm_mito, ccodstrnxs_gcode_alt_flatworm_mito + n, back_inserter(c.codonStrings));
<a name="l00419"></a>00419         <span class="keywordflow">return</span> c;
<a name="l00420"></a>00420     }
<a name="l00421"></a>00421     <span class="keywordflow">if</span>(gCode == NXS_GCODE_BLEPHARISMA_MACRO) {
<a name="l00422"></a>00422         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_blepharisma_macro[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 63};
<a name="l00423"></a>00423         n = 62;
<a name="l00424"></a>00424         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_blepharisma_macro[] = {8, 11, 8, 11, 16, 16, 16, 16, 14, 15, 14, 15, 7, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 13, 19, 15, 15, 15, 15, 1, 18, 1, 9, 4, 9, 4};
<a name="l00425"></a>00425         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_blepharisma_macro[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAG&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00426"></a>00426         std::copy(ccitacnxs_gcode_blepharisma_macro, ccitacnxs_gcode_blepharisma_macro + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00427"></a>00427         std::copy(caaindnxs_gcode_blepharisma_macro, caaindnxs_gcode_blepharisma_macro + n, back_inserter(c.aaInd));
<a name="l00428"></a>00428         std::copy(ccodstrnxs_gcode_blepharisma_macro, ccodstrnxs_gcode_blepharisma_macro + n, back_inserter(c.codonStrings));
<a name="l00429"></a>00429         <span class="keywordflow">return</span> c;
<a name="l00430"></a>00430     }
<a name="l00431"></a>00431     <span class="keywordflow">if</span>(gCode == NXS_GCODE_CHLOROPHYCEAN_MITO) {
<a name="l00432"></a>00432         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_chlorophycean_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 63};
<a name="l00433"></a>00433         n = 62;
<a name="l00434"></a>00434         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_chlorophycean_mito[] = {8, 11, 8, 11, 16, 16, 16, 16, 14, 15, 14, 15, 7, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 9, 19, 15, 15, 15, 15, 1, 18, 1, 9, 4, 9, 4};
<a name="l00435"></a>00435         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_chlorophycean_mito[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAG&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00436"></a>00436         std::copy(ccitacnxs_gcode_chlorophycean_mito, ccitacnxs_gcode_chlorophycean_mito + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00437"></a>00437         std::copy(caaindnxs_gcode_chlorophycean_mito, caaindnxs_gcode_chlorophycean_mito + n, back_inserter(c.aaInd));
<a name="l00438"></a>00438         std::copy(ccodstrnxs_gcode_chlorophycean_mito, ccodstrnxs_gcode_chlorophycean_mito + n, back_inserter(c.codonStrings));
<a name="l00439"></a>00439         <span class="keywordflow">return</span> c;
<a name="l00440"></a>00440     }
<a name="l00441"></a>00441     <span class="keywordflow">if</span>(gCode == NXS_GCODE_TREMATODE_MITO) {
<a name="l00442"></a>00442         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_trematode_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63};
<a name="l00443"></a>00443         n = 62;
<a name="l00444"></a>00444         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_trematode_mito[] = {11, 11, 8, 11, 16, 16, 16, 16, 15, 15, 15, 15, 10, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 19, 15, 15, 15, 15, 18, 1, 18, 1, 9, 4, 9, 4};
<a name="l00445"></a>00445         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_trematode_mito[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGA&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00446"></a>00446         std::copy(ccitacnxs_gcode_trematode_mito, ccitacnxs_gcode_trematode_mito + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00447"></a>00447         std::copy(caaindnxs_gcode_trematode_mito, caaindnxs_gcode_trematode_mito + n, back_inserter(c.aaInd));
<a name="l00448"></a>00448         std::copy(ccodstrnxs_gcode_trematode_mito, ccodstrnxs_gcode_trematode_mito + n, back_inserter(c.codonStrings));
<a name="l00449"></a>00449         <span class="keywordflow">return</span> c;
<a name="l00450"></a>00450     }
<a name="l00451"></a>00451     <span class="keywordflow">if</span>(gCode == NXS_GCODE_SCENEDESMUS_MITO) {
<a name="l00452"></a>00452         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_scenedesmus_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 50, 51, 53, 54, 55, 57, 58, 59, 60, 61, 62, 63};
<a name="l00453"></a>00453         n = 61;
<a name="l00454"></a>00454         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_scenedesmus_mito[] = {8, 11, 8, 11, 16, 16, 16, 16, 14, 15, 14, 15, 7, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 9, 19, 15, 15, 15, 1, 18, 1, 9, 4, 9, 4};
<a name="l00455"></a>00455         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_scenedesmus_mito[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAG&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTA&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00456"></a>00456         std::copy(ccitacnxs_gcode_scenedesmus_mito, ccitacnxs_gcode_scenedesmus_mito + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00457"></a>00457         std::copy(caaindnxs_gcode_scenedesmus_mito, caaindnxs_gcode_scenedesmus_mito + n, back_inserter(c.aaInd));
<a name="l00458"></a>00458         std::copy(ccodstrnxs_gcode_scenedesmus_mito, ccodstrnxs_gcode_scenedesmus_mito + n, back_inserter(c.codonStrings));
<a name="l00459"></a>00459         <span class="keywordflow">return</span> c;
<a name="l00460"></a>00460     }
<a name="l00461"></a>00461     <span class="keywordflow">if</span>(gCode == NXS_GCODE_THRAUSTOCHYTRIUM_MITO) {
<a name="l00462"></a>00462         <span class="keyword">const</span> <span class="keywordtype">int</span> ccitacnxs_gcode_thraustochytrium_mito[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 57, 58, 59, 61, 62, 63};
<a name="l00463"></a>00463         n = 60;
<a name="l00464"></a>00464         <span class="keyword">const</span> <span class="keywordtype">int</span> caaindnxs_gcode_thraustochytrium_mito[] = {8, 11, 8, 11, 16, 16, 16, 16, 14, 15, 14, 15, 7, 7, 10, 7, 13, 6, 13, 6, 12, 12, 12, 12, 14, 14, 14, 14, 9, 9, 9, 9, 3, 2, 3, 2, 0, 0, 0, 0, 5, 5, 5, 5, 17, 17, 17, 17, 19, 19, 15, 15, 15, 15, 1, 18, 1, 4, 9, 4};
<a name="l00465"></a>00465         <span class="keyword">const</span> <span class="keywordtype">char</span> * ccodstrnxs_gcode_thraustochytrium_mito[] = {<span class="stringliteral">&quot;AAA&quot;</span>, <span class="stringliteral">&quot;AAC&quot;</span>, <span class="stringliteral">&quot;AAG&quot;</span>, <span class="stringliteral">&quot;AAT&quot;</span>, <span class="stringliteral">&quot;ACA&quot;</span>, <span class="stringliteral">&quot;ACC&quot;</span>, <span class="stringliteral">&quot;ACG&quot;</span>, <span class="stringliteral">&quot;ACT&quot;</span>, <span class="stringliteral">&quot;AGA&quot;</span>, <span class="stringliteral">&quot;AGC&quot;</span>, <span class="stringliteral">&quot;AGG&quot;</span>, <span class="stringliteral">&quot;AGT&quot;</span>, <span class="stringliteral">&quot;ATA&quot;</span>, <span class="stringliteral">&quot;ATC&quot;</span>, <span class="stringliteral">&quot;ATG&quot;</span>, <span class="stringliteral">&quot;ATT&quot;</span>, <span class="stringliteral">&quot;CAA&quot;</span>, <span class="stringliteral">&quot;CAC&quot;</span>, <span class="stringliteral">&quot;CAG&quot;</span>, <span class="stringliteral">&quot;CAT&quot;</span>, <span class="stringliteral">&quot;CCA&quot;</span>, <span class="stringliteral">&quot;CCC&quot;</span>, <span class="stringliteral">&quot;CCG&quot;</span>, <span class="stringliteral">&quot;CCT&quot;</span>, <span class="stringliteral">&quot;CGA&quot;</span>, <span class="stringliteral">&quot;CGC&quot;</span>, <span class="stringliteral">&quot;CGG&quot;</span>, <span class="stringliteral">&quot;CGT&quot;</span>, <span class="stringliteral">&quot;CTA&quot;</span>, <span class="stringliteral">&quot;CTC&quot;</span>, <span class="stringliteral">&quot;CTG&quot;</span>, <span class="stringliteral">&quot;CTT&quot;</span>, <span class="stringliteral">&quot;GAA&quot;</span>, <span class="stringliteral">&quot;GAC&quot;</span>, <span class="stringliteral">&quot;GAG&quot;</span>, <span class="stringliteral">&quot;GAT&quot;</span>, <span class="stringliteral">&quot;GCA&quot;</span>, <span class="stringliteral">&quot;GCC&quot;</span>, <span class="stringliteral">&quot;GCG&quot;</span>, <span class="stringliteral">&quot;GCT&quot;</span>, <span class="stringliteral">&quot;GGA&quot;</span>, <span class="stringliteral">&quot;GGC&quot;</span>, <span class="stringliteral">&quot;GGG&quot;</span>, <span class="stringliteral">&quot;GGT&quot;</span>, <span class="stringliteral">&quot;GTA&quot;</span>, <span class="stringliteral">&quot;GTC&quot;</span>, <span class="stringliteral">&quot;GTG&quot;</span>, <span class="stringliteral">&quot;GTT&quot;</span>, <span class="stringliteral">&quot;TAC&quot;</span>, <span class="stringliteral">&quot;TAT&quot;</span>, <span class="stringliteral">&quot;TCA&quot;</span>, <span class="stringliteral">&quot;TCC&quot;</span>, <span class="stringliteral">&quot;TCG&quot;</span>, <span class="stringliteral">&quot;TCT&quot;</span>, <span class="stringliteral">&quot;TGC&quot;</span>, <span class="stringliteral">&quot;TGG&quot;</span>, <span class="stringliteral">&quot;TGT&quot;</span>, <span class="stringliteral">&quot;TTC&quot;</span>, <span class="stringliteral">&quot;TTG&quot;</span>, <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l00466"></a>00466         std::copy(ccitacnxs_gcode_thraustochytrium_mito, ccitacnxs_gcode_thraustochytrium_mito + n, back_inserter(c.compressedCodonIndToAllCodonsInd));
<a name="l00467"></a>00467         std::copy(caaindnxs_gcode_thraustochytrium_mito, caaindnxs_gcode_thraustochytrium_mito + n, back_inserter(c.aaInd));
<a name="l00468"></a>00468         std::copy(ccodstrnxs_gcode_thraustochytrium_mito, ccodstrnxs_gcode_thraustochytrium_mito + n, back_inserter(c.codonStrings));
<a name="l00469"></a>00469         <span class="keywordflow">return</span> c;
<a name="l00470"></a>00470     }
<a name="l00471"></a>00471     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Unrecognized genetic code.&quot;</span>);
<a name="l00472"></a>00472 }
<a name="l00473"></a>00473 
<a name="l00474"></a>00474 CodonRecodingStruct NxsCharactersBlock::RemoveStopCodons(NxsGeneticCodesEnum gCode)
<a name="l00475"></a>00475 {
<a name="l00476"></a>00476     <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * mapper = this-&gt;GetMutableDatatypeMapperForChar(0);
<a name="l00477"></a>00477     <span class="keywordflow">if</span> (mapper == 0L)
<a name="l00478"></a>00478         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Invalid characters block (no datatype mapper)&quot;</span>);
<a name="l00479"></a>00479     <span class="keywordflow">if</span> (mapper-&gt;GetDatatype() != <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa11d7fb339c6f83517338e0e6faac722" title="indicates `matrix&amp;#39; holds amino acid sequences">codon</a>)
<a name="l00480"></a>00480         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Characters block must be of the type codons when RemoveStopCodons is called&quot;</span>);
<a name="l00481"></a>00481     <span class="keywordflow">if</span> (mapper-&gt;geneticCode != NXS_GCODE_NO_CODE)
<a name="l00482"></a>00482         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Characters block must be an uncompressed codons type when RemoveStopCodons is called&quot;</span>);
<a name="l00483"></a>00483 
<a name="l00484"></a>00484     <span class="keyword">const</span> std::vector&lt;NxsDiscreteStateCell&gt; v = getToCodonRecodingMapper(gCode);
<a name="l00485"></a>00485     CodonRecodingStruct c = getCodonRecodingStruct(gCode);
<a name="l00486"></a>00486     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nRS = c.compressedCodonIndToAllCodonsInd.size();
<a name="l00487"></a>00487     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> offset = 64 - nRS;
<a name="l00488"></a>00488     NxsDiscreteStateMatrix  dMat(this-&gt;discreteMatrix);
<a name="l00489"></a>00489     <span class="keywordtype">unsigned</span> rowInd = 0;
<a name="l00490"></a>00490     <span class="keywordflow">for</span> (NxsDiscreteStateMatrix::iterator rowIt = dMat.begin(); rowIt != dMat.end(); ++rowIt)
<a name="l00491"></a>00491         {
<a name="l00492"></a>00492         NxsDiscreteStateRow &amp; row = *rowIt;
<a name="l00493"></a>00493         <span class="keywordtype">unsigned</span> charInd = 0;
<a name="l00494"></a>00494         <span class="keywordflow">for</span> (NxsDiscreteStateRow::iterator cellIt = row.begin(); cellIt != row.end(); ++cellIt)
<a name="l00495"></a>00495             {
<a name="l00496"></a>00496             <span class="keyword">const</span> NxsDiscreteStateCell cell = *cellIt;
<a name="l00497"></a>00497             <span class="keywordflow">if</span> (cell &gt;= 64)
<a name="l00498"></a>00498                 *cellIt = cell - offset;
<a name="l00499"></a>00499             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell &gt;= 0)
<a name="l00500"></a>00500                 {
<a name="l00501"></a>00501                 <span class="keyword">const</span> NxsDiscreteStateCell recoded = v[cell];
<a name="l00502"></a>00502                 <span class="keywordflow">if</span> (recoded &lt; 0)
<a name="l00503"></a>00503                     {
<a name="l00504"></a>00504                     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> m;
<a name="l00505"></a>00505                     m &lt;&lt; <span class="stringliteral">&quot;Stop codon found at character &quot;</span>;
<a name="l00506"></a>00506                     m &lt;&lt; charInd + 1;
<a name="l00507"></a>00507                     m &lt;&lt; <span class="stringliteral">&quot; for taxon &quot;</span>;
<a name="l00508"></a>00508                     m &lt;&lt; rowInd + 1;
<a name="l00509"></a>00509                     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(m);
<a name="l00510"></a>00510                     }
<a name="l00511"></a>00511                 *cellIt = recoded;
<a name="l00512"></a>00512                 }
<a name="l00513"></a>00513             ++charInd;
<a name="l00514"></a>00514             }
<a name="l00515"></a>00515         ++rowInd;
<a name="l00516"></a>00516         }
<a name="l00517"></a>00517     dMat.swap(this-&gt;discreteMatrix);
<a name="l00518"></a>00518     std::set&lt;NxsDiscreteStateCell&gt; deletedInds;
<a name="l00519"></a>00519     <span class="keywordflow">for</span> (NxsDiscreteStateCell i = 0; i &lt; 64; ++i)
<a name="l00520"></a>00520         {
<a name="l00521"></a>00521         <span class="keywordflow">if</span> (v[(<span class="keywordtype">int</span>)i] &lt; 0)
<a name="l00522"></a>00522             deletedInds.insert(i);
<a name="l00523"></a>00523         }
<a name="l00524"></a>00524     mapper-&gt;DeleteStateIndices(deletedInds);
<a name="l00525"></a>00525     <span class="keywordflow">return</span> c;
<a name="l00526"></a>00526 }
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 <span class="keywordtype">unsigned</span> NxsCharactersBlock::NumAmbigInTaxon(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> taxInd, <span class="keyword">const</span> NxsUnsignedSet * charIndices, <span class="keyword">const</span> <span class="keywordtype">bool</span> countOnlyCompletelyMissing, <span class="keyword">const</span> <span class="keywordtype">bool</span> treatGapsAsMissing)<span class="keyword"> const</span>
<a name="l00529"></a>00529 <span class="keyword"></span>{
<a name="l00530"></a>00530     <span class="keyword">const</span> NxsDiscreteStateRow &amp; row = <a class="code" href="classNxsCharactersBlock_a2840b32dd8053a925a9c777911f6b659.html#a2840b32dd8053a925a9c777911f6b659">GetDiscreteMatrixRow</a>(taxInd);
<a name="l00531"></a>00531     <span class="keywordtype">unsigned</span> nAmbig = 0;
<a name="l00532"></a>00532     <span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * m;
<a name="l00533"></a>00533     <span class="keywordflow">if</span> (charIndices == NULL)
<a name="l00534"></a>00534         {
<a name="l00535"></a>00535         <span class="keywordtype">unsigned</span> cInd = 0;
<a name="l00536"></a>00536         <span class="keywordflow">for</span> (NxsDiscreteStateRow::const_iterator cellIt = row.begin(); cellIt != row.end(); ++cellIt)
<a name="l00537"></a>00537             {
<a name="l00538"></a>00538             m = GetDatatypeMapperForChar(cInd++);
<a name="l00539"></a>00539             NCL_ASSERT(m);
<a name="l00540"></a>00540             <span class="keyword">const</span> NxsDiscreteStateCell &amp; c = *cellIt;
<a name="l00541"></a>00541             <span class="keywordflow">if</span> (c &lt; 0 || c &gt;= (NxsDiscreteStateCell) m-&gt;GetNumStates())
<a name="l00542"></a>00542                 {
<a name="l00543"></a>00543                 <span class="keywordflow">if</span> (countOnlyCompletelyMissing)
<a name="l00544"></a>00544                     {
<a name="l00545"></a>00545                     <span class="keywordflow">if</span> (c == NXS_MISSING_CODE)
<a name="l00546"></a>00546                         nAmbig++;
<a name="l00547"></a>00547                     }
<a name="l00548"></a>00548                 <span class="keywordflow">else</span>
<a name="l00549"></a>00549                     {
<a name="l00550"></a>00550                     <span class="keywordflow">if</span> (c != NXS_GAP_STATE_CODE || treatGapsAsMissing)
<a name="l00551"></a>00551                         nAmbig++;
<a name="l00552"></a>00552                     }
<a name="l00553"></a>00553                 }
<a name="l00554"></a>00554             }
<a name="l00555"></a>00555         }
<a name="l00556"></a>00556     <span class="keywordflow">else</span>
<a name="l00557"></a>00557         {
<a name="l00558"></a>00558         <span class="keywordflow">for</span> (NxsUnsignedSet::const_iterator c = charIndices-&gt;begin(); c != charIndices-&gt;end(); ++c)
<a name="l00559"></a>00559             {
<a name="l00560"></a>00560             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> cIndex = *c;
<a name="l00561"></a>00561             m = GetDatatypeMapperForChar(cIndex);
<a name="l00562"></a>00562             <span class="keyword">const</span> NxsDiscreteStateCell &amp; sc = row.at(cIndex);
<a name="l00563"></a>00563             <span class="keywordflow">if</span> (sc &lt; 0 || sc &gt;= (NxsDiscreteStateCell) m-&gt;GetNumStates())
<a name="l00564"></a>00564                 {
<a name="l00565"></a>00565                 <span class="keywordflow">if</span> (countOnlyCompletelyMissing)
<a name="l00566"></a>00566                     {
<a name="l00567"></a>00567                     <span class="keywordflow">if</span> (sc == NXS_MISSING_CODE)
<a name="l00568"></a>00568                         nAmbig++;
<a name="l00569"></a>00569                     }
<a name="l00570"></a>00570                 <span class="keywordflow">else</span>
<a name="l00571"></a>00571                     {
<a name="l00572"></a>00572                     <span class="keywordflow">if</span> (sc != NXS_GAP_STATE_CODE || treatGapsAsMissing)
<a name="l00573"></a>00573                         nAmbig++;
<a name="l00574"></a>00574                     }
<a name="l00575"></a>00575                 }
<a name="l00576"></a>00576             }
<a name="l00577"></a>00577         }
<a name="l00578"></a>00578     <span class="keywordflow">return</span> nAmbig;
<a name="l00579"></a>00579 }
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 <span class="keywordtype">bool</span> NxsCharactersBlock::FirstTaxonStatesAreSubsetOfSecond(
<a name="l00582"></a>00582   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> firstTaxonInd,
<a name="l00583"></a>00583   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> secondTaxonInd,
<a name="l00584"></a>00584   <span class="keyword">const</span> NxsUnsignedSet * charIndices,
<a name="l00585"></a>00585   <span class="keyword">const</span> <span class="keywordtype">bool</span> treatAmbigAsMissing,
<a name="l00586"></a>00586   <span class="keyword">const</span> <span class="keywordtype">bool</span> treatGapAsMissing)<span class="keyword"> const</span>
<a name="l00587"></a>00587 <span class="keyword"></span>{
<a name="l00588"></a>00588     <span class="keyword">const</span> NxsDiscreteStateRow &amp; firstRow = <a class="code" href="classNxsCharactersBlock_a2840b32dd8053a925a9c777911f6b659.html#a2840b32dd8053a925a9c777911f6b659">GetDiscreteMatrixRow</a>(firstTaxonInd);
<a name="l00589"></a>00589     <span class="keyword">const</span> NxsDiscreteStateRow &amp; secondRow = <a class="code" href="classNxsCharactersBlock_a2840b32dd8053a925a9c777911f6b659.html#a2840b32dd8053a925a9c777911f6b659">GetDiscreteMatrixRow</a>(secondTaxonInd);
<a name="l00590"></a>00590     <span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * m;
<a name="l00591"></a>00591     <span class="keywordflow">if</span> (charIndices == NULL)
<a name="l00592"></a>00592         {
<a name="l00593"></a>00593         <span class="keywordtype">unsigned</span> cInd = 0;
<a name="l00594"></a>00594         NxsDiscreteStateRow::const_iterator firstIt = firstRow.begin();
<a name="l00595"></a>00595         NxsDiscreteStateRow::const_iterator secondIt = secondRow.begin();
<a name="l00596"></a>00596         <span class="keywordflow">for</span> (; firstIt != firstRow.end(); ++firstIt, ++secondIt)
<a name="l00597"></a>00597             {
<a name="l00598"></a>00598             m = GetDatatypeMapperForChar(cInd++);
<a name="l00599"></a>00599             <span class="keyword">const</span> NxsDiscreteStateCell ns = (NxsDiscreteStateCell) m-&gt;GetNumStates();
<a name="l00600"></a>00600             NxsDiscreteStateCell f = *firstIt;
<a name="l00601"></a>00601             NxsDiscreteStateCell s = *secondIt;
<a name="l00602"></a>00602             <span class="keywordflow">if</span> (treatAmbigAsMissing)
<a name="l00603"></a>00603                 {
<a name="l00604"></a>00604                 <span class="keywordflow">if</span> (f &gt;= ns)
<a name="l00605"></a>00605                     f = NXS_MISSING_CODE;
<a name="l00606"></a>00606                 <span class="keywordflow">if</span> (s &gt;= ns)
<a name="l00607"></a>00607                     s = NXS_MISSING_CODE;
<a name="l00608"></a>00608                 }
<a name="l00609"></a>00609             <span class="keywordflow">if</span> (!m-&gt;FirstIsSubset(f, s, treatGapAsMissing))
<a name="l00610"></a>00610                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00611"></a>00611             }
<a name="l00612"></a>00612         }
<a name="l00613"></a>00613     <span class="keywordflow">else</span>
<a name="l00614"></a>00614         {
<a name="l00615"></a>00615         <span class="keywordflow">for</span> (NxsUnsignedSet::const_iterator c = charIndices-&gt;begin(); c != charIndices-&gt;end(); ++c)
<a name="l00616"></a>00616             {
<a name="l00617"></a>00617             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> cIndex = *c;
<a name="l00618"></a>00618             m = GetDatatypeMapperForChar(cIndex);
<a name="l00619"></a>00619             <span class="keyword">const</span> NxsDiscreteStateCell ns = m-&gt;GetNumStates();
<a name="l00620"></a>00620             NxsDiscreteStateCell f = firstRow.at(cIndex);
<a name="l00621"></a>00621             NxsDiscreteStateCell s = secondRow.at(cIndex);
<a name="l00622"></a>00622             <span class="keywordflow">if</span> (treatAmbigAsMissing)
<a name="l00623"></a>00623                 {
<a name="l00624"></a>00624                 <span class="keywordflow">if</span> (f &gt;= ns)
<a name="l00625"></a>00625                     f = NXS_MISSING_CODE;
<a name="l00626"></a>00626                 <span class="keywordflow">if</span> (s &gt;= ns)
<a name="l00627"></a>00627                     s = NXS_MISSING_CODE;
<a name="l00628"></a>00628                 }
<a name="l00629"></a>00629             <span class="keywordflow">if</span> (!m-&gt;FirstIsSubset(f, s, treatGapAsMissing))
<a name="l00630"></a>00630                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00631"></a>00631             }
<a name="l00632"></a>00632         }
<a name="l00633"></a>00633     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00634"></a>00634 }
<a name="l00635"></a>00635 
<a name="l00636"></a>00636 std::pair&lt;unsigned, unsigned&gt; NxsCharactersBlock::GetPairwiseDist(
<a name="l00637"></a>00637   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> firstTaxonInd,
<a name="l00638"></a>00638   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> secondTaxonInd,
<a name="l00639"></a>00639   <span class="keyword">const</span> NxsUnsignedSet * charIndices,
<a name="l00640"></a>00640   <span class="keyword">const</span> <span class="keywordtype">bool</span> treatAmbigAsMissing,
<a name="l00641"></a>00641   <span class="keyword">const</span> <span class="keywordtype">bool</span> treatGapAsMissing)<span class="keyword"> const</span>
<a name="l00642"></a>00642 <span class="keyword"></span>{
<a name="l00643"></a>00643     <span class="keyword">const</span> NxsDiscreteStateRow &amp; firstRow = <a class="code" href="classNxsCharactersBlock_a2840b32dd8053a925a9c777911f6b659.html#a2840b32dd8053a925a9c777911f6b659">GetDiscreteMatrixRow</a>(firstTaxonInd);
<a name="l00644"></a>00644     <span class="keyword">const</span> NxsDiscreteStateRow &amp; secondRow = <a class="code" href="classNxsCharactersBlock_a2840b32dd8053a925a9c777911f6b659.html#a2840b32dd8053a925a9c777911f6b659">GetDiscreteMatrixRow</a>(secondTaxonInd);
<a name="l00645"></a>00645     <span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * m;
<a name="l00646"></a>00646     <span class="keywordtype">unsigned</span> nDiffs = 0;
<a name="l00647"></a>00647     <span class="keywordtype">unsigned</span> nSites = 0;
<a name="l00648"></a>00648     <span class="keywordflow">if</span> (charIndices == NULL)
<a name="l00649"></a>00649         {
<a name="l00650"></a>00650         <span class="keywordtype">unsigned</span> cInd = 0;
<a name="l00651"></a>00651         NxsDiscreteStateRow::const_iterator firstIt = firstRow.begin();
<a name="l00652"></a>00652         NxsDiscreteStateRow::const_iterator secondIt = secondRow.begin();
<a name="l00653"></a>00653         <span class="keywordflow">for</span> (; firstIt != firstRow.end(); ++firstIt, ++secondIt)
<a name="l00654"></a>00654             {
<a name="l00655"></a>00655             m = GetDatatypeMapperForChar(cInd++);
<a name="l00656"></a>00656             <span class="keyword">const</span> NxsDiscreteStateCell ns = m-&gt;GetNumStates();
<a name="l00657"></a>00657             NxsDiscreteStateCell f = *firstIt;
<a name="l00658"></a>00658             NxsDiscreteStateCell s = *secondIt;
<a name="l00659"></a>00659             <span class="keywordflow">if</span> (treatAmbigAsMissing)
<a name="l00660"></a>00660                 {
<a name="l00661"></a>00661                 <span class="keywordflow">if</span> (f &gt;= ns)
<a name="l00662"></a>00662                     f = NXS_MISSING_CODE;
<a name="l00663"></a>00663                 <span class="keywordflow">if</span> (s &gt;= ns)
<a name="l00664"></a>00664                     s = NXS_MISSING_CODE;
<a name="l00665"></a>00665                 }
<a name="l00666"></a>00666             <span class="keywordflow">if</span> (f &lt; 0 || s &lt; 0)
<a name="l00667"></a>00667                 {
<a name="l00668"></a>00668                 <span class="keywordflow">if</span> (treatGapAsMissing &amp;&amp; (f == NXS_GAP_STATE_CODE || s == NXS_GAP_STATE_CODE))
<a name="l00669"></a>00669                     <span class="keywordflow">continue</span>;
<a name="l00670"></a>00670                 <span class="keywordflow">if</span> (f == NXS_MISSING_CODE || s == NXS_MISSING_CODE)
<a name="l00671"></a>00671                     <span class="keywordflow">continue</span>;
<a name="l00672"></a>00672                 }
<a name="l00673"></a>00673             nSites++;
<a name="l00674"></a>00674             <span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt; &amp; ssim = m-&gt;GetStateIntersection(f, s);
<a name="l00675"></a>00675             <span class="keywordflow">if</span> (!ssim.empty())
<a name="l00676"></a>00676                 ++nDiffs;
<a name="l00677"></a>00677             }
<a name="l00678"></a>00678         }
<a name="l00679"></a>00679     <span class="keywordflow">else</span>
<a name="l00680"></a>00680         {
<a name="l00681"></a>00681         <span class="keywordflow">for</span> (NxsUnsignedSet::const_iterator c = charIndices-&gt;begin(); c != charIndices-&gt;end(); ++c)
<a name="l00682"></a>00682             {
<a name="l00683"></a>00683             m = GetDatatypeMapperForChar(*c);
<a name="l00684"></a>00684             <span class="keyword">const</span> NxsDiscreteStateCell ns = (NxsDiscreteStateCell) m-&gt;GetNumStates();
<a name="l00685"></a>00685             NxsDiscreteStateCell f = firstRow.at(*c);
<a name="l00686"></a>00686             NxsDiscreteStateCell s = secondRow.at(*c);
<a name="l00687"></a>00687             <span class="keywordflow">if</span> (treatAmbigAsMissing)
<a name="l00688"></a>00688                 {
<a name="l00689"></a>00689                 <span class="keywordflow">if</span> (f &gt;= ns)
<a name="l00690"></a>00690                     f = NXS_MISSING_CODE;
<a name="l00691"></a>00691                 <span class="keywordflow">if</span> (s &gt;= ns)
<a name="l00692"></a>00692                     s = NXS_MISSING_CODE;
<a name="l00693"></a>00693                 }
<a name="l00694"></a>00694             <span class="keywordflow">if</span> (f &lt; 0 || s &lt; 0)
<a name="l00695"></a>00695                 {
<a name="l00696"></a>00696                 <span class="keywordflow">if</span> (treatGapAsMissing &amp;&amp; (f == NXS_GAP_STATE_CODE || s == NXS_GAP_STATE_CODE))
<a name="l00697"></a>00697                     <span class="keywordflow">continue</span>;
<a name="l00698"></a>00698                 <span class="keywordflow">if</span> (f == NXS_MISSING_CODE || s == NXS_MISSING_CODE)
<a name="l00699"></a>00699                     <span class="keywordflow">continue</span>;
<a name="l00700"></a>00700                 }
<a name="l00701"></a>00701             nSites++;
<a name="l00702"></a>00702             <span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt; &amp; ssi = m-&gt;GetStateIntersection(f, s);
<a name="l00703"></a>00703             <span class="keywordflow">if</span> (!ssi.empty())
<a name="l00704"></a>00704                 ++nDiffs;
<a name="l00705"></a>00705             }
<a name="l00706"></a>00706         }
<a name="l00707"></a>00707     <span class="keywordflow">return</span> std::pair&lt;unsigned, unsigned&gt;(nDiffs, nSites);
<a name="l00708"></a>00708 }
<a name="l00709"></a>00709 
<a name="l00710"></a>00710 
<a name="l00711"></a>00711 <span class="keywordtype">void</span> NxsDiscreteDatatypeMapper::BuildStateSubsetMatrix()<span class="keyword"> const</span>
<a name="l00712"></a>00712 <span class="keyword"></span>{
<a name="l00713"></a>00713     <span class="keywordflow">if</span> (stateIntersectionMatrix.empty())
<a name="l00714"></a>00714         BuildStateIntersectionMatrix();
<a name="l00715"></a>00715     isStateSubsetMatrix.clear();
<a name="l00716"></a>00716     isStateSubsetMatrixGapsMissing.clear();
<a name="l00717"></a>00717     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nsPlus = stateSetsVec.size();
<a name="l00718"></a>00718     IsStateSubsetRow r(nsPlus, <span class="keyword">false</span>);
<a name="l00719"></a>00719     isStateSubsetMatrix.assign(nsPlus, r);
<a name="l00720"></a>00720     isStateSubsetMatrixGapsMissing.assign(nsPlus, r);
<a name="l00721"></a>00721     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; nsPlus; ++i)
<a name="l00722"></a>00722         {
<a name="l00723"></a>00723         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; nsPlus; ++j)
<a name="l00724"></a>00724             {
<a name="l00725"></a>00725             <span class="keywordflow">if</span> (!stateIntersectionMatrix[i][j].empty())
<a name="l00726"></a>00726                 {
<a name="l00727"></a>00727                 isStateSubsetMatrix[i][j] = <span class="keyword">true</span>;
<a name="l00728"></a>00728                 isStateSubsetMatrixGapsMissing[i][j] = <span class="keyword">true</span>;
<a name="l00729"></a>00729                 }
<a name="l00730"></a>00730             }
<a name="l00731"></a>00731         }
<a name="l00732"></a>00732     isStateSubsetMatrixGapsMissing[0][1] = <span class="keyword">true</span>;
<a name="l00733"></a>00733     isStateSubsetMatrixGapsMissing[1][0] = <span class="keyword">true</span>;
<a name="l00734"></a>00734 }
<a name="l00735"></a>00735 
<a name="l00736"></a>00736 <span class="keywordtype">void</span> NxsDiscreteDatatypeMapper::BuildStateIntersectionMatrix()<span class="keyword"> const</span>
<a name="l00737"></a>00737 <span class="keyword"></span>{
<a name="l00738"></a>00738     <span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt; emptySet;
<a name="l00739"></a>00739 
<a name="l00740"></a>00740     stateIntersectionMatrix.clear();
<a name="l00741"></a>00741 
<a name="l00742"></a>00742     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nsPlus = stateSetsVec.size();
<a name="l00743"></a>00743     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> offset = (unsigned)(sclOffset + 2);
<a name="l00744"></a>00744     StateIntersectionRow emptyRow(nsPlus, emptySet);
<a name="l00745"></a>00745     stateIntersectionMatrix.assign(nsPlus, emptyRow);
<a name="l00746"></a>00746     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = offset; i &lt; nsPlus; ++i)
<a name="l00747"></a>00747         {
<a name="l00748"></a>00748         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = i; j &lt; nsPlus; ++j)
<a name="l00749"></a>00749             {
<a name="l00750"></a>00750             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> offi = i + sclOffset;
<a name="l00751"></a>00751             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> offj = j + sclOffset;
<a name="l00752"></a>00752             std::set&lt;NxsDiscreteStateCell&gt; intersect;
<a name="l00753"></a>00753             <span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt;    &amp;fs =  <a class="code" href="classNxsDiscreteDatatypeMapper_ad39cdce419be460c3a197dfa07a96c80.html#ad39cdce419be460c3a197dfa07a96c80" title="Returns the set of state indices that correspond to the states of state code `c`...">GetStateSetForCode</a>(offi);
<a name="l00754"></a>00754             <span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt;    &amp;ss =  <a class="code" href="classNxsDiscreteDatatypeMapper_ad39cdce419be460c3a197dfa07a96c80.html#ad39cdce419be460c3a197dfa07a96c80" title="Returns the set of state indices that correspond to the states of state code `c`...">GetStateSetForCode</a>(offj);
<a name="l00755"></a>00755             set_intersection(fs.begin(), fs.end(), ss.begin(), ss.end(), inserter(intersect, intersect.begin()));
<a name="l00756"></a>00756             stateIntersectionMatrix[i - NXS_GAP_STATE_CODE][j - NXS_GAP_STATE_CODE] = intersect;
<a name="l00757"></a>00757             <span class="keywordflow">if</span> (i != j)
<a name="l00758"></a>00758                 stateIntersectionMatrix[j - NXS_GAP_STATE_CODE][i - NXS_GAP_STATE_CODE] = stateIntersectionMatrix[i - NXS_GAP_STATE_CODE][j - NXS_GAP_STATE_CODE];
<a name="l00759"></a>00759             }
<a name="l00760"></a>00760         }
<a name="l00761"></a>00761 
<a name="l00762"></a>00762     std::set&lt;NxsDiscreteStateCell&gt; tmpSet;
<a name="l00763"></a>00763     NCL_ASSERT(1 == NXS_MISSING_CODE - NXS_GAP_STATE_CODE);
<a name="l00764"></a>00764     tmpSet.insert(NXS_GAP_STATE_CODE);
<a name="l00765"></a>00765     stateIntersectionMatrix[0][0] = tmpSet;
<a name="l00766"></a>00766 
<a name="l00767"></a>00767     tmpSet.clear();
<a name="l00768"></a>00768     tmpSet.insert(NXS_MISSING_CODE);
<a name="l00769"></a>00769     stateIntersectionMatrix[1][1] = tmpSet;
<a name="l00770"></a>00770     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = offset; i &lt; nsPlus; ++i)
<a name="l00771"></a>00771         {
<a name="l00772"></a>00772         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> offi = i + sclOffset;
<a name="l00773"></a>00773         stateIntersectionMatrix[1][i - NXS_GAP_STATE_CODE] = <a class="code" href="classNxsDiscreteDatatypeMapper_ad39cdce419be460c3a197dfa07a96c80.html#ad39cdce419be460c3a197dfa07a96c80" title="Returns the set of state indices that correspond to the states of state code `c`...">GetStateSetForCode</a>(offi);
<a name="l00774"></a>00774         }
<a name="l00775"></a>00775 }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 
<a name="l00778"></a>00778 NxsGeneticCodesEnum geneticCodeNameToEnum(std::string n)
<a name="l00779"></a>00779 {
<a name="l00780"></a>00780     <a class="code" href="classNxsString_a8a226fa743e246c3b2b65880deaa81db.html#a8a226fa743e246c3b2b65880deaa81db" title="Capitalizes every character in s.">NxsString::to_lower</a>(n);
<a name="l00781"></a>00781     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;standard&quot;</span>)
<a name="l00782"></a>00782         <span class="keywordflow">return</span> NXS_GCODE_STANDARD;
<a name="l00783"></a>00783     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;vertmito&quot;</span>)
<a name="l00784"></a>00784         <span class="keywordflow">return</span> NXS_GCODE_VERT_MITO;
<a name="l00785"></a>00785     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;yeastmito&quot;</span>)
<a name="l00786"></a>00786         <span class="keywordflow">return</span> NXS_GCODE_YEAST_MITO;
<a name="l00787"></a>00787     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;moldmito&quot;</span>)
<a name="l00788"></a>00788         <span class="keywordflow">return</span> NXS_GCODE_MOLD_MITO;
<a name="l00789"></a>00789     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;invertmito&quot;</span>)
<a name="l00790"></a>00790         <span class="keywordflow">return</span> NXS_GCODE_INVERT_MITO;
<a name="l00791"></a>00791     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;ciliate&quot;</span>)
<a name="l00792"></a>00792         <span class="keywordflow">return</span> NXS_GCODE_CILIATE;
<a name="l00793"></a>00793     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;echinomito&quot;</span>)
<a name="l00794"></a>00794         <span class="keywordflow">return</span> NXS_GCODE_ECHINO_MITO;
<a name="l00795"></a>00795     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;euplotid&quot;</span>)
<a name="l00796"></a>00796         <span class="keywordflow">return</span> NXS_GCODE_EUPLOTID;
<a name="l00797"></a>00797     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;plantplastid&quot;</span>)
<a name="l00798"></a>00798         <span class="keywordflow">return</span> NXS_GCODE_PLANT_PLASTID;
<a name="l00799"></a>00799     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;altyeast&quot;</span>)
<a name="l00800"></a>00800         <span class="keywordflow">return</span> NXS_GCODE_ALT_YEAST;
<a name="l00801"></a>00801     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;ascidianmito&quot;</span>)
<a name="l00802"></a>00802         <span class="keywordflow">return</span> NXS_GCODE_ASCIDIAN_MITO;
<a name="l00803"></a>00803     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;altflatwormmito&quot;</span>)
<a name="l00804"></a>00804         <span class="keywordflow">return</span> NXS_GCODE_ALT_FLATWORM_MITO;
<a name="l00805"></a>00805     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;blepharismamacro&quot;</span>)
<a name="l00806"></a>00806         <span class="keywordflow">return</span> NXS_GCODE_BLEPHARISMA_MACRO;
<a name="l00807"></a>00807     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;chlorophyceanmito&quot;</span>)
<a name="l00808"></a>00808         <span class="keywordflow">return</span> NXS_GCODE_CHLOROPHYCEAN_MITO;
<a name="l00809"></a>00809     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;trematodemito&quot;</span>)
<a name="l00810"></a>00810         <span class="keywordflow">return</span> NXS_GCODE_TREMATODE_MITO;
<a name="l00811"></a>00811     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;scenedesmusmito&quot;</span>)
<a name="l00812"></a>00812         <span class="keywordflow">return</span> NXS_GCODE_SCENEDESMUS_MITO;
<a name="l00813"></a>00813     <span class="keywordflow">if</span> (n == <span class="stringliteral">&quot;thraustochytriummito&quot;</span>)
<a name="l00814"></a>00814         <span class="keywordflow">return</span> NXS_GCODE_THRAUSTOCHYTRIUM_MITO;
<a name="l00815"></a>00815     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> err = <span class="stringliteral">&quot;Unrecognized genetic code name: &quot;</span>;
<a name="l00816"></a>00816     err &lt;&lt; n;
<a name="l00817"></a>00817     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(err);
<a name="l00818"></a>00818 }
<a name="l00819"></a>00819 
<a name="l00820"></a>00820 std::string geneticCodeEnumToName(NxsGeneticCodesEnum n)
<a name="l00821"></a>00821 {
<a name="l00822"></a>00822     <span class="keywordflow">if</span> (n == NXS_GCODE_STANDARD)
<a name="l00823"></a>00823         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Standard&quot;</span>;
<a name="l00824"></a>00824     <span class="keywordflow">if</span> (n == NXS_GCODE_VERT_MITO)
<a name="l00825"></a>00825         <span class="keywordflow">return</span> <span class="stringliteral">&quot;VertMito&quot;</span>;
<a name="l00826"></a>00826     <span class="keywordflow">if</span> (n == NXS_GCODE_YEAST_MITO)
<a name="l00827"></a>00827         <span class="keywordflow">return</span> <span class="stringliteral">&quot;YeastMito&quot;</span>;
<a name="l00828"></a>00828     <span class="keywordflow">if</span> (n == NXS_GCODE_MOLD_MITO)
<a name="l00829"></a>00829         <span class="keywordflow">return</span> <span class="stringliteral">&quot;MoldMito&quot;</span>;
<a name="l00830"></a>00830     <span class="keywordflow">if</span> (n == NXS_GCODE_INVERT_MITO)
<a name="l00831"></a>00831         <span class="keywordflow">return</span> <span class="stringliteral">&quot;InvertMito&quot;</span>;
<a name="l00832"></a>00832     <span class="keywordflow">if</span> (n == NXS_GCODE_CILIATE)
<a name="l00833"></a>00833         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Ciliate&quot;</span>;
<a name="l00834"></a>00834     <span class="keywordflow">if</span> (n == NXS_GCODE_ECHINO_MITO)
<a name="l00835"></a>00835         <span class="keywordflow">return</span> <span class="stringliteral">&quot;EchinoMito&quot;</span>;
<a name="l00836"></a>00836     <span class="keywordflow">if</span> (n == NXS_GCODE_EUPLOTID)
<a name="l00837"></a>00837         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Euplotid&quot;</span>;
<a name="l00838"></a>00838     <span class="keywordflow">if</span> (n == NXS_GCODE_PLANT_PLASTID)
<a name="l00839"></a>00839         <span class="keywordflow">return</span> <span class="stringliteral">&quot;PlantPlastid&quot;</span>;
<a name="l00840"></a>00840     <span class="keywordflow">if</span> (n == NXS_GCODE_ALT_YEAST)
<a name="l00841"></a>00841         <span class="keywordflow">return</span> <span class="stringliteral">&quot;AltYeast&quot;</span>;
<a name="l00842"></a>00842     <span class="keywordflow">if</span> (n == NXS_GCODE_ASCIDIAN_MITO)
<a name="l00843"></a>00843         <span class="keywordflow">return</span> <span class="stringliteral">&quot;AscidianMito&quot;</span>;
<a name="l00844"></a>00844     <span class="keywordflow">if</span> (n == NXS_GCODE_ALT_FLATWORM_MITO)
<a name="l00845"></a>00845         <span class="keywordflow">return</span> <span class="stringliteral">&quot;AltFlatwormMito&quot;</span>;
<a name="l00846"></a>00846     <span class="keywordflow">if</span> (n == NXS_GCODE_BLEPHARISMA_MACRO)
<a name="l00847"></a>00847         <span class="keywordflow">return</span> <span class="stringliteral">&quot;BlepharismaMacro&quot;</span>;
<a name="l00848"></a>00848     <span class="keywordflow">if</span> (n == NXS_GCODE_CHLOROPHYCEAN_MITO)
<a name="l00849"></a>00849         <span class="keywordflow">return</span> <span class="stringliteral">&quot;ChlorophyceanMito&quot;</span>;
<a name="l00850"></a>00850     <span class="keywordflow">if</span> (n == NXS_GCODE_TREMATODE_MITO)
<a name="l00851"></a>00851         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Trematodemito&quot;</span>;
<a name="l00852"></a>00852     <span class="keywordflow">if</span> (n == NXS_GCODE_SCENEDESMUS_MITO)
<a name="l00853"></a>00853         <span class="keywordflow">return</span> <span class="stringliteral">&quot;ScenedesmusMito&quot;</span>;
<a name="l00854"></a>00854     <span class="keywordflow">if</span> (n == NXS_GCODE_THRAUSTOCHYTRIUM_MITO)
<a name="l00855"></a>00855         <span class="keywordflow">return</span> <span class="stringliteral">&quot;ThraustochytriumMito&quot;</span>;
<a name="l00856"></a>00856     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> err = <span class="stringliteral">&quot;Unrecognized genetic code enumeration: &quot;</span>;
<a name="l00857"></a>00857     err &lt;&lt; n;
<a name="l00858"></a>00858     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(err);
<a name="l00859"></a>00859 }
<a name="l00860"></a>00860 
<a name="l00861"></a>00861 std::vector&lt;std::string&gt; getGeneticCodeNames()
<a name="l00862"></a>00862 {
<a name="l00863"></a>00863     std::vector&lt;std::string&gt; n(NXS_GCODE_CODE_ENUM_SIZE);
<a name="l00864"></a>00864     n[NXS_GCODE_STANDARD] = <span class="stringliteral">&quot;Standard&quot;</span> ;
<a name="l00865"></a>00865     n[NXS_GCODE_VERT_MITO] = <span class="stringliteral">&quot;VertMito&quot;</span> ;
<a name="l00866"></a>00866     n[NXS_GCODE_YEAST_MITO] = <span class="stringliteral">&quot;YeastMito&quot;</span> ;
<a name="l00867"></a>00867     n[NXS_GCODE_MOLD_MITO] = <span class="stringliteral">&quot;MoldMito&quot;</span> ;
<a name="l00868"></a>00868     n[NXS_GCODE_INVERT_MITO] = <span class="stringliteral">&quot;InvertMito&quot;</span> ;
<a name="l00869"></a>00869     n[NXS_GCODE_CILIATE] = <span class="stringliteral">&quot;Ciliate&quot;</span> ;
<a name="l00870"></a>00870     n[NXS_GCODE_ECHINO_MITO] = <span class="stringliteral">&quot;EchinoMito&quot;</span> ;
<a name="l00871"></a>00871     n[NXS_GCODE_EUPLOTID] = <span class="stringliteral">&quot;Euplotid&quot;</span> ;
<a name="l00872"></a>00872     n[NXS_GCODE_PLANT_PLASTID] = <span class="stringliteral">&quot;PlantPlastid&quot;</span> ;
<a name="l00873"></a>00873     n[NXS_GCODE_ALT_YEAST] = <span class="stringliteral">&quot;AltYeast&quot;</span> ;
<a name="l00874"></a>00874     n[NXS_GCODE_ASCIDIAN_MITO] = <span class="stringliteral">&quot;AscidianMito&quot;</span> ;
<a name="l00875"></a>00875     n[NXS_GCODE_ALT_FLATWORM_MITO] = <span class="stringliteral">&quot;AltFlatwormMito&quot;</span> ;
<a name="l00876"></a>00876     n[NXS_GCODE_BLEPHARISMA_MACRO] = <span class="stringliteral">&quot;BlepharismaMacro&quot;</span> ;
<a name="l00877"></a>00877     n[NXS_GCODE_CHLOROPHYCEAN_MITO] = <span class="stringliteral">&quot;ChlorophyceanMito&quot;</span> ;
<a name="l00878"></a>00878     n[NXS_GCODE_TREMATODE_MITO] = <span class="stringliteral">&quot;TrematodeMito&quot;</span> ;
<a name="l00879"></a>00879     n[NXS_GCODE_SCENEDESMUS_MITO] = <span class="stringliteral">&quot;ScenedesmusMito&quot;</span> ;
<a name="l00880"></a>00880     n[NXS_GCODE_THRAUSTOCHYTRIUM_MITO] = <span class="stringliteral">&quot;ThraustochytriumMito&quot;</span> ;
<a name="l00881"></a>00881     <span class="keywordflow">return</span> n;
<a name="l00882"></a>00882 }
<a name="l00883"></a>00883 
<a name="l00884"></a>00884 
<a name="l00885"></a>00885 
<a name="l00886"></a>00886 <span class="comment">/*</span>
<a name="l00887"></a>00887 <span class="comment">  code index 0 =&gt; &quot;Standard&quot;</span>
<a name="l00888"></a>00888 <span class="comment">  code index 1 =&gt; &quot;Vertebrate Mitochondrial&quot;</span>
<a name="l00889"></a>00889 <span class="comment">  code index 2 =&gt; &quot;Yeast Mitochondrial&quot;</span>
<a name="l00890"></a>00890 <span class="comment">  code index 3 =&gt; &quot;Mold Mitochondrial; Protozoan Mitochondrial; Coelenterate Mitochondrial; Mycoplasma; Spiroplasma&quot;</span>
<a name="l00891"></a>00891 <span class="comment">  code index 4 =&gt; &quot;Invertebrate Mitochondrial&quot;</span>
<a name="l00892"></a>00892 <span class="comment">  code index 5 =&gt; &quot;Ciliate Nuclear; Dasycladacean Nuclear; Hexamita Nuclear&quot;</span>
<a name="l00893"></a>00893 <span class="comment">  code index 8 =&gt; &quot;Echinoderm Mitochondrial; Flatworm Mitochondrial&quot;</span>
<a name="l00894"></a>00894 <span class="comment">  code index 9 =&gt; &quot;Euplotid Nuclear&quot;</span>
<a name="l00895"></a>00895 <span class="comment">  code index 10 =&gt; &quot;Bacterial and Plant Plastid&quot;</span>
<a name="l00896"></a>00896 <span class="comment">  code index 11 =&gt; &quot;Alternative Yeast Nuclear&quot;</span>
<a name="l00897"></a>00897 <span class="comment">  code index 12 =&gt; &quot;Ascidian Mitochondrial&quot;</span>
<a name="l00898"></a>00898 <span class="comment">  code index 13 =&gt; &quot;Alternative Flatworm Mitochondrial&quot;</span>
<a name="l00899"></a>00899 <span class="comment">  code index 14 =&gt; &quot;Blepharisma Macronuclear&quot;</span>
<a name="l00900"></a>00900 <span class="comment">  code index 15 =&gt; &quot;Chlorophycean Mitochondrial&quot;</span>
<a name="l00901"></a>00901 <span class="comment">  code index 20 =&gt; &quot;Trematode Mitochondrial&quot;</span>
<a name="l00902"></a>00902 <span class="comment">  code index 21 =&gt; &quot;Scenedesmus obliquus Mitochondrial&quot;</span>
<a name="l00903"></a>00903 <span class="comment">  code index 22 =&gt; &quot;Thraustochytrium Mitochondrial&quot;</span>
<a name="l00904"></a>00904 <span class="comment">*/</span>
<a name="l00905"></a>00905 std::string getGeneticCodeAAOrder(NxsGeneticCodesEnum codeIndex)
<a name="l00906"></a>00906 {
<a name="l00907"></a>00907     std::vector&lt;std::string&gt; code(NXS_GCODE_CODE_ENUM_SIZE);
<a name="l00908"></a>00908     code[NXS_GCODE_STANDARD] =  <span class="stringliteral">&quot;KNKNTTTTRSRSIIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVV*Y*YSSSS*CWCLFLF&quot;</span>;
<a name="l00909"></a>00909     code[NXS_GCODE_VERT_MITO] = <span class="stringliteral">&quot;KNKNTTTT*S*SMIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVV*Y*YSSSSWCWCLFLF&quot;</span>;
<a name="l00910"></a>00910     code[NXS_GCODE_YEAST_MITO] = <span class="stringliteral">&quot;KNKNTTTTRSRSIIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVV*Y*YSSSSWCWCLFLF&quot;</span>;
<a name="l00911"></a>00911     code[NXS_GCODE_MOLD_MITO] = <span class="stringliteral">&quot;KNKNTTTTRSRSIIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVV*Y*YSSSSWCWCLFLF&quot;</span>;
<a name="l00912"></a>00912     code[NXS_GCODE_INVERT_MITO] = <span class="stringliteral">&quot;KNKNTTTTSSSSMIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVV*Y*YSSSSWCWCLFLF&quot;</span>;
<a name="l00913"></a>00913     code[NXS_GCODE_CILIATE] = <span class="stringliteral">&quot;KNKNTTTTRSRSIIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVVQYQYSSSS*CWCLFLF&quot;</span>;
<a name="l00914"></a>00914     code[NXS_GCODE_ECHINO_MITO] = <span class="stringliteral">&quot;NNKNTTTTSSSSIIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVV*Y*YSSSSWCWCLFLF&quot;</span>;
<a name="l00915"></a>00915     code[NXS_GCODE_EUPLOTID] = <span class="stringliteral">&quot;KNKNTTTTRSRSIIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVV*Y*YSSSSCCWCLFLF&quot;</span>;
<a name="l00916"></a>00916     code[NXS_GCODE_PLANT_PLASTID] = <span class="stringliteral">&quot;KNKNTTTTRSRSIIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVV*Y*YSSSS*CWCLFLF&quot;</span>;
<a name="l00917"></a>00917     code[NXS_GCODE_ALT_YEAST] = <span class="stringliteral">&quot;KNKNTTTTRSRSIIMIQHQHPPPPRRRRLLSLEDEDAAAAGGGGVVVV*Y*YSSSS*CWCLFLF&quot;</span>;
<a name="l00918"></a>00918     code[NXS_GCODE_ASCIDIAN_MITO] = <span class="stringliteral">&quot;KNKNTTTTGSGSMIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVV*Y*YSSSSWCWCLFLF&quot;</span>;
<a name="l00919"></a>00919     code[NXS_GCODE_ALT_FLATWORM_MITO] = <span class="stringliteral">&quot;NNKNTTTTSSSSIIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVVYY*YSSSSWCWCLFLF&quot;</span>;
<a name="l00920"></a>00920     code[NXS_GCODE_BLEPHARISMA_MACRO] = <span class="stringliteral">&quot;KNKNTTTTRSRSIIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVV*YQYSSSS*CWCLFLF&quot;</span>;
<a name="l00921"></a>00921     code[NXS_GCODE_CHLOROPHYCEAN_MITO] = <span class="stringliteral">&quot;KNKNTTTTRSRSIIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVV*YLYSSSS*CWCLFLF&quot;</span>;
<a name="l00922"></a>00922     code[NXS_GCODE_TREMATODE_MITO] = <span class="stringliteral">&quot;NNKNTTTTSSSSMIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVV*Y*YSSSSWCWCLFLF&quot;</span>;
<a name="l00923"></a>00923     code[NXS_GCODE_SCENEDESMUS_MITO] = <span class="stringliteral">&quot;KNKNTTTTRSRSIIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVV*YLY*SSS*CWCLFLF&quot;</span>;
<a name="l00924"></a>00924     code[NXS_GCODE_THRAUSTOCHYTRIUM_MITO] = <span class="stringliteral">&quot;KNKNTTTTRSRSIIMIQHQHPPPPRRRRLLLLEDEDAAAAGGGGVVVV*Y*YSSSS*CWC*FLF&quot;</span>;
<a name="l00925"></a>00925     <span class="keywordtype">int</span> c = (int) codeIndex;
<a name="l00926"></a>00926     <span class="keywordflow">return</span> code.at(c);
<a name="l00927"></a>00927 }
<a name="l00928"></a>00928 
<a name="l00929"></a>00929 
<a name="l00930"></a>00930 
<a name="l00931"></a>00931 std::vector&lt;NxsDiscreteStateCell&gt; getGeneticCodeIndicesAAOrder(<span class="keyword">const</span> NxsGeneticCodesEnum codeIndex);
<a name="l00932"></a>00932 
<a name="l00933"></a>00933 
<a name="l00934"></a>00934 std::vector&lt;NxsDiscreteStateCell&gt; getGeneticCodeIndicesAAOrder(<span class="keyword">const</span> NxsGeneticCodesEnum codeIndex)
<a name="l00935"></a>00935 {
<a name="l00936"></a>00936     std::vector&lt;NxsDiscreteStateCell&gt; aaInd(64);
<a name="l00937"></a>00937     aaInd[0] = 8;
<a name="l00938"></a>00938     aaInd[1] = 11;
<a name="l00939"></a>00939     aaInd[2] = 8;
<a name="l00940"></a>00940     aaInd[3] = 11;
<a name="l00941"></a>00941     aaInd[4] = 16;
<a name="l00942"></a>00942     aaInd[5] = 16;
<a name="l00943"></a>00943     aaInd[6] = 16;
<a name="l00944"></a>00944     aaInd[7] = 16;
<a name="l00945"></a>00945     aaInd[8] = 14;
<a name="l00946"></a>00946     aaInd[9] = 15;
<a name="l00947"></a>00947     aaInd[10] = 14;
<a name="l00948"></a>00948     aaInd[11] = 15;
<a name="l00949"></a>00949     aaInd[12] = 7;
<a name="l00950"></a>00950     aaInd[13] = 7;
<a name="l00951"></a>00951     aaInd[14] = 10;
<a name="l00952"></a>00952     aaInd[15] = 7;
<a name="l00953"></a>00953     aaInd[16] = 13;
<a name="l00954"></a>00954     aaInd[17] = 6;
<a name="l00955"></a>00955     aaInd[18] = 13;
<a name="l00956"></a>00956     aaInd[19] = 6;
<a name="l00957"></a>00957     aaInd[20] = 12;
<a name="l00958"></a>00958     aaInd[21] = 12;
<a name="l00959"></a>00959     aaInd[22] = 12;
<a name="l00960"></a>00960     aaInd[23] = 12;
<a name="l00961"></a>00961     aaInd[24] = 14;
<a name="l00962"></a>00962     aaInd[25] = 14;
<a name="l00963"></a>00963     aaInd[26] = 14;
<a name="l00964"></a>00964     aaInd[27] = 14;
<a name="l00965"></a>00965     aaInd[28] = 9;
<a name="l00966"></a>00966     aaInd[29] = 9;
<a name="l00967"></a>00967     aaInd[30] = 9;
<a name="l00968"></a>00968     aaInd[31] = 9;
<a name="l00969"></a>00969     aaInd[32] = 3;
<a name="l00970"></a>00970     aaInd[33] = 2;
<a name="l00971"></a>00971     aaInd[34] = 3;
<a name="l00972"></a>00972     aaInd[35] = 2;
<a name="l00973"></a>00973     aaInd[36] = 0;
<a name="l00974"></a>00974     aaInd[37] = 0;
<a name="l00975"></a>00975     aaInd[38] = 0;
<a name="l00976"></a>00976     aaInd[39] = 0;
<a name="l00977"></a>00977     aaInd[40] = 5;
<a name="l00978"></a>00978     aaInd[41] = 5;
<a name="l00979"></a>00979     aaInd[42] = 5;
<a name="l00980"></a>00980     aaInd[43] = 5;
<a name="l00981"></a>00981     aaInd[44] = 17;
<a name="l00982"></a>00982     aaInd[45] = 17;
<a name="l00983"></a>00983     aaInd[46] = 17;
<a name="l00984"></a>00984     aaInd[47] = 17;
<a name="l00985"></a>00985     aaInd[48] = 20;
<a name="l00986"></a>00986     aaInd[49] = 19;
<a name="l00987"></a>00987     aaInd[50] = 20;
<a name="l00988"></a>00988     aaInd[51] = 19;
<a name="l00989"></a>00989     aaInd[52] = 15;
<a name="l00990"></a>00990     aaInd[53] = 15;
<a name="l00991"></a>00991     aaInd[54] = 15;
<a name="l00992"></a>00992     aaInd[55] = 15;
<a name="l00993"></a>00993     aaInd[56] = 20;
<a name="l00994"></a>00994     aaInd[57] = 1;
<a name="l00995"></a>00995     aaInd[58] = 18;
<a name="l00996"></a>00996     aaInd[59] = 1;
<a name="l00997"></a>00997     aaInd[60] = 9;
<a name="l00998"></a>00998     aaInd[61] = 4;
<a name="l00999"></a>00999     aaInd[62] = 9;
<a name="l01000"></a>01000     aaInd[63] = 4;
<a name="l01001"></a>01001     <span class="keywordflow">if</span> (codeIndex == NXS_GCODE_VERT_MITO) {
<a name="l01002"></a>01002         aaInd[8] = 20;
<a name="l01003"></a>01003         aaInd[10] = 20;
<a name="l01004"></a>01004         aaInd[12] = 10;
<a name="l01005"></a>01005         aaInd[56] = 18;
<a name="l01006"></a>01006     }
<a name="l01007"></a>01007     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codeIndex == NXS_GCODE_YEAST_MITO) {
<a name="l01008"></a>01008         aaInd[56] = 18;
<a name="l01009"></a>01009     }
<a name="l01010"></a>01010     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codeIndex == NXS_GCODE_MOLD_MITO) {
<a name="l01011"></a>01011         aaInd[56] = 18;
<a name="l01012"></a>01012     }
<a name="l01013"></a>01013     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codeIndex == NXS_GCODE_INVERT_MITO) {
<a name="l01014"></a>01014         aaInd[8] = 15;
<a name="l01015"></a>01015         aaInd[10] = 15;
<a name="l01016"></a>01016         aaInd[12] = 10;
<a name="l01017"></a>01017         aaInd[56] = 18;
<a name="l01018"></a>01018     }
<a name="l01019"></a>01019     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codeIndex == NXS_GCODE_CILIATE) {
<a name="l01020"></a>01020         aaInd[48] = 13;
<a name="l01021"></a>01021         aaInd[50] = 13;
<a name="l01022"></a>01022     }
<a name="l01023"></a>01023     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codeIndex == NXS_GCODE_ECHINO_MITO) {
<a name="l01024"></a>01024         aaInd[0] = 11;
<a name="l01025"></a>01025         aaInd[8] = 15;
<a name="l01026"></a>01026         aaInd[10] = 15;
<a name="l01027"></a>01027         aaInd[56] = 18;
<a name="l01028"></a>01028     }
<a name="l01029"></a>01029     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codeIndex == NXS_GCODE_EUPLOTID) {
<a name="l01030"></a>01030         aaInd[56] = 1;
<a name="l01031"></a>01031     }
<a name="l01032"></a>01032     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codeIndex == NXS_GCODE_ALT_YEAST) {
<a name="l01033"></a>01033         aaInd[30] = 15;
<a name="l01034"></a>01034     }
<a name="l01035"></a>01035     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codeIndex == NXS_GCODE_ASCIDIAN_MITO) {
<a name="l01036"></a>01036         aaInd[8] = 5;
<a name="l01037"></a>01037         aaInd[10] = 5;
<a name="l01038"></a>01038         aaInd[12] = 10;
<a name="l01039"></a>01039         aaInd[56] = 18;
<a name="l01040"></a>01040     }
<a name="l01041"></a>01041     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codeIndex == NXS_GCODE_ALT_FLATWORM_MITO) {
<a name="l01042"></a>01042         aaInd[0] = 11;
<a name="l01043"></a>01043         aaInd[8] = 15;
<a name="l01044"></a>01044         aaInd[10] = 15;
<a name="l01045"></a>01045         aaInd[48] = 19;
<a name="l01046"></a>01046         aaInd[56] = 18;
<a name="l01047"></a>01047     }
<a name="l01048"></a>01048     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codeIndex == NXS_GCODE_BLEPHARISMA_MACRO) {
<a name="l01049"></a>01049         aaInd[50] = 13;
<a name="l01050"></a>01050     }
<a name="l01051"></a>01051     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codeIndex == NXS_GCODE_CHLOROPHYCEAN_MITO) {
<a name="l01052"></a>01052         aaInd[50] = 9;
<a name="l01053"></a>01053     }
<a name="l01054"></a>01054     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codeIndex == NXS_GCODE_TREMATODE_MITO) {
<a name="l01055"></a>01055         aaInd[0] = 11;
<a name="l01056"></a>01056         aaInd[8] = 15;
<a name="l01057"></a>01057         aaInd[10] = 15;
<a name="l01058"></a>01058         aaInd[12] = 10;
<a name="l01059"></a>01059         aaInd[56] = 18;
<a name="l01060"></a>01060     }
<a name="l01061"></a>01061     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codeIndex == NXS_GCODE_SCENEDESMUS_MITO) {
<a name="l01062"></a>01062         aaInd[50] = 9;
<a name="l01063"></a>01063         aaInd[52] = 20;
<a name="l01064"></a>01064     }
<a name="l01065"></a>01065     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codeIndex == NXS_GCODE_THRAUSTOCHYTRIUM_MITO) {
<a name="l01066"></a>01066         aaInd[60] = 20;
<a name="l01067"></a>01067     }
<a name="l01068"></a>01068     <span class="keywordflow">return</span> aaInd;
<a name="l01069"></a>01069 }
<a name="l01070"></a>01070 
<a name="l01071"></a>01071 
<a name="l01072"></a><a class="code" href="classNxsCharactersBlock_abafe2976c3a29989b2cbbcb12a6acafa.html#abafe2976c3a29989b2cbbcb12a6acafa">01072</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_abafe2976c3a29989b2cbbcb12a6acafa.html#abafe2976c3a29989b2cbbcb12a6acafa">NxsCharactersBlock::CodonPosPartitionToPosList</a>(<span class="keyword">const</span> NxsPartition &amp;codonPos, std::list&lt;int&gt; * charIndices)
<a name="l01073"></a>01073 {
<a name="l01074"></a>01074     <span class="keywordflow">if</span> (charIndices == 0L)
<a name="l01075"></a>01075         <span class="keywordflow">return</span>;
<a name="l01076"></a>01076     <span class="keyword">const</span> NxsUnsignedSet * firstPos = 0L;
<a name="l01077"></a>01077     <span class="keyword">const</span> NxsUnsignedSet * secondPos = 0L;
<a name="l01078"></a>01078     <span class="keyword">const</span> NxsUnsignedSet * thirdPos = 0L;
<a name="l01079"></a>01079     <span class="keywordflow">for</span> (NxsPartition::const_iterator pIt = codonPos.begin(); pIt != codonPos.end(); ++pIt)
<a name="l01080"></a>01080         {
<a name="l01081"></a>01081         <span class="keywordflow">if</span> (pIt-&gt;first == <span class="stringliteral">&quot;1&quot;</span>)
<a name="l01082"></a>01082             {
<a name="l01083"></a>01083             NCL_ASSERT(firstPos == 0L);
<a name="l01084"></a>01084             firstPos = &amp;(pIt-&gt;second);
<a name="l01085"></a>01085             }
<a name="l01086"></a>01086         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pIt-&gt;first == <span class="stringliteral">&quot;2&quot;</span>)
<a name="l01087"></a>01087             {
<a name="l01088"></a>01088             NCL_ASSERT(secondPos == 0L);
<a name="l01089"></a>01089             secondPos = &amp;(pIt-&gt;second);
<a name="l01090"></a>01090             }
<a name="l01091"></a>01091         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pIt-&gt;first == <span class="stringliteral">&quot;3&quot;</span>)
<a name="l01092"></a>01092             {
<a name="l01093"></a>01093             NCL_ASSERT(thirdPos == 0L);
<a name="l01094"></a>01094             thirdPos = &amp;(pIt-&gt;second);
<a name="l01095"></a>01095             }
<a name="l01096"></a>01096         }
<a name="l01097"></a>01097     <span class="keywordflow">if</span> (firstPos == 0L || secondPos == 0L || thirdPos == 0L)
<a name="l01098"></a>01098         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Expecting partition subsets named 1, 2, and 3&quot;</span>);
<a name="l01099"></a>01099     <span class="keywordflow">if</span> (firstPos-&gt;size() != secondPos-&gt;size() || firstPos-&gt;size() != thirdPos-&gt;size())
<a name="l01100"></a>01100         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Expecting the partition subsets named 1, 2, and 3 to have the same size&quot;</span>);
<a name="l01101"></a>01101     NxsUnsignedSet::const_iterator fIt = firstPos-&gt;begin();
<a name="l01102"></a>01102     NxsUnsignedSet::const_iterator sIt = secondPos-&gt;begin();
<a name="l01103"></a>01103     NxsUnsignedSet::const_iterator thIt = thirdPos-&gt;begin();
<a name="l01104"></a>01104     <span class="keyword">const</span> NxsUnsignedSet::const_iterator endIt = firstPos-&gt;end();
<a name="l01105"></a>01105     <span class="keywordflow">for</span> (; fIt != endIt; ++fIt, ++sIt, ++thIt)
<a name="l01106"></a>01106         {
<a name="l01107"></a>01107         charIndices-&gt;push_back(*fIt);
<a name="l01108"></a>01108         charIndices-&gt;push_back(*sIt);
<a name="l01109"></a>01109         charIndices-&gt;push_back(*thIt);
<a name="l01110"></a>01110         }
<a name="l01111"></a>01111 }
<a name="l01112"></a>01112 
<a name="l01113"></a>01113 <span class="comment">/* allocates a new charaters block with amino acids for the codons in the characters block (which should have datatype = codon).</span>
<a name="l01114"></a>01114 <span class="comment">*/</span>
<a name="l01115"></a>01115 <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> * NxsCharactersBlock::NewProteinCharactersBlock(
<a name="l01116"></a>01116   <span class="keyword">const</span> <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> * codonBlock,
<a name="l01117"></a>01117   <span class="keywordtype">bool</span> mapPartialAmbigToUnknown,
<a name="l01118"></a>01118   <span class="keywordtype">bool</span> gapToUnknown,
<a name="l01119"></a>01119   NxsGeneticCodesEnum codeIndex)
<a name="l01120"></a>01120 {
<a name="l01121"></a>01121     std::vector&lt;NxsDiscreteStateCell&gt; aas = getGeneticCodeIndicesAAOrder(codeIndex);
<a name="l01122"></a>01122     <span class="keywordflow">return</span> NxsCharactersBlock::NewProteinCharactersBlock(codonBlock, mapPartialAmbigToUnknown, gapToUnknown, aas);
<a name="l01123"></a>01123 }
<a name="l01124"></a>01124 
<a name="l01125"></a>01125 
<a name="l01126"></a>01126 <span class="comment">/* allocates a new charaters block with amino acids for the codons in the characters block (which should have datatype = codon).</span>
<a name="l01127"></a>01127 <span class="comment"></span>
<a name="l01128"></a>01128 <span class="comment">*/</span>
<a name="l01129"></a><a class="code" href="classNxsCharactersBlock_a3d7824cec8960db992d3f8ed5a963e53.html#a3d7824cec8960db992d3f8ed5a963e53">01129</a> <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> * NxsCharactersBlock::NewProteinCharactersBlock(
<a name="l01130"></a>01130   <span class="keyword">const</span> <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> * codonBlock,
<a name="l01131"></a>01131   <span class="keywordtype">bool</span> mapPartialAmbigToUnknown,
<a name="l01132"></a>01132   <span class="keywordtype">bool</span> gapToUnknown,
<a name="l01133"></a>01133   <span class="keyword">const</span> std::vector&lt;NxsDiscreteStateCell&gt; &amp; aaIndices) 
<a name="l01134"></a>01134 {
<a name="l01135"></a>01135     <span class="keywordflow">if</span> (!codonBlock)
<a name="l01136"></a>01136         <span class="keywordflow">return</span> NULL;
<a name="l01137"></a>01137     <span class="keywordflow">if</span> (codonBlock-&gt;<a class="code" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&amp;#39; from the datatype mapper.">GetDataType</a>() != <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa11d7fb339c6f83517338e0e6faac722" title="indicates `matrix&amp;#39; holds amino acid sequences">NxsCharactersBlock::codon</a>)
<a name="l01138"></a>01138         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;NewProteinCharactersBlock must be called with a block of codon datatype&quot;</span>);
<a name="l01139"></a>01139     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nc = codonBlock-&gt;<a class="code" href="classNxsCharactersBlock_a5f984e07256fa1055b04210484301046.html#a5f984e07256fa1055b04210484301046">GetNCharTotal</a>();
<a name="l01140"></a>01140 
<a name="l01141"></a>01141     <span class="comment">/* create a new characters block with the same TAXA, but no ASSUMPTIONS block */</span>
<a name="l01142"></a>01142     <a class="code" href="classNxsTaxaBlockAPI.html" title="This abstract class describes the interface that every block that wants to serve...">NxsTaxaBlockAPI</a> * taxa = codonBlock-&gt;GetTaxaBlockPtr(NULL);
<a name="l01143"></a>01143     <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> * aaBlock = <span class="keyword">new</span> <a class="code" href="classNxsCharactersBlock_aecbd5a9f87d5966c8a63acd77a507b67.html#aecbd5a9f87d5966c8a63acd77a507b67" title="In v2.1 of the API, the NxsTaxaBlockAPI and NxsAssumptionsBlockAPI pointers are usually...">NxsCharactersBlock</a>(taxa, NULL);
<a name="l01144"></a>01144     aaBlock-&gt;SetNChar(nc);
<a name="l01145"></a>01145     aaBlock-&gt;SetNTax(codonBlock-&gt;GetNTaxWithData());
<a name="l01146"></a>01146     aaBlock-&gt;missing = codonBlock-&gt;missing;
<a name="l01147"></a>01147     aaBlock-&gt;gap = (gapToUnknown ? <span class="charliteral">&#39;\0&#39;</span> : codonBlock-&gt;gap);
<a name="l01148"></a>01148     aaBlock-&gt;gapMode = codonBlock-&gt;gapMode;
<a name="l01149"></a>01149     aaBlock-&gt;datatype = <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca6867b9b05a5ce824179b5bdf10c891fc" title="indicates `matrix&amp;#39; holds nucleotide sequences">NxsCharactersBlock::protein</a>;
<a name="l01150"></a>01150     aaBlock-&gt;originalDatatype = codonBlock-&gt;originalDatatype;
<a name="l01151"></a>01151     aaBlock-&gt;<a class="code" href="classNxsCharactersBlock_a60329b2e678a91ca6cd46957093e6f56.html#a60329b2e678a91ca6cd46957093e6f56" title="Resets standard symbol set after a change in `datatype&amp;#39; is made.">ResetSymbols</a>();
<a name="l01152"></a>01152     aaBlock-&gt;tokens = <span class="keyword">false</span>;
<a name="l01153"></a>01153 
<a name="l01154"></a>01154 
<a name="l01155"></a>01155     NxsPartition dummy;
<a name="l01156"></a>01156     std::vector&lt;DataTypesEnum&gt; dummyVec;
<a name="l01157"></a>01157     aaBlock-&gt;CreateDatatypeMapperObjects(dummy, dummyVec);
<a name="l01158"></a>01158     <span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * codonMapper = codonBlock-&gt;GetDatatypeMapperForChar(0);
<a name="l01159"></a>01159     <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * aaMapper = aaBlock-&gt;GetMutableDatatypeMapperForChar(0);
<a name="l01160"></a>01160     aaMapper-&gt;geneticCode = codonMapper-&gt;geneticCode;
<a name="l01161"></a>01161 
<a name="l01162"></a>01162     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ntax = (taxa == 0L ? codonBlock-&gt;GetNTaxWithData() : taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_a3e9b998d97ad05914bda0d616069c26f.html#a3e9b998d97ad05914bda0d616069c26f">GetNTax</a>());
<a name="l01163"></a>01163     aaBlock-&gt;datatypeReadFromFormat = <span class="keyword">false</span>;
<a name="l01164"></a>01164     aaBlock-&gt;statesFormat = STATES_PRESENT;
<a name="l01165"></a>01165     aaBlock-&gt;restrictionDataype = <span class="keyword">false</span>;
<a name="l01166"></a>01166     aaBlock-&gt;supportMixedDatatype = <span class="keyword">false</span>;
<a name="l01167"></a>01167     aaBlock-&gt;convertAugmentedToMixed = <span class="keyword">false</span>;
<a name="l01168"></a>01168     aaBlock-&gt;writeInterleaveLen = INT_MAX;
<a name="l01169"></a>01169 
<a name="l01170"></a>01170 
<a name="l01171"></a>01171     NxsDiscreteStateRow matRow(nc, 0);
<a name="l01172"></a>01172     aaBlock-&gt;discreteMatrix.assign(ntax, matRow);
<a name="l01173"></a>01173     <span class="keywordflow">if</span> (mapPartialAmbigToUnknown &amp;&amp; (gapToUnknown || codonBlock-&gt;<a class="code" href="classNxsCharactersBlock_a25f1d2be3465fd9dafb97be50d8e2601.html#a25f1d2be3465fd9dafb97be50d8e2601" title="Returns the gap symbol currently in effect.">GetGapSymbol</a>() != <span class="charliteral">&#39;\0&#39;</span>))
<a name="l01174"></a>01174         {
<a name="l01175"></a>01175         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> taxInd = 0; taxInd &lt; ntax; ++taxInd)
<a name="l01176"></a>01176             {
<a name="l01177"></a>01177             <span class="keyword">const</span> NxsDiscreteStateRow &amp; sourceRow = codonBlock-&gt;discreteMatrix.at(taxInd);
<a name="l01178"></a>01178             NxsDiscreteStateRow &amp; destRow = aaBlock-&gt;discreteMatrix.at(taxInd);
<a name="l01179"></a>01179             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> c = 0; c &lt; nc ; ++c)
<a name="l01180"></a>01180                 {
<a name="l01181"></a>01181                 <span class="keyword">const</span> NxsDiscreteStateCell <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa11d7fb339c6f83517338e0e6faac722" title="indicates `matrix&amp;#39; holds amino acid sequences">codon</a> = sourceRow[c];
<a name="l01182"></a>01182                 <span class="keywordflow">if</span> (codon &lt; 0 || codon &gt; 63)
<a name="l01183"></a>01183                     destRow[c] = NXS_MISSING_CODE;
<a name="l01184"></a>01184                 <span class="keywordflow">else</span>
<a name="l01185"></a>01185                     destRow[c] = aaIndices.at(codon);
<a name="l01186"></a>01186                 }
<a name="l01187"></a>01187             }
<a name="l01188"></a>01188         }
<a name="l01189"></a>01189     <span class="keywordflow">else</span>
<a name="l01190"></a>01190         {
<a name="l01191"></a>01191         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;NewProteinCharactersBlock is not implemented for cases in which you are not mapping any ambiguity to the missing state code.&quot;</span>);
<a name="l01192"></a>01192         }
<a name="l01193"></a>01193     <span class="keywordflow">return</span> aaBlock;
<a name="l01194"></a>01194 }
<a name="l01195"></a>01195 
<a name="l01196"></a>01196 
<a name="l01197"></a>01197 <span class="comment">/* allocates a new charaters block with all of the active characters in `charBlock`</span>
<a name="l01198"></a>01198 <span class="comment">    but with a 64-state codon datatype. The order of codons is:</span>
<a name="l01199"></a>01199 <span class="comment">     0   1   2   3   4   5  ... 63</span>
<a name="l01200"></a>01200 <span class="comment">    AAA AAC AAG AAT ACA ACC ... TTT</span>
<a name="l01201"></a>01201 <span class="comment">    The caller is responsible for deleting the new NxsCharactersBlock object</span>
<a name="l01202"></a>01202 <span class="comment"></span>
<a name="l01203"></a>01203 <span class="comment">    If honorCharActive is true, then inactive characters are simply skipped in the reading</span>
<a name="l01204"></a>01204 <span class="comment">    frame (treated as if they were introns) rather than being treated as missing.</span>
<a name="l01205"></a>01205 <span class="comment">*/</span>
<a name="l01206"></a>01206 <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> * NxsCharactersBlock::NewCodonsCharactersBlock(
<a name="l01207"></a>01207   <span class="keyword">const</span> <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> * dnaBlock,
<a name="l01208"></a>01208   <span class="keywordtype">bool</span> mapPartialAmbigToUnknown,
<a name="l01209"></a>01209   <span class="keywordtype">bool</span> gapsToUnknown,
<a name="l01210"></a>01210   <span class="keywordtype">bool</span> honorCharActive,
<a name="l01211"></a>01211   <span class="keyword">const</span> std::list&lt;int&gt; * charIndices,
<a name="l01212"></a>01212   <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> ** spareNucs)
<a name="l01213"></a>01213 {
<a name="l01214"></a>01214     <span class="keywordflow">if</span> (!dnaBlock)
<a name="l01215"></a>01215         <span class="keywordflow">return</span> NULL;
<a name="l01216"></a>01216     <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290c" title="values used to represent different basic types of data stored in a CHARACTERS block...">DataTypesEnum</a> nucType = dnaBlock-&gt;<a class="code" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&amp;#39; from the datatype mapper.">GetDataType</a>();
<a name="l01217"></a>01217     <span class="keywordflow">if</span> (nucType != <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca0145b9755a4581acaabe1e4c458d7f73" title="indicates `matrix&amp;#39; holds characters with arbitrarily-assigned, discrete states...">NxsCharactersBlock::dna</a> &amp;&amp; nucType != <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca9cb7e8ceb8521a96df0b81ecac913814" title="indicates `matrix&amp;#39; holds DNA sequences (states A, C, G, T)">NxsCharactersBlock::rna</a> &amp;&amp; nucType != <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa9ca7e6de7b65840b97d9ecd42c0ad3a" title="indicates `matrix&amp;#39; holds RNA sequences (states A, C, G, U)">NxsCharactersBlock::nucleotide</a>)
<a name="l01218"></a>01218         <span class="keywordflow">return</span> NULL;
<a name="l01219"></a>01219     std::list&lt;int&gt; charInds;
<a name="l01220"></a>01220     <span class="keyword">const</span> std::list&lt;int&gt; * sourceChars;
<a name="l01221"></a>01221     std::list&lt;int&gt; culled;
<a name="l01222"></a>01222     NxsUnsignedSet untranslated;
<a name="l01223"></a>01223 
<a name="l01224"></a>01224 
<a name="l01225"></a>01225 
<a name="l01226"></a>01226     <span class="keywordtype">unsigned</span> nc = dnaBlock-&gt;<a class="code" href="classNxsCharactersBlock_a5f984e07256fa1055b04210484301046.html#a5f984e07256fa1055b04210484301046">GetNCharTotal</a>();
<a name="l01227"></a>01227 
<a name="l01228"></a>01228     <span class="keywordflow">if</span> (charIndices == NULL)
<a name="l01229"></a>01229         {
<a name="l01230"></a>01230         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; nc; ++i)
<a name="l01231"></a>01231             charInds.push_back((<span class="keywordtype">int</span>)i);
<a name="l01232"></a>01232         sourceChars = &amp;charInds;
<a name="l01233"></a>01233         }
<a name="l01234"></a>01234     <span class="keywordflow">else</span>
<a name="l01235"></a>01235         sourceChars = charIndices;
<a name="l01236"></a>01236 
<a name="l01237"></a>01237     <span class="keywordflow">if</span> (honorCharActive)
<a name="l01238"></a>01238         {
<a name="l01239"></a>01239         <span class="keywordflow">for</span> (std::list&lt;int&gt;::const_iterator cIt = sourceChars-&gt;begin(); cIt != sourceChars-&gt;end(); ++cIt)
<a name="l01240"></a>01240             {
<a name="l01241"></a>01241             <span class="keyword">const</span> <span class="keywordtype">int</span> c = *cIt;
<a name="l01242"></a>01242             <span class="keywordflow">if</span> (c &lt; 0 || dnaBlock-&gt;<a class="code" href="classNxsCharactersBlock_a1a2ac1c77126d46dab11200bc1869258.html#a1a2ac1c77126d46dab11200bc1869258">IsActiveChar</a>((<span class="keywordtype">unsigned</span>) c))
<a name="l01243"></a>01243                 culled.push_back(c);
<a name="l01244"></a>01244             }
<a name="l01245"></a>01245         <span class="keywordflow">if</span> (spareNucs)
<a name="l01246"></a>01246             {
<a name="l01247"></a>01247             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> c = 0; c &lt; nc; ++c)
<a name="l01248"></a>01248                 {
<a name="l01249"></a>01249                 <span class="keywordflow">if</span> (dnaBlock-&gt;<a class="code" href="classNxsCharactersBlock_a1a2ac1c77126d46dab11200bc1869258.html#a1a2ac1c77126d46dab11200bc1869258">IsActiveChar</a>((<span class="keywordtype">unsigned</span>) c))
<a name="l01250"></a>01250                     untranslated.insert(c);
<a name="l01251"></a>01251                 }
<a name="l01252"></a>01252             }
<a name="l01253"></a>01253         sourceChars = &amp;culled;
<a name="l01254"></a>01254         }
<a name="l01255"></a>01255     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (spareNucs)
<a name="l01256"></a>01256         {
<a name="l01257"></a>01257         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> c = 0; c &lt; nc; ++c)
<a name="l01258"></a>01258             untranslated.insert(c);
<a name="l01259"></a>01259         }
<a name="l01260"></a>01260 
<a name="l01261"></a>01261     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nnucs = (<span class="keyword">const</span> unsigned)sourceChars-&gt;size();
<a name="l01262"></a>01262     <span class="keywordflow">if</span> (nnucs % 3)
<a name="l01263"></a>01263         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Cannot create a codons block with a number of characters that is not a multiple of 3&quot;</span>);
<a name="l01264"></a>01264     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ncodons = nnucs/3;
<a name="l01265"></a>01265 
<a name="l01266"></a>01266     <span class="comment">/* create a new characters block with the same TAXA, but no ASSUMPTIONS block */</span>
<a name="l01267"></a>01267     <a class="code" href="classNxsTaxaBlockAPI.html" title="This abstract class describes the interface that every block that wants to serve...">NxsTaxaBlockAPI</a> * taxa = dnaBlock-&gt;GetTaxaBlockPtr(NULL);
<a name="l01268"></a>01268     <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> * codonsBlock = <span class="keyword">new</span> <a class="code" href="classNxsCharactersBlock_aecbd5a9f87d5966c8a63acd77a507b67.html#aecbd5a9f87d5966c8a63acd77a507b67" title="In v2.1 of the API, the NxsTaxaBlockAPI and NxsAssumptionsBlockAPI pointers are usually...">NxsCharactersBlock</a>(taxa, NULL);
<a name="l01269"></a>01269     codonsBlock-&gt;SetNChar(ncodons);
<a name="l01270"></a>01270     codonsBlock-&gt;SetNTax(dnaBlock-&gt;GetNTaxWithData());
<a name="l01271"></a>01271     codonsBlock-&gt;missing = dnaBlock-&gt;missing;
<a name="l01272"></a>01272     codonsBlock-&gt;gap = (gapsToUnknown ? <span class="charliteral">&#39;\0&#39;</span> : dnaBlock-&gt;gap);
<a name="l01273"></a>01273     codonsBlock-&gt;gapMode = dnaBlock-&gt;gapMode;
<a name="l01274"></a>01274     codonsBlock-&gt;symbols.assign(64, <span class="charliteral">&#39;\0&#39;</span>);
<a name="l01275"></a>01275     codonsBlock-&gt;tokens = <span class="keyword">false</span>;
<a name="l01276"></a>01276     <span class="keyword">const</span> <span class="keywordtype">char</span> * gsl[] = {<span class="stringliteral">&quot;AAA&quot;</span>,  <span class="stringliteral">&quot;AAC&quot;</span>,  <span class="stringliteral">&quot;AAG&quot;</span>,  <span class="stringliteral">&quot;AAT&quot;</span>,  <span class="stringliteral">&quot;ACA&quot;</span>,  <span class="stringliteral">&quot;ACC&quot;</span>,  <span class="stringliteral">&quot;ACG&quot;</span>,  <span class="stringliteral">&quot;ACT&quot;</span>,  <span class="stringliteral">&quot;AGA&quot;</span>,  <span class="stringliteral">&quot;AGC&quot;</span>,  <span class="stringliteral">&quot;AGG&quot;</span>,  <span class="stringliteral">&quot;AGT&quot;</span>,  <span class="stringliteral">&quot;ATA&quot;</span>,  <span class="stringliteral">&quot;ATC&quot;</span>,  <span class="stringliteral">&quot;ATG&quot;</span>,  <span class="stringliteral">&quot;ATT&quot;</span>,  <span class="stringliteral">&quot;CAA&quot;</span>,  <span class="stringliteral">&quot;CAC&quot;</span>,  <span class="stringliteral">&quot;CAG&quot;</span>,  <span class="stringliteral">&quot;CAT&quot;</span>,  <span class="stringliteral">&quot;CCA&quot;</span>,  <span class="stringliteral">&quot;CCC&quot;</span>,  <span class="stringliteral">&quot;CCG&quot;</span>,  <span class="stringliteral">&quot;CCT&quot;</span>,  <span class="stringliteral">&quot;CGA&quot;</span>,  <span class="stringliteral">&quot;CGC&quot;</span>,  <span class="stringliteral">&quot;CGG&quot;</span>,  <span class="stringliteral">&quot;CGT&quot;</span>,  <span class="stringliteral">&quot;CTA&quot;</span>,  <span class="stringliteral">&quot;CTC&quot;</span>,  <span class="stringliteral">&quot;CTG&quot;</span>,  <span class="stringliteral">&quot;CTT&quot;</span>,  <span class="stringliteral">&quot;GAA&quot;</span>,  <span class="stringliteral">&quot;GAC&quot;</span>,  <span class="stringliteral">&quot;GAG&quot;</span>,  <span class="stringliteral">&quot;GAT&quot;</span>,  <span class="stringliteral">&quot;GCA&quot;</span>,  <span class="stringliteral">&quot;GCC&quot;</span>,  <span class="stringliteral">&quot;GCG&quot;</span>,  <span class="stringliteral">&quot;GCT&quot;</span>,  <span class="stringliteral">&quot;GGA&quot;</span>,  <span class="stringliteral">&quot;GGC&quot;</span>,  <span class="stringliteral">&quot;GGG&quot;</span>,  <span class="stringliteral">&quot;GGT&quot;</span>,  <span class="stringliteral">&quot;GTA&quot;</span>,  <span class="stringliteral">&quot;GTC&quot;</span>,  <span class="stringliteral">&quot;GTG&quot;</span>,  <span class="stringliteral">&quot;GTT&quot;</span>,  <span class="stringliteral">&quot;TAA&quot;</span>,  <span class="stringliteral">&quot;TAC&quot;</span>,  <span class="stringliteral">&quot;TAG&quot;</span>,  <span class="stringliteral">&quot;TAT&quot;</span>,  <span class="stringliteral">&quot;TCA&quot;</span>,  <span class="stringliteral">&quot;TCC&quot;</span>,  <span class="stringliteral">&quot;TCG&quot;</span>,  <span class="stringliteral">&quot;TCT&quot;</span>,  <span class="stringliteral">&quot;TGA&quot;</span>,  <span class="stringliteral">&quot;TGC&quot;</span>,  <span class="stringliteral">&quot;TGG&quot;</span>,  <span class="stringliteral">&quot;TGT&quot;</span>,  <span class="stringliteral">&quot;TTA&quot;</span>,  <span class="stringliteral">&quot;TTC&quot;</span>,  <span class="stringliteral">&quot;TTG&quot;</span>,  <span class="stringliteral">&quot;TTT&quot;</span>};
<a name="l01277"></a>01277 
<a name="l01278"></a>01278     codonsBlock-&gt;globalStateLabels.reserve(64);
<a name="l01279"></a>01279     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0 ; i &lt; 64; ++i)
<a name="l01280"></a>01280         codonsBlock-&gt;globalStateLabels.push_back(<a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(gsl[i]));
<a name="l01281"></a>01281 
<a name="l01282"></a>01282     <span class="comment">/* equivalent of HandleFormat */</span>
<a name="l01283"></a>01283     codonsBlock-&gt;datatype = <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa11d7fb339c6f83517338e0e6faac722" title="indicates `matrix&amp;#39; holds amino acid sequences">NxsCharactersBlock::codon</a>;
<a name="l01284"></a>01284     codonsBlock-&gt;originalDatatype = nucType;
<a name="l01285"></a>01285 
<a name="l01286"></a>01286     <span class="keyword">const</span> NxsPartition dummy;
<a name="l01287"></a>01287     <span class="keyword">const</span> std::vector&lt;DataTypesEnum&gt; dummyVec;
<a name="l01288"></a>01288     codonsBlock-&gt;CreateDatatypeMapperObjects(dummy, dummyVec);
<a name="l01289"></a>01289     <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * codonMapper = codonsBlock-&gt;GetMutableDatatypeMapperForChar(0);
<a name="l01290"></a>01290     codonMapper-&gt;geneticCode = NXS_GCODE_NO_CODE;
<a name="l01291"></a>01291 
<a name="l01292"></a>01292     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ntax = (taxa == 0L ? dnaBlock-&gt;GetNTaxWithData() : taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_a3e9b998d97ad05914bda0d616069c26f.html#a3e9b998d97ad05914bda0d616069c26f">GetNTax</a>());
<a name="l01293"></a>01293     codonsBlock-&gt;datatypeReadFromFormat = <span class="keyword">false</span>;
<a name="l01294"></a>01294     codonsBlock-&gt;statesFormat = STATES_PRESENT;
<a name="l01295"></a>01295     codonsBlock-&gt;restrictionDataype = <span class="keyword">false</span>;
<a name="l01296"></a>01296     codonsBlock-&gt;supportMixedDatatype = <span class="keyword">false</span>;
<a name="l01297"></a>01297     codonsBlock-&gt;convertAugmentedToMixed = <span class="keyword">false</span>;
<a name="l01298"></a>01298     codonsBlock-&gt;writeInterleaveLen = INT_MAX;
<a name="l01299"></a>01299 
<a name="l01300"></a>01300 
<a name="l01301"></a>01301     <span class="keyword">const</span> <span class="keywordtype">int</span> maxUnambigNucState = 3;
<a name="l01302"></a>01302     <span class="keyword">const</span> NxsDiscreteStateCell codonMissingState = NXS_MISSING_CODE;
<a name="l01303"></a>01303     NxsDiscreteStateRow matRow(ncodons, 0);
<a name="l01304"></a>01304     codonsBlock-&gt;discreteMatrix.assign(ntax, matRow);
<a name="l01305"></a>01305     <span class="keyword">const</span> std::list&lt;int&gt;::const_iterator endNucIt = sourceChars-&gt;end();
<a name="l01306"></a>01306     <span class="keywordflow">if</span> (mapPartialAmbigToUnknown &amp;&amp; (gapsToUnknown || dnaBlock-&gt;<a class="code" href="classNxsCharactersBlock_a25f1d2be3465fd9dafb97be50d8e2601.html#a25f1d2be3465fd9dafb97be50d8e2601" title="Returns the gap symbol currently in effect.">GetGapSymbol</a>() != <span class="charliteral">&#39;\0&#39;</span>))
<a name="l01307"></a>01307         {
<a name="l01308"></a>01308         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> taxInd = 0; taxInd &lt; ntax; ++taxInd)
<a name="l01309"></a>01309             {
<a name="l01310"></a>01310             std::list&lt;int&gt;::const_iterator nucIt = sourceChars-&gt;begin();
<a name="l01311"></a>01311             <span class="keyword">const</span> NxsDiscreteStateRow &amp; sourceRow = dnaBlock-&gt;discreteMatrix.at(taxInd);
<a name="l01312"></a>01312             NxsDiscreteStateRow &amp; destRow = codonsBlock-&gt;discreteMatrix.at(taxInd);
<a name="l01313"></a>01313             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> codonInd = 0; codonInd &lt; ncodons ; ++codonInd)
<a name="l01314"></a>01314                 {
<a name="l01315"></a>01315                 NCL_ASSERT(nucIt != endNucIt);
<a name="l01316"></a>01316                 <span class="keyword">const</span> <span class="keywordtype">int</span> fInd = *nucIt++;
<a name="l01317"></a>01317                 NCL_ASSERT(nucIt != endNucIt);
<a name="l01318"></a>01318                 <span class="keyword">const</span> <span class="keywordtype">int</span> sInd = *nucIt++;
<a name="l01319"></a>01319                 NCL_ASSERT(nucIt != endNucIt);
<a name="l01320"></a>01320                 <span class="keyword">const</span> <span class="keywordtype">int</span> tInd = *nucIt++;
<a name="l01321"></a>01321                 <span class="keywordflow">if</span> (spareNucs)
<a name="l01322"></a>01322                     {
<a name="l01323"></a>01323                     untranslated.erase(fInd);
<a name="l01324"></a>01324                     untranslated.erase(sInd);
<a name="l01325"></a>01325                     untranslated.erase(tInd);
<a name="l01326"></a>01326                     }
<a name="l01327"></a>01327                 <span class="keywordflow">if</span> (fInd &lt; 0 || sInd &lt; 0 || tInd &lt; 0)
<a name="l01328"></a>01328                     destRow[codonInd] = codonMissingState;
<a name="l01329"></a>01329                 <span class="keywordflow">else</span>
<a name="l01330"></a>01330                     {
<a name="l01331"></a>01331                     <span class="keyword">const</span> NxsDiscreteStateCell fb = sourceRow[fInd];
<a name="l01332"></a>01332                     <span class="keyword">const</span> NxsDiscreteStateCell sb = sourceRow[sInd];
<a name="l01333"></a>01333                     <span class="keyword">const</span> NxsDiscreteStateCell tb = sourceRow[tInd];
<a name="l01334"></a>01334                     <span class="keywordflow">if</span> (fb &lt; 0 || sb &lt; 0 || tb &lt; 0 || fb &gt; maxUnambigNucState || sb &gt; maxUnambigNucState || tb &gt; maxUnambigNucState)
<a name="l01335"></a>01335                         destRow[codonInd] = codonMissingState;
<a name="l01336"></a>01336                     <span class="keywordflow">else</span>
<a name="l01337"></a>01337                         destRow[codonInd] = 16*fb + 4*sb + tb;
<a name="l01338"></a>01338                     }
<a name="l01339"></a>01339                 }
<a name="l01340"></a>01340             }
<a name="l01341"></a>01341         }
<a name="l01342"></a>01342     <span class="keywordflow">else</span>
<a name="l01343"></a>01343         {
<a name="l01344"></a>01344         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;NewCodonsCharactersBlock is not implemented for cases in which you are not mapping any ambiguity to the missing state code.&quot;</span>);
<a name="l01345"></a>01345         }
<a name="l01346"></a>01346     <span class="keywordflow">if</span> (!untranslated.empty())
<a name="l01347"></a>01347         {
<a name="l01348"></a>01348         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nunt = (<span class="keyword">const</span> unsigned)untranslated.size();
<a name="l01349"></a>01349 
<a name="l01350"></a>01350         <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> * untBlock = <span class="keyword">new</span> <a class="code" href="classNxsCharactersBlock_aecbd5a9f87d5966c8a63acd77a507b67.html#aecbd5a9f87d5966c8a63acd77a507b67" title="In v2.1 of the API, the NxsTaxaBlockAPI and NxsAssumptionsBlockAPI pointers are usually...">NxsCharactersBlock</a>(taxa, NULL);
<a name="l01351"></a>01351         untBlock-&gt;SetNChar(nunt);
<a name="l01352"></a>01352         untBlock-&gt;SetNTax(ntax);
<a name="l01353"></a>01353         untBlock-&gt;missing = dnaBlock-&gt;missing;
<a name="l01354"></a>01354         untBlock-&gt;gap = (gapsToUnknown ? <span class="charliteral">&#39;\0&#39;</span> : dnaBlock-&gt;gap);
<a name="l01355"></a>01355         untBlock-&gt;gapMode = dnaBlock-&gt;gapMode;
<a name="l01356"></a>01356         untBlock-&gt;datatype = nucType;
<a name="l01357"></a>01357         untBlock-&gt;originalDatatype = dnaBlock-&gt;originalDatatype;
<a name="l01358"></a>01358         untBlock-&gt;<a class="code" href="classNxsCharactersBlock_a60329b2e678a91ca6cd46957093e6f56.html#a60329b2e678a91ca6cd46957093e6f56" title="Resets standard symbol set after a change in `datatype&amp;#39; is made.">ResetSymbols</a>();
<a name="l01359"></a>01359         untBlock-&gt;tokens = <span class="keyword">false</span>;
<a name="l01360"></a>01360 
<a name="l01361"></a>01361 
<a name="l01362"></a>01362         untBlock-&gt;CreateDatatypeMapperObjects(dummy, dummyVec);
<a name="l01363"></a>01363         untBlock-&gt;datatypeReadFromFormat = <span class="keyword">false</span>;
<a name="l01364"></a>01364         untBlock-&gt;statesFormat = STATES_PRESENT;
<a name="l01365"></a>01365         untBlock-&gt;restrictionDataype = <span class="keyword">false</span>;
<a name="l01366"></a>01366         untBlock-&gt;supportMixedDatatype = <span class="keyword">false</span>;
<a name="l01367"></a>01367         untBlock-&gt;convertAugmentedToMixed = <span class="keyword">false</span>;
<a name="l01368"></a>01368         untBlock-&gt;writeInterleaveLen = INT_MAX;
<a name="l01369"></a>01369 
<a name="l01370"></a>01370 
<a name="l01371"></a>01371         NxsDiscreteStateRow umatRow(nunt, 0);
<a name="l01372"></a>01372         untBlock-&gt;discreteMatrix.assign(ntax, umatRow);
<a name="l01373"></a>01373         <span class="keywordflow">if</span> (mapPartialAmbigToUnknown &amp;&amp; (gapsToUnknown || dnaBlock-&gt;<a class="code" href="classNxsCharactersBlock_a25f1d2be3465fd9dafb97be50d8e2601.html#a25f1d2be3465fd9dafb97be50d8e2601" title="Returns the gap symbol currently in effect.">GetGapSymbol</a>() != <span class="charliteral">&#39;\0&#39;</span>))
<a name="l01374"></a>01374             {
<a name="l01375"></a>01375             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> taxInd = 0; taxInd &lt; ntax; ++taxInd)
<a name="l01376"></a>01376                 {
<a name="l01377"></a>01377                 <span class="keyword">const</span> NxsDiscreteStateRow &amp; sourceRow = dnaBlock-&gt;discreteMatrix.at(taxInd);
<a name="l01378"></a>01378                 NxsDiscreteStateRow &amp; destRow = untBlock-&gt;discreteMatrix.at(taxInd);
<a name="l01379"></a>01379                 <span class="keywordtype">unsigned</span> untIndex = 0;
<a name="l01380"></a>01380                 <span class="keywordflow">for</span> (NxsUnsignedSet::const_iterator uIt  = untranslated.begin(); uIt != untranslated.end() ; ++uIt, ++untIndex)
<a name="l01381"></a>01381                     {
<a name="l01382"></a>01382                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ind = *uIt;
<a name="l01383"></a>01383                     destRow.at(untIndex) = sourceRow[ind];
<a name="l01384"></a>01384                     }
<a name="l01385"></a>01385                 }
<a name="l01386"></a>01386             }
<a name="l01387"></a>01387         <span class="keywordflow">else</span>
<a name="l01388"></a>01388             {
<a name="l01389"></a>01389             <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;NewProteinCharactersBlock is not implemented for cases in which you are not mapping any ambiguity to the missing state code.&quot;</span>);
<a name="l01390"></a>01390             }
<a name="l01391"></a>01391         *spareNucs = untBlock;
<a name="l01392"></a>01392         }
<a name="l01393"></a>01393     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (spareNucs)
<a name="l01394"></a>01394         *spareNucs = NULL;
<a name="l01395"></a>01395     <span class="keywordflow">return</span> codonsBlock;
<a name="l01396"></a>01396 }
<a name="l01397"></a>01397 
<a name="l01398"></a>01398 
<a name="l01399"></a><a class="code" href="classNxsTransformationManager_a5358cec2c0cd5416076603d3a4313ea6.html#a5358cec2c0cd5416076603d3a4313ea6">01399</a> std::vector&lt;double&gt;  <a class="code" href="classNxsTransformationManager_a5358cec2c0cd5416076603d3a4313ea6.html#a5358cec2c0cd5416076603d3a4313ea6">NxsTransformationManager::GetDoubleWeights</a>(<span class="keyword">const</span> std::string &amp;set_name)<span class="keyword"> const</span>
<a name="l01400"></a>01400 <span class="keyword">    </span>{
<a name="l01401"></a>01401     std::vector&lt;double&gt; r;
<a name="l01402"></a>01402     <span class="keyword">const</span> ListOfDblWeights *p = 0L;
<a name="l01403"></a>01403     std::map&lt;std::string, ListOfDblWeights&gt;::const_iterator dIt = dblWtSets.begin();
<a name="l01404"></a>01404     <span class="keywordflow">for</span> (; dIt != dblWtSets.end(); ++dIt)
<a name="l01405"></a>01405         {
<a name="l01406"></a>01406         <span class="keywordflow">if</span> (NxsString::case_insensitive_equals(dIt-&gt;first.c_str(), set_name.c_str()))
<a name="l01407"></a>01407             {
<a name="l01408"></a>01408             p = &amp;(dIt-&gt;second);
<a name="l01409"></a>01409             <span class="keywordflow">break</span>;
<a name="l01410"></a>01410             }
<a name="l01411"></a>01411         }
<a name="l01412"></a>01412     <span class="keywordflow">if</span> (p)
<a name="l01413"></a>01413         {
<a name="l01414"></a>01414         ListOfDblWeights::const_iterator wIt = p-&gt;begin();
<a name="l01415"></a>01415         <span class="keyword">const</span> ListOfDblWeights::const_iterator ewIt = p-&gt;end();
<a name="l01416"></a>01416         <span class="keywordflow">for</span> (; wIt != ewIt; ++wIt)
<a name="l01417"></a>01417             {
<a name="l01418"></a>01418             <span class="keywordtype">double</span> w = wIt-&gt;first;
<a name="l01419"></a>01419             <span class="keyword">const</span> std::set&lt;unsigned&gt; &amp;s = wIt-&gt;second;
<a name="l01420"></a>01420             std::set&lt;unsigned&gt;::const_reverse_iterator ip = s.rbegin();
<a name="l01421"></a>01421             <span class="keyword">const</span> std::set&lt;unsigned&gt;::const_reverse_iterator e = s.rend();
<a name="l01422"></a>01422             <span class="keywordflow">for</span> (; ip != e; ++ip)
<a name="l01423"></a>01423                 {
<a name="l01424"></a>01424                 <span class="keywordflow">if</span> (*ip &gt;= r.size())
<a name="l01425"></a>01425                     r.resize(1 + *ip, 1.0);
<a name="l01426"></a>01426                 r[*ip] = w;
<a name="l01427"></a>01427                 }
<a name="l01428"></a>01428             }
<a name="l01429"></a>01429         }
<a name="l01430"></a>01430     <span class="keywordflow">return</span> r;
<a name="l01431"></a>01431     }
<a name="l01432"></a>01432 
<a name="l01433"></a><a class="code" href="classNxsTransformationManager_a79d34a3cfc414f63690669a481707f9e.html#a79d34a3cfc414f63690669a481707f9e">01433</a> std::vector&lt;int&gt; <a class="code" href="classNxsTransformationManager_a79d34a3cfc414f63690669a481707f9e.html#a79d34a3cfc414f63690669a481707f9e">NxsTransformationManager::GetIntWeights</a>(<span class="keyword">const</span> std::string &amp;set_name)<span class="keyword"> const</span>
<a name="l01434"></a>01434 <span class="keyword">    </span>{
<a name="l01435"></a>01435     std::vector&lt;int&gt; r;
<a name="l01436"></a>01436     <span class="keyword">const</span> ListOfIntWeights *p = 0L;
<a name="l01437"></a>01437     std::map&lt;std::string, ListOfIntWeights&gt;::const_iterator dIt = intWtSets.begin();
<a name="l01438"></a>01438     <span class="keywordflow">for</span> (; dIt != intWtSets.end(); ++dIt)
<a name="l01439"></a>01439         {
<a name="l01440"></a>01440         <span class="keywordflow">if</span> (NxsString::case_insensitive_equals(dIt-&gt;first.c_str(), set_name.c_str()))
<a name="l01441"></a>01441             {
<a name="l01442"></a>01442             p = &amp;(dIt-&gt;second);
<a name="l01443"></a>01443             <span class="keywordflow">break</span>;
<a name="l01444"></a>01444             }
<a name="l01445"></a>01445         }
<a name="l01446"></a>01446     <span class="keywordflow">if</span> (p)
<a name="l01447"></a>01447         {
<a name="l01448"></a>01448         ListOfIntWeights::const_iterator wIt = p-&gt;begin();
<a name="l01449"></a>01449         <span class="keyword">const</span> ListOfIntWeights::const_iterator ewIt = p-&gt;end();
<a name="l01450"></a>01450         <span class="keywordflow">for</span> (; wIt != ewIt; ++wIt)
<a name="l01451"></a>01451             {
<a name="l01452"></a>01452             <span class="keywordtype">int</span> w = wIt-&gt;first;
<a name="l01453"></a>01453             <span class="keyword">const</span> std::set&lt;unsigned&gt; &amp;s = wIt-&gt;second;
<a name="l01454"></a>01454             std::set&lt;unsigned&gt;::const_reverse_iterator ip = s.rbegin();
<a name="l01455"></a>01455             <span class="keyword">const</span> std::set&lt;unsigned&gt;::const_reverse_iterator e = s.rend();
<a name="l01456"></a>01456             <span class="keywordflow">for</span> (; ip != e; ++ip)
<a name="l01457"></a>01457                 {
<a name="l01458"></a>01458                 <span class="keywordflow">if</span> (*ip &gt;= r.size())
<a name="l01459"></a>01459                     r.resize(1 + *ip, 1);
<a name="l01460"></a>01460                 r[*ip] = w;
<a name="l01461"></a>01461                 }
<a name="l01462"></a>01462             }
<a name="l01463"></a>01463         }
<a name="l01464"></a>01464     <span class="keywordflow">return</span> r;
<a name="l01465"></a>01465     }
<a name="l01466"></a>01466 
<a name="l01470"></a><a class="code" href="classNxsDiscreteDatatypeMapper_af64f1780522557fd5c026472c87cfdb8.html#af64f1780522557fd5c026472c87cfdb8">01470</a> <a class="code" href="classNxsDiscreteDatatypeMapper_a6eac6a70f5c2eb5ffaa67300f830a467.html#a6eac6a70f5c2eb5ffaa67300f830a467" title="creates a standard datatype mapper (symbols &amp;quot;01&amp;quot; and no gaps or equates)...">NxsDiscreteDatatypeMapper::NxsDiscreteDatatypeMapper</a>(
<a name="l01471"></a>01471     <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290c" title="values used to represent different basic types of data stored in a CHARACTERS block...">NxsCharactersBlock::DataTypesEnum</a> datatypeE,
<a name="l01472"></a>01472     <span class="keyword">const</span> std::string &amp; symbolsStr,
<a name="l01473"></a>01473     <span class="keywordtype">char</span> missingChar,
<a name="l01474"></a>01474     <span class="keywordtype">char</span> gap,
<a name="l01475"></a>01475     <span class="keywordtype">char</span> matchingChar,
<a name="l01476"></a>01476     <span class="keywordtype">bool</span> respectingCase,
<a name="l01477"></a>01477     <span class="keyword">const</span> std::map&lt;char, NxsString&gt; &amp; moreEquates)
<a name="l01478"></a>01478     :geneticCode(NXS_GCODE_NO_CODE),
<a name="l01479"></a>01479     cLookup(NULL),
<a name="l01480"></a>01480     stateCodeLookupPtr(NULL),
<a name="l01481"></a>01481     symbols(symbolsStr),
<a name="l01482"></a>01482     nStates(0),
<a name="l01483"></a>01483     matchChar(matchingChar),
<a name="l01484"></a>01484     gapChar(gap),
<a name="l01485"></a>01485     missing(missingChar),
<a name="l01486"></a>01486     respectCase(respectingCase),
<a name="l01487"></a>01487     extraEquates(moreEquates),
<a name="l01488"></a>01488     datatype(datatypeE),
<a name="l01489"></a>01489     restrictionDataype(false),
<a name="l01490"></a>01490     userDefinedEquatesBeforeConversion(false)
<a name="l01491"></a>01491     {
<a name="l01492"></a>01492     <span class="keywordflow">if</span> (symbols.empty())
<a name="l01493"></a>01493         symbols = NxsCharactersBlock::GetDefaultSymbolsForType(datatype);
<a name="l01494"></a>01494     <span class="keywordflow">if</span> (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca53544b6c478de9117d5e98a66e5f20d1" title="indicates `matrix&amp;#39; holds continuous data">NxsCharactersBlock::mixed</a>)
<a name="l01495"></a>01495         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Cannot create a mixed datatype mapper&quot;</span>); <span class="comment">// this should be the only empty string-generating datatype</span>
<a name="l01496"></a>01496     RefreshMappings(0L);
<a name="l01497"></a>01497     }
<a name="l01498"></a>01498 
<a name="l01499"></a>01499 <span class="keywordtype">void</span> NxsDiscreteDatatypeMapper::DebugPrint(std::ostream &amp; out)<span class="keyword"> const</span>
<a name="l01500"></a>01500 <span class="keyword">    </span>{
<a name="l01501"></a>01501     out &lt;&lt; GetNumStatesIncludingGap() &lt;&lt; <span class="stringliteral">&quot;states (&quot;</span>;
<a name="l01502"></a>01502     <span class="keywordflow">if</span> (gapChar == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l01503"></a>01503         out &lt;&lt; <span class="stringliteral">&quot;no gaps&quot;</span>;
<a name="l01504"></a>01504     <span class="keywordflow">else</span>
<a name="l01505"></a>01505         out &lt;&lt; <span class="stringliteral">&quot;including the gap \&quot;state\&quot;&quot;</span>;
<a name="l01506"></a>01506     <span class="keyword">const</span> <span class="keywordtype">int</span> nsc = (int) stateSetsVec.size();
<a name="l01507"></a>01507     out &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; nsc &lt;&lt; <span class="stringliteral">&quot; state codes.\n&quot;</span>;
<a name="l01508"></a>01508     out &lt;&lt; <span class="stringliteral">&quot;NEXUS     State Code      States\n&quot;</span>;
<a name="l01509"></a>01509     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> sc = sclOffset; sc &lt; sclOffset + nsc; ++sc)
<a name="l01510"></a>01510         {
<a name="l01511"></a>01511         std::string nex;
<a name="l01512"></a>01512         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c = 0; c &lt; 127; ++c)
<a name="l01513"></a>01513             {
<a name="l01514"></a>01514             <span class="keywordflow">if</span> (cLookup[c] == sc)
<a name="l01515"></a>01515                 nex.append(1, (<span class="keywordtype">char</span>) c);
<a name="l01516"></a>01516             }
<a name="l01517"></a>01517         <span class="keywordtype">int</span> buf =  (int) (10 - nex.size());
<a name="l01518"></a>01518         nex.append(buf, <span class="charliteral">&#39; &#39;</span>);
<a name="l01519"></a>01519         out &lt;&lt; nex &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; sc &lt;&lt; <span class="stringliteral">&quot;     &quot;</span>;
<a name="l01520"></a>01520         <span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt;    &amp;ss = <a class="code" href="classNxsDiscreteDatatypeMapper_ad39cdce419be460c3a197dfa07a96c80.html#ad39cdce419be460c3a197dfa07a96c80" title="Returns the set of state indices that correspond to the states of state code `c`...">GetStateSetForCode</a>(sc);
<a name="l01521"></a>01521         std::string decoded;
<a name="l01522"></a>01522         <span class="keywordflow">for</span> (std::set&lt;NxsDiscreteStateCell&gt;::const_iterator s = ss.begin(); s != ss.end(); ++s)
<a name="l01523"></a>01523             decoded.append(<a class="code" href="classNxsDiscreteDatatypeMapper_ab8641f24c773df5d85b862c854fd705e.html#ab8641f24c773df5d85b862c854fd705e" title="Returns the NEXUS reperesenation of the state code `scode` which may be a multiple...">StateCodeToNexusString</a>(*s));
<a name="l01524"></a>01524         <span class="keywordflow">if</span> (decoded.length() &lt; 2)
<a name="l01525"></a>01525             out &lt;&lt; decoded;
<a name="l01526"></a>01526         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classNxsDiscreteDatatypeMapper_afe4f8b3edb65863211bcd5a2746215e3.html#afe4f8b3edb65863211bcd5a2746215e3" title="Returns true if the state code maps to a collection of states that were flagged as...">IsPolymorphic</a>(sc))
<a name="l01527"></a>01527             out &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; decoded &lt;&lt; <span class="charliteral">&#39;)&#39;</span>;
<a name="l01528"></a>01528         <span class="keywordflow">else</span>
<a name="l01529"></a>01529             out &lt;&lt; <span class="charliteral">&#39;{&#39;</span> &lt;&lt; decoded &lt;&lt; <span class="charliteral">&#39;}&#39;</span>;
<a name="l01530"></a>01530         out &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l01531"></a>01531         }
<a name="l01532"></a>01532     }
<a name="l01533"></a>01533 
<a name="l01538"></a>01538 <span class="keywordtype">void</span> NxsCharactersBlock::CreateDatatypeMapperObjects(<span class="keyword">const</span> NxsPartition &amp; dtParts, <span class="keyword">const</span> std::vector&lt;DataTypesEnum&gt; &amp; dtcodes)
<a name="l01539"></a>01539     {
<a name="l01540"></a>01540     <span class="keywordflow">try</span> {
<a name="l01541"></a>01541         mixedTypeMapping.clear();
<a name="l01542"></a>01542         <span class="keywordflow">if</span> (datatype != <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca53544b6c478de9117d5e98a66e5f20d1" title="indicates `matrix&amp;#39; holds continuous data">mixed</a>)
<a name="l01543"></a>01543             {
<a name="l01544"></a>01544             <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> d(datatype, symbols, missing, gap, matchchar, respectingCase, userEquates);
<a name="l01545"></a>01545             datatype = d.GetDatatype();
<a name="l01546"></a>01546             DatatypeMapperAndIndexSet das(d, NxsUnsignedSet());
<a name="l01547"></a>01547             datatypeMapperVec.clear();
<a name="l01548"></a>01548             datatypeMapperVec.push_back(das);
<a name="l01549"></a>01549             }
<a name="l01550"></a>01550         <span class="keywordflow">else</span>
<a name="l01551"></a>01551             {
<a name="l01552"></a>01552             datatypeMapperVec.clear();
<a name="l01553"></a>01553             NCL_ASSERT(dtParts.size() == dtcodes.size());
<a name="l01554"></a>01554             datatypeMapperVec.reserve(dtParts.size());
<a name="l01555"></a>01555             std::vector&lt;DataTypesEnum&gt;::const_iterator cIt = dtcodes.begin();
<a name="l01556"></a>01556             <span class="comment">//@@@TMP add code to fill  DataTypesEnum -&gt; NxsUnsignedSet map  here ! for DZ and DS.</span>
<a name="l01557"></a>01557             <span class="keywordflow">for</span> (NxsPartition::const_iterator pIt = dtParts.begin(); pIt != dtParts.end(); ++pIt, ++cIt)
<a name="l01558"></a>01558                 {
<a name="l01559"></a>01559                 std::string mt;
<a name="l01560"></a>01560                 <span class="keywordflow">if</span> (*cIt == standard)
<a name="l01561"></a>01561                     mt.assign(<span class="stringliteral">&quot;0123456789&quot;</span>); <span class="comment">/*mrbayes is the only program to support MIXED and it uses a default (not extendable) symbols list of 0123456789 rather than 01*/</span>
<a name="l01562"></a>01562                 <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> d(*cIt, mt, missing, gap, matchchar, respectingCase, userEquates);
<a name="l01563"></a>01563                 <span class="keyword">const</span> NxsUnsignedSet &amp; indexSet = pIt-&gt;second;
<a name="l01564"></a>01564                 DatatypeMapperAndIndexSet das(d, pIt-&gt;second);
<a name="l01565"></a>01565                 NxsUnsignedSet &amp; mappedInds =  mixedTypeMapping[*cIt];
<a name="l01566"></a>01566                 mappedInds.insert(indexSet.begin(), indexSet.end());
<a name="l01567"></a>01567                 datatypeMapperVec.push_back(das);
<a name="l01568"></a>01568                 }
<a name="l01569"></a>01569             }
<a name="l01570"></a>01570         }
<a name="l01571"></a>01571     <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a> &amp; x)
<a name="l01572"></a>01572         {
<a name="l01573"></a>01573         std::string y = <span class="stringliteral">&quot;An error was detected while trying to create a datatype mapping structure.  This portion of code tends to generate cryptic error messages, so if the following message is not helpful, double check the syntax in the FORMAT command of your block.\n&quot;</span>;
<a name="l01574"></a>01574         y.append(x.msg);
<a name="l01575"></a>01575         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(y, x.pos, x.line, x.col);
<a name="l01576"></a>01576         }
<a name="l01577"></a>01577     }
<a name="l01578"></a>01578 
<a name="l01579"></a>01579 
<a name="l01580"></a>01580 
<a name="l01581"></a>01581 
<a name="l01606"></a><a class="code" href="classNxsCharactersBlock_a93339ad34ae1c95b7fc91b9a02ab9d5a.html#a93339ad34ae1c95b7fc91b9a02ab9d5a">01606</a> <span class="keywordtype">bool</span> <a class="code" href="classNxsCharactersBlock_a93339ad34ae1c95b7fc91b9a02ab9d5a.html#a93339ad34ae1c95b7fc91b9a02ab9d5a" title="If you say FORMAT DATATYPE=DNA SYMBOLS=&amp;quot;01&amp;quot; ; then the valid symbols become...">NxsCharactersBlock::AugmentedSymbolsToMixed</a>()
<a name="l01607"></a>01607     {
<a name="l01608"></a>01608     <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290c" title="values used to represent different basic types of data stored in a CHARACTERS block...">DataTypesEnum</a> odt = <a class="code" href="classNxsCharactersBlock_a1feb957ad6d097cc94337d7f57776bb9.html#a1feb957ad6d097cc94337d7f57776bb9" title="Returns datatype listed in the CHARACTERS block.">GetOriginalDataType</a>();
<a name="l01609"></a>01609     <span class="keywordflow">if</span> (IsMixedType() || (odt == <a class="code" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&amp;#39; from the datatype mapper.">GetDataType</a>()))
<a name="l01610"></a>01610         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01611"></a>01611     <span class="keyword">const</span> std::string origSymb = GetDefaultSymbolsForType(odt);
<a name="l01612"></a>01612     <span class="keyword">const</span> std::string cutSymb = symbols.substr(0, origSymb.length());
<a name="l01613"></a>01613     <span class="keywordflow">if</span> (origSymb != cutSymb)
<a name="l01614"></a>01614         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01615"></a>01615     <span class="keyword">const</span> std::string augmentSymbols = symbols.substr(origSymb.length());
<a name="l01616"></a>01616     <span class="keywordflow">if</span> (augmentSymbols.empty())
<a name="l01617"></a>01617         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01618"></a>01618     <span class="keywordflow">for</span> (std::string::const_iterator a = augmentSymbols.begin(); a != augmentSymbols.end(); ++a)
<a name="l01619"></a>01619         {
<a name="l01620"></a>01620         <span class="keywordflow">if</span> (!isdigit(*a))
<a name="l01621"></a>01621             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01622"></a>01622         }
<a name="l01623"></a>01623 
<a name="l01624"></a>01624     NxsUnsignedSet stdTypeChars;
<a name="l01625"></a>01625     NxsUnsignedSet origTypeChars;
<a name="l01626"></a>01626     std::set&lt;NxsDiscreteStateCell&gt; torigStateInds;
<a name="l01627"></a>01627     std::set&lt;NxsDiscreteStateCell&gt; tstdStateInds;
<a name="l01628"></a>01628     torigStateInds.insert(NXS_GAP_STATE_CODE);
<a name="l01629"></a>01629     tstdStateInds.insert(NXS_GAP_STATE_CODE);
<a name="l01630"></a>01630     <span class="keywordflow">for</span> (NxsDiscreteStateCell j = 0; j &lt; (NxsDiscreteStateCell)origSymb.length(); ++j)
<a name="l01631"></a>01631         torigStateInds.insert(j);
<a name="l01632"></a>01632     <span class="keywordflow">for</span> (NxsDiscreteStateCell j =  (NxsDiscreteStateCell)origSymb.length(); j &lt; (NxsDiscreteStateCell)symbols.length(); ++j)
<a name="l01633"></a>01633         tstdStateInds.insert(j);
<a name="l01634"></a>01634     <span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt; origStateInds(torigStateInds);
<a name="l01635"></a>01635     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nosi = (unsigned)origStateInds.size();
<a name="l01636"></a>01636     <span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt; stdStateInds(tstdStateInds);
<a name="l01637"></a>01637     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nssi = (unsigned)stdStateInds.size();
<a name="l01638"></a>01638 
<a name="l01639"></a>01639     <span class="comment">/*Check each column for patterns that can not be mapped to origSymb or augmentSymbols */</span>
<a name="l01640"></a>01640     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nChars = <a class="code" href="classNxsCharactersBlock_a5f984e07256fa1055b04210484301046.html#a5f984e07256fa1055b04210484301046">GetNCharTotal</a>();
<a name="l01641"></a>01641     GapModeEnum cached_gap_mode = this-&gt;gapMode;
<a name="l01642"></a>01642     this-&gt;gapMode = GAP_MODE_NEWSTATE;
<a name="l01643"></a>01643     <span class="keywordflow">try</span> {
<a name="l01644"></a>01644         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> colIndex = 0; colIndex &lt; nChars; ++colIndex)
<a name="l01645"></a>01645             {
<a name="l01646"></a>01646             <span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt; cs = <a class="code" href="classNxsCharactersBlock_abfbe1a4ecf6cd80703e0979473d0fcb6.html#abfbe1a4ecf6cd80703e0979473d0fcb6" title="Behaves like GetMaximalStateSetOfColumn except that missing data columns do not increase...">GetNamedStateSetOfColumn</a>(colIndex);
<a name="l01647"></a>01647             std::set&lt;NxsDiscreteStateCell&gt; origUnion;
<a name="l01648"></a>01648             set_union(origStateInds.begin(), origStateInds.end(), cs.begin(), cs.end(), inserter(origUnion, origUnion.begin()));
<a name="l01649"></a>01649             <span class="keywordflow">if</span> (origUnion.size() &gt; nosi)
<a name="l01650"></a>01650                 {
<a name="l01651"></a>01651                 std::set&lt;NxsDiscreteStateCell&gt; stdUnion;
<a name="l01652"></a>01652                 set_union(stdStateInds.begin(), stdStateInds.end(), cs.begin(), cs.end(), inserter(stdUnion, stdUnion.begin()));
<a name="l01653"></a>01653                 <span class="keywordflow">if</span> (stdUnion.size() &gt; nssi)
<a name="l01654"></a>01654                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01655"></a>01655                 stdTypeChars.insert(colIndex);
<a name="l01656"></a>01656                 }
<a name="l01657"></a>01657             <span class="keywordflow">else</span>
<a name="l01658"></a>01658                 origTypeChars.insert(colIndex);
<a name="l01659"></a>01659             }
<a name="l01660"></a>01660         }
<a name="l01661"></a>01661     <span class="keywordflow">catch</span> (...)
<a name="l01662"></a>01662         {
<a name="l01663"></a>01663         this-&gt;gapMode = cached_gap_mode;
<a name="l01664"></a>01664         <span class="keywordflow">throw</span>;
<a name="l01665"></a>01665         }
<a name="l01666"></a>01666     this-&gt;gapMode = cached_gap_mode;
<a name="l01667"></a>01667     <span class="comment">/* If we get here then the mapping to mixed type will succeed */</span>
<a name="l01668"></a>01668 
<a name="l01669"></a>01669     <span class="comment">/* copy the incoming matrix and mapper */</span>
<a name="l01670"></a>01670     VecDatatypeMapperAndIndexSet mdm = datatypeMapperVec;
<a name="l01671"></a>01671     <span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> &amp; oldMapper = mdm[0].first;
<a name="l01672"></a>01672     <span class="keywordflow">if</span> (oldMapper.GetUserDefinedEquatesBeforeConversion())
<a name="l01673"></a>01673         <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">/* dealing with equates correctly is not implemented below, so we&#39;ll bale out */</span>
<a name="l01674"></a>01674 
<a name="l01675"></a>01675     <span class="comment">/* add the new mappers */</span>
<a name="l01676"></a>01676     std::map&lt;char, NxsString&gt; noEquates;
<a name="l01677"></a>01677     datatypeMapperVec.clear();
<a name="l01678"></a>01678     <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> o(odt, origSymb, missing, gap, matchchar, respectingCase, noEquates);
<a name="l01679"></a>01679     datatypeMapperVec.push_back(DatatypeMapperAndIndexSet(o, origTypeChars));
<a name="l01680"></a>01680     <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> s(NxsCharactersBlock::standard, augmentSymbols, missing, gap, matchchar, respectingCase, noEquates);
<a name="l01681"></a>01681     datatypeMapperVec.push_back(DatatypeMapperAndIndexSet(s, stdTypeChars));
<a name="l01682"></a>01682 
<a name="l01683"></a>01683 
<a name="l01684"></a>01684     <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> &amp; newOrigTMapper = datatypeMapperVec[0].first;
<a name="l01685"></a>01685     <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> &amp; newStdTMapper = datatypeMapperVec[1].first;
<a name="l01686"></a>01686 
<a name="l01687"></a>01687     <span class="comment">/* now we recode discrete matrix with new state codes */</span>
<a name="l01688"></a>01688     <span class="keyword">const</span> NxsDiscreteStateCell nOrigStates = (NxsDiscreteStateCell) origSymb.size();
<a name="l01689"></a>01689     std::map&lt;NxsDiscreteStateCell, NxsDiscreteStateCell&gt; oldToNewStateCode;
<a name="l01690"></a>01690     NxsDiscreteStateMatrix::iterator rowIt = discreteMatrix.begin();
<a name="l01691"></a>01691     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> colIndex = 0; rowIt != discreteMatrix.end(); ++colIndex, ++rowIt)
<a name="l01692"></a>01692         {
<a name="l01693"></a>01693         NxsDiscreteStateRow &amp; row = *rowIt;
<a name="l01694"></a>01694         <span class="keywordtype">unsigned</span> column = 0;
<a name="l01695"></a>01695         <span class="keywordflow">for</span> (NxsDiscreteStateRow::iterator cell = row.begin(); cell != row.end(); ++cell, ++column)
<a name="l01696"></a>01696             {
<a name="l01697"></a>01697             <span class="keyword">const</span> NxsDiscreteStateCell initStateCode = *cell;
<a name="l01698"></a>01698             <span class="keywordflow">if</span> (initStateCode  &gt;= 0 ) <span class="comment">//gap and missing codes do not need translation</span>
<a name="l01699"></a>01699                 {
<a name="l01700"></a>01700                 std::map&lt;NxsDiscreteStateCell, NxsDiscreteStateCell&gt;::const_iterator otnIt = oldToNewStateCode.find(initStateCode);
<a name="l01701"></a>01701                 <span class="keywordflow">if</span> (otnIt == oldToNewStateCode.end())
<a name="l01702"></a>01702                     {
<a name="l01703"></a>01703                     <span class="keyword">const</span> <span class="keywordtype">bool</span> isOrigT = origTypeChars.count(column) &gt; 0;
<a name="l01704"></a>01704                     <span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt; oldSymbols = oldMapper.<a class="code" href="classNxsDiscreteDatatypeMapper_ad39cdce419be460c3a197dfa07a96c80.html#ad39cdce419be460c3a197dfa07a96c80" title="Returns the set of state indices that correspond to the states of state code `c`...">GetStateSetForCode</a>(initStateCode);
<a name="l01705"></a>01705                     <span class="keyword">const</span> std::string oldNexusString = oldMapper.<a class="code" href="classNxsDiscreteDatatypeMapper_ab8641f24c773df5d85b862c854fd705e.html#ab8641f24c773df5d85b862c854fd705e" title="Returns the NEXUS reperesenation of the state code `scode` which may be a multiple...">StateCodeToNexusString</a>(initStateCode);
<a name="l01706"></a>01706                     <span class="keyword">const</span> <span class="keywordtype">char</span> oldNexusChar = (oldNexusString.length() == 1 ? oldNexusString[0] : <span class="charliteral">&#39;\0&#39;</span>);
<a name="l01707"></a>01707                     <span class="keyword">const</span> <span class="keywordtype">bool</span> isPoly =  oldMapper.<a class="code" href="classNxsDiscreteDatatypeMapper_afe4f8b3edb65863211bcd5a2746215e3.html#afe4f8b3edb65863211bcd5a2746215e3" title="Returns true if the state code maps to a collection of states that were flagged as...">IsPolymorphic</a>(initStateCode);
<a name="l01708"></a>01708                     NxsDiscreteStateCell newStateCode ;
<a name="l01709"></a>01709                     <span class="keywordflow">if</span> (isOrigT)
<a name="l01710"></a>01710                         { <span class="comment">//old symbol indices will still be the new symbol indices</span>
<a name="l01711"></a>01711                         newStateCode = newOrigTMapper.<a class="code" href="classNxsDiscreteDatatypeMapper_a0e253cf7f7452d69062071932644df4a.html#a0e253cf7f7452d69062071932644df4a" title="Returns the state code of a (possible new state set) `sset`.">StateCodeForStateSet</a>(oldSymbols, isPoly, <span class="keyword">true</span>, oldNexusChar);
<a name="l01712"></a>01712                         newOrigTMapper.<a class="code" href="classNxsDiscreteDatatypeMapper_ab8641f24c773df5d85b862c854fd705e.html#ab8641f24c773df5d85b862c854fd705e" title="Returns the NEXUS reperesenation of the state code `scode` which may be a multiple...">StateCodeToNexusString</a>(newStateCode);
<a name="l01713"></a>01713                         }
<a name="l01714"></a>01714                     <span class="keywordflow">else</span>
<a name="l01715"></a>01715                         {
<a name="l01716"></a>01716                         std::set&lt;NxsDiscreteStateCell&gt; transSymbols;
<a name="l01717"></a>01717                         <span class="keywordflow">for</span> (std::set&lt;NxsDiscreteStateCell&gt;::const_iterator sIt = oldSymbols.begin(); sIt != oldSymbols.end(); ++sIt)
<a name="l01718"></a>01718                             {
<a name="l01719"></a>01719                             <span class="keywordflow">if</span> (*sIt &gt;= nOrigStates)
<a name="l01720"></a>01720                                 transSymbols.insert(*sIt - nOrigStates);
<a name="l01721"></a>01721                             <span class="keywordflow">else</span>
<a name="l01722"></a>01722                                 {
<a name="l01723"></a>01723                                 NCL_ASSERT(*sIt &lt; 0);
<a name="l01724"></a>01724                                 transSymbols.insert(*sIt);
<a name="l01725"></a>01725                                 }
<a name="l01726"></a>01726                             }
<a name="l01727"></a>01727                         newStateCode = newStdTMapper.<a class="code" href="classNxsDiscreteDatatypeMapper_a0e253cf7f7452d69062071932644df4a.html#a0e253cf7f7452d69062071932644df4a" title="Returns the state code of a (possible new state set) `sset`.">StateCodeForStateSet</a>(transSymbols, isPoly, <span class="keyword">true</span>, oldNexusChar);
<a name="l01728"></a>01728                         newStdTMapper.<a class="code" href="classNxsDiscreteDatatypeMapper_ab8641f24c773df5d85b862c854fd705e.html#ab8641f24c773df5d85b862c854fd705e" title="Returns the NEXUS reperesenation of the state code `scode` which may be a multiple...">StateCodeToNexusString</a>(newStateCode);
<a name="l01729"></a>01729                         }
<a name="l01730"></a>01730                     oldToNewStateCode[initStateCode] = newStateCode;
<a name="l01731"></a>01731                     *cell = newStateCode;
<a name="l01732"></a>01732                     }
<a name="l01733"></a>01733                 <span class="keywordflow">else</span>
<a name="l01734"></a>01734                     *cell = otnIt-&gt;second;
<a name="l01735"></a>01735                 }
<a name="l01736"></a>01736             }
<a name="l01737"></a>01737         }
<a name="l01738"></a>01738     datatype = <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca53544b6c478de9117d5e98a66e5f20d1" title="indicates `matrix&amp;#39; holds continuous data">NxsCharactersBlock::mixed</a>;
<a name="l01739"></a>01739     mixedTypeMapping.clear();
<a name="l01740"></a>01740     mixedTypeMapping[odt] = origTypeChars;
<a name="l01741"></a>01741     mixedTypeMapping[NxsCharactersBlock::standard] = stdTypeChars;
<a name="l01742"></a>01742     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01743"></a>01743     }
<a name="l01748"></a><a class="code" href="classNxsCharactersBlock_a8fc039e274e43180293b6f0741f5486f.html#a8fc039e274e43180293b6f0741f5486f">01748</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_a8fc039e274e43180293b6f0741f5486f.html#a8fc039e274e43180293b6f0741f5486f" title="Called when FORMAT command needs to be parsed from within the DIMENSIONS block.">NxsCharactersBlock::HandleFormat</a>(
<a name="l01749"></a>01749   <a class="code" href="classNxsToken.html">NxsToken</a> &amp;token)  <span class="comment">/* the token used to read from `in&#39; */</span>
<a name="l01750"></a>01750     {
<a name="l01751"></a>01751     errormsg.<a class="code" href="classNxsString_abbf904c772d9776139dcae602c9fd06b.html#abbf904c772d9776139dcae602c9fd06b" title="Most containers in the standard template library can be completely erased using the...">clear</a>();
<a name="l01752"></a>01752     ProcessedNxsCommand tokenVec;
<a name="l01753"></a>01753     token.<a class="code" href="classNxsToken_af339d0b55c743a874f781e0fe2e3c6c0.html#af339d0b55c743a874f781e0fe2e3c6c0" title="Reads until &amp;quot;;&amp;quot; and fills the vector of ProcessedNxsToken objects.">ProcessAsCommand</a>( &amp;tokenVec);
<a name="l01754"></a>01754 
<a name="l01755"></a>01755     <span class="keyword">const</span> ProcessedNxsCommand::const_iterator tvEnd = tokenVec.end();
<a name="l01756"></a>01756     NxsPartition dtParts;
<a name="l01757"></a>01757     std::vector&lt;DataTypesEnum&gt; dtv;
<a name="l01758"></a>01758     std::vector&lt;bool&gt; isR;
<a name="l01759"></a>01759     <span class="keywordflow">if</span> (!datatypeReadFromFormat)
<a name="l01760"></a>01760         {
<a name="l01761"></a>01761         <span class="keywordtype">bool</span> standardDataTypeAssumed = <span class="keyword">true</span>;
<a name="l01762"></a>01762         <span class="keywordtype">bool</span> ignoreCaseAssumed = <span class="keyword">true</span>;
<a name="l01763"></a>01763         datatype = standard;
<a name="l01764"></a>01764         originalDatatype = standard;
<a name="l01765"></a>01765         <a class="code" href="classNxsCharactersBlock_a60329b2e678a91ca6cd46957093e6f56.html#a60329b2e678a91ca6cd46957093e6f56" title="Resets standard symbol set after a change in `datatype&amp;#39; is made.">ResetSymbols</a>();
<a name="l01766"></a>01766         respectingCase = <span class="keyword">false</span>;
<a name="l01767"></a>01767         restrictionDataype = <span class="keyword">false</span>;
<a name="l01768"></a>01768         <span class="keywordflow">for</span> (ProcessedNxsCommand::const_iterator wIt = tokenVec.begin(); wIt != tvEnd; ++wIt)
<a name="l01769"></a>01769             {
<a name="l01770"></a>01770             <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;DATATYPE&quot;</span>))
<a name="l01771"></a>01771                 {
<a name="l01772"></a>01772                 <a class="code" href="classNxsBlock_aee6771bdd0c70f375d925c4e0b6d1095.html#aee6771bdd0c70f375d925c4e0b6d1095" title="Advances the token, and raise an exception if it is not an equals sign.">DemandEquals</a>(wIt, tvEnd, <span class="stringliteral">&quot; after keyword DATATYPE&quot;</span>);
<a name="l01773"></a>01773                 <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot; after \&quot;DATATYPE =\&quot; in FORMAT command&quot;</span>);
<a name="l01774"></a>01774                 <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;STANDARD&quot;</span>))
<a name="l01775"></a>01775                     {
<a name="l01776"></a>01776                     datatype = standard;
<a name="l01777"></a>01777                     symbols = <span class="stringliteral">&quot;01&quot;</span>;
<a name="l01778"></a>01778                     }
<a name="l01779"></a>01779                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;DNA&quot;</span>))
<a name="l01780"></a>01780                     datatype = <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca0145b9755a4581acaabe1e4c458d7f73" title="indicates `matrix&amp;#39; holds characters with arbitrarily-assigned, discrete states...">dna</a>;
<a name="l01781"></a>01781                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;RNA&quot;</span>))
<a name="l01782"></a>01782                     datatype = <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca9cb7e8ceb8521a96df0b81ecac913814" title="indicates `matrix&amp;#39; holds DNA sequences (states A, C, G, T)">rna</a>;
<a name="l01783"></a>01783                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;NUCLEOTIDE&quot;</span>))
<a name="l01784"></a>01784                     datatype = <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa9ca7e6de7b65840b97d9ecd42c0ad3a" title="indicates `matrix&amp;#39; holds RNA sequences (states A, C, G, U)">nucleotide</a>;
<a name="l01785"></a>01785                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;PROTEIN&quot;</span>))
<a name="l01786"></a>01786                     datatype = <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca6867b9b05a5ce824179b5bdf10c891fc" title="indicates `matrix&amp;#39; holds nucleotide sequences">protein</a>;
<a name="l01787"></a>01787                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;RESTRICTION&quot;</span>))
<a name="l01788"></a>01788                     {
<a name="l01789"></a>01789                     datatype = standard;
<a name="l01790"></a>01790                     restrictionDataype = <span class="keyword">true</span>;
<a name="l01791"></a>01791                     }
<a name="l01792"></a>01792                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;CONTINUOUS&quot;</span>))
<a name="l01793"></a>01793                     {
<a name="l01794"></a>01794                     datatype = <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">continuous</a>;
<a name="l01795"></a>01795                     statesFormat = INDIVIDUALS;
<a name="l01796"></a>01796                     items = std::vector&lt;std::string&gt;(1, std::string(<span class="stringliteral">&quot;AVERAGE&quot;</span>));
<a name="l01797"></a>01797                     tokens = <span class="keyword">true</span>;
<a name="l01798"></a>01798                     }
<a name="l01799"></a>01799                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (supportMixedDatatype &amp;&amp; wIt-&gt;Equals(<span class="stringliteral">&quot;MIXED&quot;</span>))
<a name="l01800"></a>01800                     {
<a name="l01801"></a>01801                     datatype = <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca53544b6c478de9117d5e98a66e5f20d1" title="indicates `matrix&amp;#39; holds continuous data">mixed</a>;
<a name="l01802"></a>01802                     <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot; after \&quot;DATATYPE=MIXED\&quot; in FORMAT command. Expecting (&quot;</span>);
<a name="l01803"></a>01803                     <span class="keywordflow">if</span> (!wIt-&gt;Equals(<span class="stringliteral">&quot;(&quot;</span>))
<a name="l01804"></a>01804                         {
<a name="l01805"></a>01805                         errormsg &lt;&lt; <span class="stringliteral">&quot;Expecting ( after \&quot;DATATYPE=MIXED\&quot; but found &quot;</span> &lt;&lt; wIt-&gt;GetToken();
<a name="l01806"></a>01806                         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *wIt);
<a name="l01807"></a>01807                         }
<a name="l01808"></a>01808                     <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot; after \&quot;DATATYPE=MIXED(\&quot; in FORMAT command. Expecting a datatype&quot;</span>);
<a name="l01809"></a>01809                     ostringstream fakestream;
<a name="l01810"></a>01810                     <span class="keywordflow">while</span> (!wIt-&gt;Equals(<span class="stringliteral">&quot;)&quot;</span>))
<a name="l01811"></a>01811                         {
<a name="l01812"></a>01812                         fakestream &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; NxsString::GetEscaped(wIt-&gt;GetToken());
<a name="l01813"></a>01813                         <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot; in \&quot;DATATYPE=MIXED\&quot; in FORMAT command. Expecting a closing ) to terminate the list.&quot;</span>);
<a name="l01814"></a>01814                         }
<a name="l01815"></a>01815                     fakestream &lt;&lt; <span class="charliteral">&#39;;&#39;</span>;
<a name="l01816"></a>01816                     <span class="keyword">const</span> std::string accumulated = fakestream.str();
<a name="l01817"></a>01817                     istringstream fakeinput(accumulated);
<a name="l01818"></a>01818                     <a class="code" href="classNxsToken.html">NxsToken</a> subToken(fakeinput);
<a name="l01819"></a>01819                     <span class="keywordflow">try</span>
<a name="l01820"></a>01820                         {
<a name="l01821"></a>01821                         std::string mt(<span class="stringliteral">&quot;mixed datatype definition&quot;</span>);
<a name="l01822"></a>01822                         subToken.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l01823"></a>01823                         this-&gt;ReadPartitionDef(dtParts, *<span class="keyword">this</span>, mt, <span class="stringliteral">&quot;Character&quot;</span>, <span class="stringliteral">&quot;Datatype=Mixed&quot;</span>, subToken, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);
<a name="l01824"></a>01824                         }
<a name="l01825"></a>01825                     <span class="keywordflow">catch</span> (<a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a> &amp; x)
<a name="l01826"></a>01826                         {
<a name="l01827"></a>01827                         errormsg = x.msg;
<a name="l01828"></a>01828                         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *wIt);
<a name="l01829"></a>01829                         }
<a name="l01830"></a>01830                     <span class="keywordflow">catch</span> (...)
<a name="l01831"></a>01831                         {
<a name="l01832"></a>01832                         errormsg &lt;&lt; <span class="stringliteral">&quot;Error parsing \&quot;DATATYPE=MIXED\&quot; subcommand in FORMAT the command.&quot;</span>;
<a name="l01833"></a>01833                         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *wIt);
<a name="l01834"></a>01834                         }
<a name="l01835"></a>01835                     <span class="keywordflow">for</span> (NxsPartition::const_iterator pIt = dtParts.begin(); pIt != dtParts.end(); ++pIt)
<a name="l01836"></a>01836                         {
<a name="l01837"></a>01837                         <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> name(pIt-&gt;first.c_str());
<a name="l01838"></a>01838                         name.ToUpper();
<a name="l01839"></a>01839                         <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;RESTRICTION&quot;</span>)
<a name="l01840"></a>01840                             {
<a name="l01841"></a>01841                             dtv.push_back(standard);
<a name="l01842"></a>01842                             isR.push_back(<span class="keyword">true</span>);
<a name="l01843"></a>01843                             }
<a name="l01844"></a>01844                         <span class="keywordflow">else</span>
<a name="l01845"></a>01845                             {
<a name="l01846"></a>01846                             isR.push_back(<span class="keyword">false</span>);
<a name="l01847"></a>01847                             <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;STANDARD&quot;</span>)
<a name="l01848"></a>01848                                 dtv.push_back(standard);
<a name="l01849"></a>01849                             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;DNA&quot;</span>)
<a name="l01850"></a>01850                                 dtv.push_back(<a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca0145b9755a4581acaabe1e4c458d7f73" title="indicates `matrix&amp;#39; holds characters with arbitrarily-assigned, discrete states...">dna</a>);
<a name="l01851"></a>01851                             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;RNA&quot;</span>)
<a name="l01852"></a>01852                                 dtv.push_back(<a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca9cb7e8ceb8521a96df0b81ecac913814" title="indicates `matrix&amp;#39; holds DNA sequences (states A, C, G, T)">rna</a>);
<a name="l01853"></a>01853                             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;NUCLEOTIDE&quot;</span>)
<a name="l01854"></a>01854                                 dtv.push_back(<a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa9ca7e6de7b65840b97d9ecd42c0ad3a" title="indicates `matrix&amp;#39; holds RNA sequences (states A, C, G, U)">nucleotide</a>);
<a name="l01855"></a>01855                             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;PROTEIN&quot;</span>)
<a name="l01856"></a>01856                                 dtv.push_back(<a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca6867b9b05a5ce824179b5bdf10c891fc" title="indicates `matrix&amp;#39; holds nucleotide sequences">protein</a>);
<a name="l01857"></a>01857                             <span class="keywordflow">else</span>
<a name="l01858"></a>01858                                 {
<a name="l01859"></a>01859                                 errormsg &lt;&lt; pIt-&gt;first &lt;&lt;  <span class="stringliteral">&quot; is not a valid DATATYPE within a &quot;</span> &lt;&lt;  <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot; block&quot;</span>;
<a name="l01860"></a>01860                                 <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *wIt);
<a name="l01861"></a>01861                                 }
<a name="l01862"></a>01862                             }
<a name="l01863"></a>01863                         }
<a name="l01864"></a>01864                     }
<a name="l01865"></a>01865                 <span class="keywordflow">else</span>
<a name="l01866"></a>01866                     {
<a name="l01867"></a>01867                     errormsg &lt;&lt; wIt-&gt;GetToken() &lt;&lt;  <span class="stringliteral">&quot; is not a valid DATATYPE within a &quot;</span> &lt;&lt;  <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot; block&quot;</span>;
<a name="l01868"></a>01868                     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *wIt);
<a name="l01869"></a>01869                     }
<a name="l01870"></a>01870                 datatypeReadFromFormat = <span class="keyword">true</span>;
<a name="l01871"></a>01871                 originalDatatype = datatype;
<a name="l01872"></a>01872                 <a class="code" href="classNxsCharactersBlock_a60329b2e678a91ca6cd46957093e6f56.html#a60329b2e678a91ca6cd46957093e6f56" title="Resets standard symbol set after a change in `datatype&amp;#39; is made.">ResetSymbols</a>();
<a name="l01873"></a>01873                 standardDataTypeAssumed = <span class="keyword">false</span>;
<a name="l01874"></a>01874                 <span class="keywordflow">if</span> (!ignoreCaseAssumed)
<a name="l01875"></a>01875                     <span class="keywordflow">break</span>;
<a name="l01876"></a>01876                 }
<a name="l01877"></a>01877             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;RESPECTCASE&quot;</span>))
<a name="l01878"></a>01878                 {
<a name="l01879"></a>01879                 ignoreCaseAssumed = <span class="keyword">false</span>;
<a name="l01880"></a>01880                 respectingCase = <span class="keyword">true</span>;
<a name="l01881"></a>01881                 <span class="keywordflow">if</span> (!standardDataTypeAssumed)
<a name="l01882"></a>01882                     <span class="keywordflow">break</span>;
<a name="l01883"></a>01883                 }
<a name="l01884"></a>01884             }
<a name="l01885"></a>01885         }
<a name="l01886"></a>01886     <span class="keywordflow">for</span> (ProcessedNxsCommand::const_iterator wIt = tokenVec.begin(); wIt != tvEnd; ++wIt)
<a name="l01887"></a>01887         {
<a name="l01888"></a>01888 
<a name="l01889"></a>01889         <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;DATATYPE&quot;</span>))<span class="comment">// we should have already processed this</span>
<a name="l01890"></a>01890             {
<a name="l01891"></a>01891             <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;after DATATYPE in FORMAT command&quot;</span>); <span class="comment">// =</span>
<a name="l01892"></a>01892             <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;after DATATYPE = in FORMAT command&quot;</span>); <span class="comment">// datatype</span>
<a name="l01893"></a>01893             }
<a name="l01894"></a>01894         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;RESPECTCASE&quot;</span>))
<a name="l01895"></a>01895             {
<a name="l01896"></a>01896             <span class="keywordflow">if</span> (!respectingCase)
<a name="l01897"></a>01897                 {
<a name="l01898"></a>01898                 errormsg &lt;&lt; <span class="stringliteral">&quot;Only one FORMAT command should occur per DATA or CHARACTERS block.&quot;</span>;
<a name="l01899"></a>01899                 <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *wIt);
<a name="l01900"></a>01900                 }
<a name="l01901"></a>01901             }
<a name="l01902"></a>01902         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;MISSING&quot;</span>))
<a name="l01903"></a>01903             {
<a name="l01904"></a>01904             <a class="code" href="classNxsBlock_aee6771bdd0c70f375d925c4e0b6d1095.html#aee6771bdd0c70f375d925c4e0b6d1095" title="Advances the token, and raise an exception if it is not an equals sign.">DemandEquals</a>(wIt, tvEnd, <span class="stringliteral">&quot;after keyword MISSING&quot;</span>);
<a name="l01905"></a>01905             <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;after \&quot;MISSING = \&quot; in FORMAT command&quot;</span>);
<a name="l01906"></a>01906             <span class="keyword">const</span> std::string t = wIt-&gt;GetToken();
<a name="l01907"></a>01907             <span class="keywordflow">if</span> (t.length() != 1)
<a name="l01908"></a>01908                 {
<a name="l01909"></a>01909                 errormsg &lt;&lt; <span class="stringliteral">&quot;MISSING symbol should be a single character, but &quot;</span> &lt;&lt; t &lt;&lt; <span class="stringliteral">&quot; was specified&quot;</span>;
<a name="l01910"></a>01910                 WarnDangerousContent(errormsg, *wIt);
<a name="l01911"></a>01911                 }
<a name="l01912"></a>01912             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a0e5bcf6a302bf475420b28036a218b51.html#a0e5bcf6a302bf475420b28036a218b51" title="Returns true if current token is a single character and this character is a punctuation...">IsPunctuationToken</a>(t) &amp;&amp; !token.<a class="code" href="classNxsToken_af75d27ce09e09c66c838ad61e13839f7.html#af75d27ce09e09c66c838ad61e13839f7" title="Returns true if current token is a single character and this character is either...">IsPlusMinusToken</a>(t))
<a name="l01913"></a>01913                 {
<a name="l01914"></a>01914                 errormsg &lt;&lt; <span class="stringliteral">&quot;MISSING symbol specified cannot be a punctuation token (&quot;</span> &lt;&lt; t &lt;&lt; <span class="stringliteral">&quot; was specified)&quot;</span>;
<a name="l01915"></a>01915                 WarnDangerousContent(errormsg, *wIt);
<a name="l01916"></a>01916                 }
<a name="l01917"></a>01917             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_ada43d5e71e16665d7f20874bd6fb6641.html#ada43d5e71e16665d7f20874bd6fb6641" title="Returns true if current token is a single character and this character is a whitespace...">IsWhitespaceToken</a>(t))
<a name="l01918"></a>01918                 {
<a name="l01919"></a>01919                 errormsg &lt;&lt; <span class="stringliteral">&quot;MISSING symbol specified cannot be a whitespace character (&quot;</span> &lt;&lt; t &lt;&lt; <span class="stringliteral">&quot; was specified)&quot;</span>;
<a name="l01920"></a>01920                 WarnDangerousContent(errormsg, *wIt);
<a name="l01921"></a>01921                 }
<a name="l01922"></a>01922             missing = t[0];
<a name="l01923"></a>01923             }
<a name="l01924"></a>01924         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;GAP&quot;</span>))
<a name="l01925"></a>01925             {
<a name="l01926"></a>01926             <a class="code" href="classNxsBlock_aee6771bdd0c70f375d925c4e0b6d1095.html#aee6771bdd0c70f375d925c4e0b6d1095" title="Advances the token, and raise an exception if it is not an equals sign.">DemandEquals</a>(wIt, tvEnd, <span class="stringliteral">&quot;after keyword GAP&quot;</span>);
<a name="l01927"></a>01927             <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;after \&quot;GAP = \&quot; in FORMAT command&quot;</span>);
<a name="l01928"></a>01928             <span class="keyword">const</span> std::string t = wIt-&gt;GetToken();
<a name="l01929"></a>01929             <span class="keywordflow">if</span> (t.length() != 1)
<a name="l01930"></a>01930                 {
<a name="l01931"></a>01931                 errormsg &lt;&lt; <span class="stringliteral">&quot;GAP symbol should be a single character, but &quot;</span> &lt;&lt; t &lt;&lt; <span class="stringliteral">&quot; was specified&quot;</span>;
<a name="l01932"></a>01932                 WarnDangerousContent(errormsg, *wIt);
<a name="l01933"></a>01933                 }
<a name="l01934"></a>01934             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a0e5bcf6a302bf475420b28036a218b51.html#a0e5bcf6a302bf475420b28036a218b51" title="Returns true if current token is a single character and this character is a punctuation...">IsPunctuationToken</a>(t) &amp;&amp; !token.<a class="code" href="classNxsToken_af75d27ce09e09c66c838ad61e13839f7.html#af75d27ce09e09c66c838ad61e13839f7" title="Returns true if current token is a single character and this character is either...">IsPlusMinusToken</a>(t))
<a name="l01935"></a>01935                 {
<a name="l01936"></a>01936                 errormsg &lt;&lt; <span class="stringliteral">&quot;GAP symbol specified cannot be a punctuation token &quot;</span> &lt;&lt; t &lt;&lt; <span class="stringliteral">&quot; was specified&quot;</span>;
<a name="l01937"></a>01937                 WarnDangerousContent(errormsg, *wIt);
<a name="l01938"></a>01938                 }
<a name="l01939"></a>01939             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_ada43d5e71e16665d7f20874bd6fb6641.html#ada43d5e71e16665d7f20874bd6fb6641" title="Returns true if current token is a single character and this character is a whitespace...">IsWhitespaceToken</a>(t))
<a name="l01940"></a>01940                 {
<a name="l01941"></a>01941                 errormsg &lt;&lt; <span class="stringliteral">&quot;GAP symbol specified cannot be a whitespace character &quot;</span> &lt;&lt; t &lt;&lt; <span class="stringliteral">&quot; was specified&quot;</span>;
<a name="l01942"></a>01942                 WarnDangerousContent(errormsg, *wIt);
<a name="l01943"></a>01943                 }
<a name="l01944"></a>01944             gap = t[0];
<a name="l01945"></a>01945             }
<a name="l01946"></a>01946         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;MATCHCHAR&quot;</span>))
<a name="l01947"></a>01947             {
<a name="l01948"></a>01948             <a class="code" href="classNxsBlock_aee6771bdd0c70f375d925c4e0b6d1095.html#aee6771bdd0c70f375d925c4e0b6d1095" title="Advances the token, and raise an exception if it is not an equals sign.">DemandEquals</a>(wIt, tvEnd, <span class="stringliteral">&quot;after keyword MATCHCHAR&quot;</span>);
<a name="l01949"></a>01949             <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;after \&quot;MATCHCHAR = \&quot; in FORMAT command&quot;</span>);
<a name="l01950"></a>01950             <span class="keyword">const</span> std::string t = wIt-&gt;GetToken();
<a name="l01951"></a>01951             <span class="keywordflow">if</span> (t.length() != 1)
<a name="l01952"></a>01952                 {
<a name="l01953"></a>01953                 errormsg &lt;&lt; <span class="stringliteral">&quot;MATCHCHAR symbol should be a single character, but &quot;</span> &lt;&lt; t &lt;&lt; <span class="stringliteral">&quot; was specified&quot;</span>;
<a name="l01954"></a>01954                 WarnDangerousContent(errormsg, *wIt);
<a name="l01955"></a>01955                 }
<a name="l01956"></a>01956             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a0e5bcf6a302bf475420b28036a218b51.html#a0e5bcf6a302bf475420b28036a218b51" title="Returns true if current token is a single character and this character is a punctuation...">IsPunctuationToken</a>(t) &amp;&amp; !token.<a class="code" href="classNxsToken_af75d27ce09e09c66c838ad61e13839f7.html#af75d27ce09e09c66c838ad61e13839f7" title="Returns true if current token is a single character and this character is either...">IsPlusMinusToken</a>(t))
<a name="l01957"></a>01957                 {
<a name="l01958"></a>01958                 errormsg &lt;&lt; <span class="stringliteral">&quot;MATCHCHAR symbol specified cannot be a punctuation token (&quot;</span> &lt;&lt; t &lt;&lt; <span class="stringliteral">&quot; was specified)&quot;</span>;
<a name="l01959"></a>01959                 WarnDangerousContent(errormsg, *wIt);
<a name="l01960"></a>01960                 }
<a name="l01961"></a>01961             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_ada43d5e71e16665d7f20874bd6fb6641.html#ada43d5e71e16665d7f20874bd6fb6641" title="Returns true if current token is a single character and this character is a whitespace...">IsWhitespaceToken</a>(t))
<a name="l01962"></a>01962                 {
<a name="l01963"></a>01963                 errormsg &lt;&lt; <span class="stringliteral">&quot;MATCHCHAR symbol specified cannot be a whitespace character (&quot;</span> &lt;&lt; t &lt;&lt; <span class="stringliteral">&quot; was specified)&quot;</span>;
<a name="l01964"></a>01964                 WarnDangerousContent(errormsg, *wIt);
<a name="l01965"></a>01965                 }
<a name="l01966"></a>01966             matchchar = t[0];
<a name="l01967"></a>01967             }
<a name="l01968"></a>01968         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;SYMBOLS&quot;</span>) || wIt-&gt;Equals(<span class="stringliteral">&quot;SYMBOL&quot;</span>))
<a name="l01969"></a>01969             {
<a name="l01970"></a>01970             <span class="keywordflow">if</span> (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>)
<a name="l01971"></a>01971                 <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;SYMBOLS subcommand not allowed for DATATYPE=CONTINUOUS&quot;</span>, *wIt);
<a name="l01972"></a>01972             <span class="keywordflow">if</span> (restrictionDataype)
<a name="l01973"></a>01973                 <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;SYMBOLS subcommand not allowed for DATATYPE=RESTRICTION&quot;</span>, *wIt);
<a name="l01974"></a>01974             NxsDiscreteStateCell numDefStates;
<a name="l01975"></a>01975             <span class="keywordtype">unsigned</span> maxNewStates = NCL_MAX_STATES;
<a name="l01976"></a>01976             <span class="keywordflow">switch</span>(datatype)
<a name="l01977"></a>01977                 {
<a name="l01978"></a>01978                 <span class="keywordflow">case</span> <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca0145b9755a4581acaabe1e4c458d7f73" title="indicates `matrix&amp;#39; holds characters with arbitrarily-assigned, discrete states...">NxsCharactersBlock::dna</a>:
<a name="l01979"></a>01979                 <span class="keywordflow">case</span> <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca9cb7e8ceb8521a96df0b81ecac913814" title="indicates `matrix&amp;#39; holds DNA sequences (states A, C, G, T)">NxsCharactersBlock::rna</a>:
<a name="l01980"></a>01980                 <span class="keywordflow">case</span> <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa9ca7e6de7b65840b97d9ecd42c0ad3a" title="indicates `matrix&amp;#39; holds RNA sequences (states A, C, G, U)">NxsCharactersBlock::nucleotide</a>:
<a name="l01981"></a>01981                     numDefStates = 4;
<a name="l01982"></a>01982                     maxNewStates = NCL_MAX_STATES-4;
<a name="l01983"></a>01983                     <span class="keywordflow">break</span>;
<a name="l01984"></a>01984 
<a name="l01985"></a>01985                 <span class="keywordflow">case</span> <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca6867b9b05a5ce824179b5bdf10c891fc" title="indicates `matrix&amp;#39; holds nucleotide sequences">NxsCharactersBlock::protein</a>:
<a name="l01986"></a>01986                     numDefStates = 21;
<a name="l01987"></a>01987                     maxNewStates = NCL_MAX_STATES-21;
<a name="l01988"></a>01988                     <span class="keywordflow">break</span>;
<a name="l01989"></a>01989 
<a name="l01990"></a>01990                 <span class="keywordflow">default</span>:
<a name="l01991"></a>01991                     numDefStates = 0; <span class="comment">// replace symbols list for standard datatype</span>
<a name="l01992"></a>01992                     symbols.clear();
<a name="l01993"></a>01993                     maxNewStates = NCL_MAX_STATES;
<a name="l01994"></a>01994                 }
<a name="l01995"></a>01995             <a class="code" href="classNxsBlock_aee6771bdd0c70f375d925c4e0b6d1095.html#aee6771bdd0c70f375d925c4e0b6d1095" title="Advances the token, and raise an exception if it is not an equals sign.">DemandEquals</a>(wIt, tvEnd, <span class="stringliteral">&quot;after keyword SYMBOLS&quot;</span>);
<a name="l01996"></a>01996             <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;\&quot; to start the symbols list&quot;</span>);
<a name="l01997"></a>01997             <span class="keywordflow">if</span> (!wIt-&gt;Equals(<span class="stringliteral">&quot;\&quot;&quot;</span>))
<a name="l01998"></a>01998                 {
<a name="l01999"></a>01999                 errormsg &lt;&lt; <span class="stringliteral">&quot;Expecting \&quot; after Symbols= but &quot;</span> &lt;&lt; wIt-&gt;GetToken() &lt;&lt; <span class="stringliteral">&quot; was found&quot;</span>;
<a name="l02000"></a>02000                 <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *wIt);
<a name="l02001"></a>02001                 }
<a name="l02002"></a>02002             <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;closing \&quot; of symbols list&quot;</span>);
<a name="l02003"></a>02003             <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> s;
<a name="l02004"></a>02004             <span class="keywordflow">while</span> (!wIt-&gt;Equals(<span class="stringliteral">&quot;\&quot;&quot;</span>))
<a name="l02005"></a>02005                 {
<a name="l02006"></a>02006                 s += wIt-&gt;GetToken().c_str();
<a name="l02007"></a>02007                 <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;closing \&quot; of symbols list&quot;</span>);
<a name="l02008"></a>02008                 }
<a name="l02009"></a>02009 
<a name="l02010"></a>02010             <span class="keyword">const</span> std::string tos = <a class="code" href="classNxsString_a3efcad1ffa92a160cdd2210be924265b.html#a3efcad1ffa92a160cdd2210be924265b" title="Strips all whitespace.">NxsString::strip_whitespace</a>(s);
<a name="l02011"></a>02011             <span class="keyword">const</span> <span class="keywordtype">char</span> * to = tos.c_str();
<a name="l02012"></a>02012             <span class="keywordtype">unsigned</span> tlen = (unsigned)tos.length();
<a name="l02013"></a>02013             <span class="keywordflow">if</span> (tlen &gt; maxNewStates)
<a name="l02014"></a>02014                 {
<a name="l02015"></a>02015                 errormsg &lt;&lt; <span class="stringliteral">&quot;SYMBOLS defines &quot;</span> &lt;&lt; tlen &lt;&lt; <span class="stringliteral">&quot; new states but only &quot;</span> &lt;&lt; maxNewStates &lt;&lt; <span class="stringliteral">&quot; new states allowed for this DATATYPE&quot;</span>;
<a name="l02016"></a>02016                 <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *wIt);
<a name="l02017"></a>02017                 }
<a name="l02018"></a>02018             <span class="comment">// Check to make sure user has not used any symbols already in the</span>
<a name="l02019"></a>02019             <span class="comment">// default symbols list for this data type</span>
<a name="l02020"></a>02020             <span class="comment">//</span>
<a name="l02021"></a>02021             std::string preprocessedS;
<a name="l02022"></a>02022             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; tlen; i++)
<a name="l02023"></a>02023                 {
<a name="l02024"></a>02024                 <span class="keywordflow">if</span> (to[i] == <span class="charliteral">&#39;~&#39;</span>)
<a name="l02025"></a>02025                     {
<a name="l02026"></a>02026                     <span class="keywordflow">if</span> (i == 0 || i == tlen -1)
<a name="l02027"></a>02027                         {
<a name="l02028"></a>02028                         errormsg &lt;&lt; <span class="stringliteral">&quot;A ~ in a SYMBOLS list is interpreted as a range of symbols.  The ~ cannot be the first or last character in the symbols list&quot;</span>;
<a name="l02029"></a>02029                         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l02030"></a>02030                         }
<a name="l02031"></a>02031                     <span class="keyword">const</span> <span class="keywordtype">int</span> jj = i - 1 ;
<a name="l02032"></a>02032                     <span class="keyword">const</span> <span class="keywordtype">char</span> prevChar = to[jj];
<a name="l02033"></a>02033                     <span class="keyword">const</span> <span class="keywordtype">char</span> nextChar = to[i+1];
<a name="l02034"></a>02034                     <span class="keywordflow">if</span> ((isdigit(prevChar) &amp;&amp; isdigit(nextChar)) || (isalpha(prevChar) &amp;&amp; isalpha(nextChar)))
<a name="l02035"></a>02035                         {
<a name="l02036"></a>02036                         <span class="keywordflow">if</span> (nextChar &gt; prevChar)
<a name="l02037"></a>02037                             {
<a name="l02038"></a>02038                             <span class="keywordflow">for</span> (<span class="keywordtype">char</span> c = (<span class="keywordtype">char</span>)((<span class="keywordtype">int</span>)prevChar + 1) ; c &lt; nextChar;)
<a name="l02039"></a>02039                                 {
<a name="l02040"></a>02040                                 preprocessedS.append(1, c);
<a name="l02041"></a>02041                                 c = (char) ((<span class="keywordtype">int</span>)c + 1);
<a name="l02042"></a>02042                                 }
<a name="l02043"></a>02043                             }
<a name="l02044"></a>02044                         <span class="keywordflow">else</span>
<a name="l02045"></a>02045                             {
<a name="l02046"></a>02046                             errormsg &lt;&lt; <span class="stringliteral">&quot;Endpoint of SYMBOLS range must be greater than the starting point.  This was not true of &quot;</span> &lt;&lt; prevChar &lt;&lt; <span class="charliteral">&#39;~&#39;</span> &lt;&lt; nextChar;
<a name="l02047"></a>02047                             <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l02048"></a>02048                             }
<a name="l02049"></a>02049                         }
<a name="l02050"></a>02050                     <span class="keywordflow">else</span>
<a name="l02051"></a>02051                         {
<a name="l02052"></a>02052                         errormsg &lt;&lt; prevChar &lt;&lt; <span class="charliteral">&#39;~&#39;</span> &lt;&lt; nextChar &lt;&lt; <span class="stringliteral">&quot; is an illegal SYMBOLS range. A range must go from a letter to a letter or from a number to number&quot;</span> ;
<a name="l02053"></a>02053                         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l02054"></a>02054                         }
<a name="l02055"></a>02055                     }
<a name="l02056"></a>02056                 <span class="keywordflow">else</span>
<a name="l02057"></a>02057                     preprocessedS += to[i];
<a name="l02058"></a>02058                 }
<a name="l02059"></a>02059             <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> processedS;
<a name="l02060"></a>02060             <span class="keywordflow">for</span> (std::string::const_iterator pp = preprocessedS.begin(); pp != preprocessedS.end(); ++pp)
<a name="l02061"></a>02061                 {
<a name="l02062"></a>02062                 <span class="keyword">const</span> <span class="keywordtype">char</span> c = *pp;
<a name="l02063"></a>02063                 <span class="keywordflow">if</span> (<a class="code" href="classNxsCharactersBlock_a2d652b95a2fe2d09fff6e8df0d64c7c4.html#a2d652b95a2fe2d09fff6e8df0d64c7c4" title="Returns true if `ch&amp;#39; can be found in the `symbols&amp;#39; array.">IsInSymbols</a>(c))
<a name="l02064"></a>02064                     {
<a name="l02065"></a>02065                     errormsg &lt;&lt; <span class="stringliteral">&quot;The character &quot;</span> &lt;&lt; c &lt;&lt; <span class="stringliteral">&quot; defined in SYMBOLS is predefined for this DATATYPE and should not occur in a SYMBOLS statement&quot;</span>;
<a name="l02066"></a>02066                     <span class="keywordflow">if</span> (nexusReader)
<a name="l02067"></a>02067                         {
<a name="l02068"></a>02068                         nexusReader-&gt;<a class="code" href="classNxsReader_aa81b33d57a4c5ddac0d5ccbf81df9c5b.html#aa81b33d57a4c5ddac0d5ccbf81df9c5b" title="Used internally as a more convenient way of calling NexusWarn.">NexusWarnToken</a>(errormsg, <a class="code" href="classNxsReader_a409e01dc0baecef7ed471879c0692978.html#a409e01dc0baecef7ed471879c0692978ad6030a0462aaf947e6383d0fd91a0b68">NxsReader::SKIPPING_CONTENT_WARNING</a>, token);
<a name="l02069"></a>02069                         errormsg.<a class="code" href="classNxsString_abbf904c772d9776139dcae602c9fd06b.html#abbf904c772d9776139dcae602c9fd06b" title="Most containers in the standard template library can be completely erased using the...">clear</a>();
<a name="l02070"></a>02070                         }
<a name="l02071"></a>02071                     }
<a name="l02072"></a>02072                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (   (respectingCase &amp;&amp; (userEquates.find(c) != userEquates.end()))
<a name="l02073"></a>02073                          || (! respectingCase &amp;&amp; (userEquates.find(toupper(c)) != userEquates.end() || userEquates.find(tolower(*pp)) != userEquates.end())))
<a name="l02074"></a>02074                     {
<a name="l02075"></a>02075                     errormsg &lt;&lt; <span class="stringliteral">&quot;The character &quot;</span> &lt;&lt; *pp &lt;&lt; <span class="stringliteral">&quot; defined in SYMBOLS subcommand, has already been introduced as an EQUATE key.  The use of a character as both a state symbol and an equate key is not allowed.&quot;</span>;
<a name="l02076"></a>02076                     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l02077"></a>02077                     }
<a name="l02078"></a>02078                 <span class="keywordflow">else</span>
<a name="l02079"></a>02079                     processedS += *pp;
<a name="l02080"></a>02080                 }
<a name="l02081"></a>02081             <span class="keywordflow">if</span> (!processedS.empty())
<a name="l02082"></a>02082                 {
<a name="l02083"></a>02083                 <span class="keywordflow">if</span> (this-&gt;datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca0145b9755a4581acaabe1e4c458d7f73" title="indicates `matrix&amp;#39; holds characters with arbitrarily-assigned, discrete states...">dna</a> || this-&gt;datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca9cb7e8ceb8521a96df0b81ecac913814" title="indicates `matrix&amp;#39; holds DNA sequences (states A, C, G, T)">rna</a> || this-&gt;restrictionDataype || this-&gt;datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca6867b9b05a5ce824179b5bdf10c891fc" title="indicates `matrix&amp;#39; holds nucleotide sequences">protein</a>)
<a name="l02084"></a>02084                     {
<a name="l02085"></a>02085                     <span class="keywordflow">if</span> (this-&gt;allowAugmentingOfSequenceSymbols)
<a name="l02086"></a>02086                         {
<a name="l02087"></a>02087                         errormsg &lt;&lt; <span class="stringliteral">&quot;Adding symbols to the &quot;</span> &lt;&lt; GetNameOfDatatype(this-&gt;datatype) &lt;&lt; <span class="stringliteral">&quot; datatype will cause the matrix to be treated as if it were a&quot;</span>;
<a name="l02088"></a>02088                         <span class="keywordflow">if</span> (this-&gt;convertAugmentedToMixed)
<a name="l02089"></a>02089                             errormsg &lt;&lt; <span class="stringliteral">&quot; MIXED datatype matrix&quot;</span>;
<a name="l02090"></a>02090                         <span class="keywordflow">else</span>
<a name="l02091"></a>02091                             errormsg &lt;&lt; <span class="stringliteral">&quot; STANDARD datatype matrix&quot;</span>;
<a name="l02092"></a>02092                         <span class="keywordflow">if</span> (!this-&gt;convertAugmentedToMixed)
<a name="l02093"></a>02093                             nexusReader-&gt;<a class="code" href="classNxsReader_aa81b33d57a4c5ddac0d5ccbf81df9c5b.html#aa81b33d57a4c5ddac0d5ccbf81df9c5b" title="Used internally as a more convenient way of calling NexusWarn.">NexusWarnToken</a>(errormsg, <a class="code" href="classNxsReader_a409e01dc0baecef7ed471879c0692978.html#a409e01dc0baecef7ed471879c0692978ac790b23b7c9d8cd1b9716a561fe31e6b">NxsReader::AMBIGUOUS_CONTENT_WARNING</a>, token);
<a name="l02094"></a>02094                         errormsg.<a class="code" href="classNxsString_abbf904c772d9776139dcae602c9fd06b.html#abbf904c772d9776139dcae602c9fd06b" title="Most containers in the standard template library can be completely erased using the...">clear</a>();
<a name="l02095"></a>02095                         }
<a name="l02096"></a>02096                     <span class="keywordflow">else</span>
<a name="l02097"></a>02097                         {
<a name="l02098"></a>02098                         errormsg &lt;&lt; <span class="stringliteral">&quot;Symbols cannot be added to the &quot;</span> &lt;&lt; GetNameOfDatatype(this-&gt;datatype) &lt;&lt; <span class="stringliteral">&quot; datatype.&quot;</span>;
<a name="l02099"></a>02099                         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l02100"></a>02100                         }
<a name="l02101"></a>02101                     }
<a name="l02102"></a>02102                 <span class="comment">// If we&#39;ve made it this far, go ahead and add the user-defined</span>
<a name="l02103"></a>02103                 <span class="comment">// symbols to the end of the list of predefined symbols</span>
<a name="l02104"></a>02104                 <span class="comment">//</span>
<a name="l02105"></a>02105                 symbols += processedS.c_str();
<a name="l02106"></a>02106                 }
<a name="l02107"></a>02107             }
<a name="l02108"></a>02108 
<a name="l02109"></a>02109         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;EQUATE&quot;</span>))
<a name="l02110"></a>02110             {
<a name="l02111"></a>02111             <span class="keywordflow">if</span> (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>)
<a name="l02112"></a>02112                 <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;EQUATE subcommand not allowed for DATATYPE=CONTINUOUS&quot;</span>, *wIt);
<a name="l02113"></a>02113 
<a name="l02114"></a>02114             <a class="code" href="classNxsBlock_aee6771bdd0c70f375d925c4e0b6d1095.html#aee6771bdd0c70f375d925c4e0b6d1095" title="Advances the token, and raise an exception if it is not an equals sign.">DemandEquals</a>(wIt, tvEnd, <span class="stringliteral">&quot;after keyword EQUATE&quot;</span>);
<a name="l02115"></a>02115             <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;\&quot; to start the Equate definition&quot;</span>);
<a name="l02116"></a>02116             <span class="keywordflow">if</span> (!wIt-&gt;Equals(<span class="stringliteral">&quot;\&quot;&quot;</span>))
<a name="l02117"></a>02117                 {
<a name="l02118"></a>02118                 errormsg &lt;&lt; <span class="stringliteral">&quot;Expecting &#39;\&quot;&#39; after keyword EQUATE but found &quot;</span> &lt;&lt; wIt-&gt;GetToken() &lt;&lt; <span class="stringliteral">&quot; instead&quot;</span>;
<a name="l02119"></a>02119                 <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *wIt);
<a name="l02120"></a>02120                 }
<a name="l02121"></a>02121             <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;\&quot; to end the Equate definition&quot;</span>);
<a name="l02122"></a>02122             <span class="keywordflow">while</span> (!wIt-&gt;Equals(<span class="stringliteral">&quot;\&quot;&quot;</span>))
<a name="l02123"></a>02123                 {
<a name="l02124"></a>02124                 std::string t = wIt-&gt;GetToken();
<a name="l02125"></a>02125                 <span class="keywordflow">if</span> (t.length() != 1)
<a name="l02126"></a>02126                     {
<a name="l02127"></a>02127                     errormsg &lt;&lt; <span class="stringliteral">&quot;Expecting single-character EQUATE symbol but found &quot;</span> &lt;&lt; wIt-&gt;GetToken() &lt;&lt; <span class="stringliteral">&quot; instead&quot;</span>;
<a name="l02128"></a>02128                     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *wIt);
<a name="l02129"></a>02129                     }
<a name="l02130"></a>02130                 <span class="keyword">const</span> <span class="keywordtype">char</span> ch = t[0];
<a name="l02131"></a>02131                 <span class="keywordtype">bool</span> badEquateSymbol = <span class="keyword">false</span>;
<a name="l02132"></a>02132 
<a name="l02133"></a>02133                 <span class="comment">// Equate symbols cannot be punctuation (except for + and -)</span>
<a name="l02134"></a>02134                 <span class="comment">//</span>
<a name="l02135"></a>02135                 <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a0e5bcf6a302bf475420b28036a218b51.html#a0e5bcf6a302bf475420b28036a218b51" title="Returns true if current token is a single character and this character is a punctuation...">IsPunctuationToken</a>(t) &amp;&amp; !token.<a class="code" href="classNxsToken_af75d27ce09e09c66c838ad61e13839f7.html#af75d27ce09e09c66c838ad61e13839f7" title="Returns true if current token is a single character and this character is either...">IsPlusMinusToken</a>(t))
<a name="l02136"></a>02136                     badEquateSymbol = <span class="keyword">true</span>;
<a name="l02137"></a>02137                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;^&#39;</span>)
<a name="l02138"></a>02138                     badEquateSymbol = <span class="keyword">true</span>;
<a name="l02139"></a>02139                 <span class="keywordflow">if</span> (badEquateSymbol)
<a name="l02140"></a>02140                     {
<a name="l02141"></a>02141                     errormsg &lt;&lt; <span class="stringliteral">&quot;EQUATE symbol specified (&quot;</span> &lt;&lt; wIt-&gt;GetToken() &lt;&lt;  <span class="stringliteral">&quot;) is not valid. Equate symbols cannot be any of the following: ()[]{}/\\,;:=*&#39;\&quot;`&lt;&gt;^&quot;</span>;
<a name="l02142"></a>02142                     WarnDangerousContent(errormsg, *wIt);
<a name="l02143"></a>02143                     }
<a name="l02144"></a>02144                 <span class="keywordflow">if</span> (ch == missing || ch == matchchar || ch == gap || <a class="code" href="classNxsCharactersBlock_a2d652b95a2fe2d09fff6e8df0d64c7c4.html#a2d652b95a2fe2d09fff6e8df0d64c7c4" title="Returns true if `ch&amp;#39; can be found in the `symbols&amp;#39; array.">IsInSymbols</a>(ch))
<a name="l02145"></a>02145                     {
<a name="l02146"></a>02146                     errormsg &lt;&lt; <span class="stringliteral">&quot;EQUATE symbol specified (&quot;</span> &lt;&lt; wIt-&gt;GetToken() &lt;&lt;  <span class="stringliteral">&quot;) is not valid; An Equate symbol cannot be a state symbol or identical to the  missing,  gap, or matchchar symbols.&quot;</span>;
<a name="l02147"></a>02147                     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *wIt);
<a name="l02148"></a>02148                     }
<a name="l02149"></a>02149 
<a name="l02150"></a>02150                 <a class="code" href="classNxsBlock_aee6771bdd0c70f375d925c4e0b6d1095.html#aee6771bdd0c70f375d925c4e0b6d1095" title="Advances the token, and raise an exception if it is not an equals sign.">DemandEquals</a>(wIt, tvEnd, <span class="stringliteral">&quot; in EQUATE definition&quot;</span>);
<a name="l02151"></a>02151                 <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;State or set of states in Equate definition&quot;</span>);
<a name="l02152"></a>02152                 <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> s;
<a name="l02153"></a>02153                 s = wIt-&gt;GetToken().c_str();
<a name="l02154"></a>02154                 <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;{&quot;</span>))
<a name="l02155"></a>02155                     {
<a name="l02156"></a>02156                     <span class="keywordflow">while</span> (!wIt-&gt;Equals(<span class="stringliteral">&quot;}&quot;</span>))
<a name="l02157"></a>02157                         {
<a name="l02158"></a>02158                         <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;} to close the state set in an equate definition&quot;</span>);
<a name="l02159"></a>02159                         s += wIt-&gt;GetToken().c_str();
<a name="l02160"></a>02160                         }
<a name="l02161"></a>02161                     }
<a name="l02162"></a>02162                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;(&quot;</span>))
<a name="l02163"></a>02163                     {
<a name="l02164"></a>02164                     <span class="keywordflow">while</span> (!wIt-&gt;Equals(<span class="stringliteral">&quot;)&quot;</span>))
<a name="l02165"></a>02165                         {
<a name="l02166"></a>02166                         <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;) to close the state set in an equate definition&quot;</span>);
<a name="l02167"></a>02167                         s += wIt-&gt;GetToken().c_str();
<a name="l02168"></a>02168                         }
<a name="l02169"></a>02169                     }
<a name="l02170"></a>02170                 <span class="keyword">const</span> std::string nows = <a class="code" href="classNxsString_a3efcad1ffa92a160cdd2210be924265b.html#a3efcad1ffa92a160cdd2210be924265b" title="Strips all whitespace.">NxsString::strip_whitespace</a>(s);
<a name="l02171"></a>02171                 userEquates[ch] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(nows.c_str());
<a name="l02172"></a>02172                 <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;\&quot; to end the Equate definition&quot;</span>);
<a name="l02173"></a>02173                 }
<a name="l02174"></a>02174             }
<a name="l02175"></a>02175 
<a name="l02176"></a>02176         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;LABELS&quot;</span>))
<a name="l02177"></a>02177             labels = <span class="keyword">true</span>;
<a name="l02178"></a>02178         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;NOLABELS&quot;</span>))
<a name="l02179"></a>02179             labels = <span class="keyword">false</span>;
<a name="l02180"></a>02180         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;TRANSPOSE&quot;</span>))
<a name="l02181"></a>02181             transposing = <span class="keyword">true</span>;
<a name="l02182"></a>02182         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;INTERLEAVE&quot;</span>))
<a name="l02183"></a>02183             interleaving = <span class="keyword">true</span>;
<a name="l02184"></a>02184         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;ITEMS&quot;</span>))
<a name="l02185"></a>02185             {
<a name="l02186"></a>02186             <a class="code" href="classNxsBlock_aee6771bdd0c70f375d925c4e0b6d1095.html#aee6771bdd0c70f375d925c4e0b6d1095" title="Advances the token, and raise an exception if it is not an equals sign.">DemandEquals</a>(wIt, tvEnd, <span class="stringliteral">&quot;after keyword ITEMS&quot;</span>);
<a name="l02187"></a>02187             items.clear();
<a name="l02188"></a>02188             <span class="comment">// This should be STATES (no other item is supported at this time)</span>
<a name="l02189"></a>02189             <span class="comment">//</span>
<a name="l02190"></a>02190             <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;after \&quot;ITEMS =\&quot; in FORMAT command&quot;</span>);
<a name="l02191"></a>02191             <span class="keywordflow">if</span> (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>)
<a name="l02192"></a>02192                 {
<a name="l02193"></a>02193                 std::string s;
<a name="l02194"></a>02194                 <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;(&quot;</span>))
<a name="l02195"></a>02195                     {
<a name="l02196"></a>02196                     <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;) to close Items list in FORMAT command&quot;</span>);
<a name="l02197"></a>02197                     <span class="keywordflow">while</span> (!wIt-&gt;Equals(<span class="stringliteral">&quot;)&quot;</span>))
<a name="l02198"></a>02198                         {
<a name="l02199"></a>02199                         s = wIt-&gt;GetToken();
<a name="l02200"></a>02200                         <a class="code" href="classNxsString_afa27910900e7e9f3bdc8d1b9753479a9.html#afa27910900e7e9f3bdc8d1b9753479a9" title="Capitalizes every character in s.">NxsString::to_upper</a>(s);
<a name="l02201"></a>02201                         items.push_back(std::string(s.c_str()));
<a name="l02202"></a>02202                         <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;) to close Items list in FORMAT command&quot;</span>);
<a name="l02203"></a>02203                         }
<a name="l02204"></a>02204                     }
<a name="l02205"></a>02205                 <span class="keywordflow">else</span>
<a name="l02206"></a>02206                     {
<a name="l02207"></a>02207                     s = wIt-&gt;GetToken();
<a name="l02208"></a>02208                     <a class="code" href="classNxsString_afa27910900e7e9f3bdc8d1b9753479a9.html#afa27910900e7e9f3bdc8d1b9753479a9" title="Capitalizes every character in s.">NxsString::to_upper</a>(s);
<a name="l02209"></a>02209                     items.push_back(std::string(s.c_str()));
<a name="l02210"></a>02210                     }
<a name="l02211"></a>02211                 }
<a name="l02212"></a>02212             <span class="keywordflow">else</span>
<a name="l02213"></a>02213                 {
<a name="l02214"></a>02214                 <span class="keywordflow">if</span> (!wIt-&gt;Equals(<span class="stringliteral">&quot;STATES&quot;</span>))
<a name="l02215"></a>02215                     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Sorry, only ITEMS=STATES is supported for discrete datatypes at this time&quot;</span>, *wIt);
<a name="l02216"></a>02216                 items = std::vector&lt;std::string&gt;(1, std::string(<span class="stringliteral">&quot;STATES&quot;</span>));
<a name="l02217"></a>02217                 }
<a name="l02218"></a>02218             }
<a name="l02219"></a>02219         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;STATESFORMAT&quot;</span>))
<a name="l02220"></a>02220             {
<a name="l02221"></a>02221             <a class="code" href="classNxsBlock_aee6771bdd0c70f375d925c4e0b6d1095.html#aee6771bdd0c70f375d925c4e0b6d1095" title="Advances the token, and raise an exception if it is not an equals sign.">DemandEquals</a>(wIt, tvEnd, <span class="stringliteral">&quot;after keyword STATESFORMAT&quot;</span>);
<a name="l02222"></a>02222             <a class="code" href="classProcessedNxsToken_a548e8059aa207b0fabc0e0cf1a2319cc.html#a548e8059aa207b0fabc0e0cf1a2319cc" title="Convenience function.">ProcessedNxsToken::IncrementNotLast</a>(wIt, tvEnd, <span class="stringliteral">&quot;after \&quot;STATESFORMAT =\&quot; in FORMAT command&quot;</span>);
<a name="l02223"></a>02223             <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;STATESPRESENT&quot;</span>))
<a name="l02224"></a>02224                 statesFormat = STATES_PRESENT;
<a name="l02225"></a>02225             <span class="keywordflow">else</span>
<a name="l02226"></a>02226                 {
<a name="l02227"></a>02227                 <span class="keywordflow">if</span> (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>)
<a name="l02228"></a>02228                     {
<a name="l02229"></a>02229                     <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;INDIVIDUALS&quot;</span>))
<a name="l02230"></a>02230                         statesFormat = INDIVIDUALS;
<a name="l02231"></a>02231                     <span class="keywordflow">else</span>
<a name="l02232"></a>02232                         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Sorry, only STATESFORMAT=STATESPRESENT or STATESFORMAT=INDIVIDUALS are supported for continuous datatypes at this time&quot;</span>, *wIt);
<a name="l02233"></a>02233                     }
<a name="l02234"></a>02234                 <span class="keywordflow">else</span>
<a name="l02235"></a>02235                     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Sorry, only STATESFORMAT=STATESPRESENT supported for discrete datatypes at this time&quot;</span>, *wIt);
<a name="l02236"></a>02236                 }
<a name="l02237"></a>02237             }
<a name="l02238"></a>02238         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;TOKENS&quot;</span>))
<a name="l02239"></a>02239             tokens = <span class="keyword">true</span>;
<a name="l02240"></a>02240         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wIt-&gt;Equals(<span class="stringliteral">&quot;NOTOKENS&quot;</span>))
<a name="l02241"></a>02241             {
<a name="l02242"></a>02242             <span class="keywordflow">if</span> (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>)
<a name="l02243"></a>02243                 <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;NOTOKENS is not allowed for the CONTINUOUS datatype&quot;</span>, *wIt);
<a name="l02244"></a>02244             tokens = <span class="keyword">false</span>;
<a name="l02245"></a>02245             }
<a name="l02246"></a>02246         }
<a name="l02247"></a>02247     <span class="keywordflow">if</span> (<a class="code" href="classNxsCharactersBlock_a2d652b95a2fe2d09fff6e8df0d64c7c4.html#a2d652b95a2fe2d09fff6e8df0d64c7c4" title="Returns true if `ch&amp;#39; can be found in the `symbols&amp;#39; array.">IsInSymbols</a>(missing))
<a name="l02248"></a>02248         {
<a name="l02249"></a>02249         errormsg &lt;&lt; <span class="stringliteral">&quot;The \&quot;missing\&quot; character \&#39;&quot;</span> &lt;&lt; missing &lt;&lt; <span class="stringliteral">&quot;\&#39; may not be included in the SYMBOLS list.&quot;</span>;
<a name="l02250"></a>02250         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *tokenVec.begin());
<a name="l02251"></a>02251         }
<a name="l02252"></a>02252     <span class="keywordflow">if</span> (<a class="code" href="classNxsCharactersBlock_a2d652b95a2fe2d09fff6e8df0d64c7c4.html#a2d652b95a2fe2d09fff6e8df0d64c7c4" title="Returns true if `ch&amp;#39; can be found in the `symbols&amp;#39; array.">IsInSymbols</a>(matchchar))
<a name="l02253"></a>02253         {
<a name="l02254"></a>02254         errormsg &lt;&lt; <span class="stringliteral">&quot;The \&quot;matchchar\&quot; character \&#39;&quot;</span> &lt;&lt; matchchar &lt;&lt; <span class="stringliteral">&quot;\&#39; may not be included in the SYMBOLS list.&quot;</span>;
<a name="l02255"></a>02255         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *tokenVec.begin());
<a name="l02256"></a>02256         }
<a name="l02257"></a>02257     <span class="keywordflow">if</span> (<a class="code" href="classNxsCharactersBlock_a2d652b95a2fe2d09fff6e8df0d64c7c4.html#a2d652b95a2fe2d09fff6e8df0d64c7c4" title="Returns true if `ch&amp;#39; can be found in the `symbols&amp;#39; array.">IsInSymbols</a>(gap))
<a name="l02258"></a>02258         {
<a name="l02259"></a>02259         errormsg &lt;&lt; <span class="stringliteral">&quot;The \&quot;gap\&quot; character \&#39;&quot;</span> &lt;&lt; gap &lt;&lt; <span class="stringliteral">&quot;\&#39; may not be included in the SYMBOLS list.&quot;</span>;
<a name="l02260"></a>02260         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *tokenVec.begin());
<a name="l02261"></a>02261         }
<a name="l02262"></a>02262 
<a name="l02263"></a>02263     <span class="keywordflow">if</span> (matchchar != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l02264"></a>02264         {
<a name="l02265"></a>02265         <span class="keywordflow">if</span> ((matchchar == gap) || (!respectingCase &amp;&amp; toupper(matchchar) == toupper(gap)))
<a name="l02266"></a>02266             {
<a name="l02267"></a>02267             errormsg &lt;&lt; <span class="stringliteral">&quot;MatchChar and Gap symbol cannot be identical!  Both were set to &quot;</span> &lt;&lt; gap;
<a name="l02268"></a>02268             <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *tokenVec.begin());
<a name="l02269"></a>02269             }
<a name="l02270"></a>02270         <span class="keywordflow">if</span> ((matchchar == missing) || (!respectingCase &amp;&amp; toupper(matchchar) == toupper(missing)))
<a name="l02271"></a>02271             {
<a name="l02272"></a>02272             errormsg &lt;&lt; <span class="stringliteral">&quot;MatchChar and Missing symbol cannot be identical!  Both were set to &quot;</span> &lt;&lt; missing;
<a name="l02273"></a>02273             <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *tokenVec.begin());
<a name="l02274"></a>02274             }
<a name="l02275"></a>02275         }
<a name="l02276"></a>02276     <span class="keywordflow">if</span> ((gap != <span class="charliteral">&#39;\0&#39;</span>) &amp;&amp; ((gap == missing) || (!respectingCase &amp;&amp; toupper(gap) == toupper(missing))))
<a name="l02277"></a>02277         {
<a name="l02278"></a>02278         errormsg &lt;&lt; <span class="stringliteral">&quot;Gap symbol and Missing symbol cannot be identical!  Both were set to &quot;</span> &lt;&lt; missing;
<a name="l02279"></a>02279         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, *tokenVec.begin());
<a name="l02280"></a>02280         }
<a name="l02281"></a>02281 
<a name="l02282"></a>02282     <span class="comment">// Perform some last checks before leaving the FORMAT command</span>
<a name="l02283"></a>02283     <span class="comment">//</span>
<a name="l02284"></a>02284     <span class="keywordflow">if</span> (!tokens &amp;&amp; datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">continuous</a>)
<a name="l02285"></a>02285         <a class="code" href="classNxsBlock_a9106779865a661477259f3d84edb36a5.html#a9106779865a661477259f3d84edb36a5" title="throws a NxsException with the token info for `token` `expected` should fill in the...">GenerateNxsException</a>(token, <span class="stringliteral">&quot;TOKENS must be defined for DATATYPE=CONTINUOUS&quot;</span>);
<a name="l02286"></a>02286     <span class="keywordflow">if</span> (tokens &amp;&amp; (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca0145b9755a4581acaabe1e4c458d7f73" title="indicates `matrix&amp;#39; holds characters with arbitrarily-assigned, discrete states...">dna</a> || datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca9cb7e8ceb8521a96df0b81ecac913814" title="indicates `matrix&amp;#39; holds DNA sequences (states A, C, G, T)">rna</a> || datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa9ca7e6de7b65840b97d9ecd42c0ad3a" title="indicates `matrix&amp;#39; holds RNA sequences (states A, C, G, U)">nucleotide</a>))
<a name="l02287"></a>02287         <a class="code" href="classNxsBlock_a9106779865a661477259f3d84edb36a5.html#a9106779865a661477259f3d84edb36a5" title="throws a NxsException with the token info for `token` `expected` should fill in the...">GenerateNxsException</a>(token, <span class="stringliteral">&quot;TOKENS not allowed for the DATATYPEs DNA, RNA, or NUCLEOTIDE&quot;</span>);
<a name="l02288"></a>02288     CreateDatatypeMapperObjects(dtParts, dtv);
<a name="l02289"></a>02289     <span class="keywordflow">if</span> (IsMixedType() &amp;&amp; tokens)
<a name="l02290"></a>02290         {
<a name="l02291"></a>02291         errormsg = <span class="stringliteral">&quot;The combination of DATATYPE=Mixed  and TOKENS are not currently supported.&quot;</span>;
<a name="l02292"></a>02292         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token.<a class="code" href="classNxsToken_a17e5caf91acc756c23159f76f8b2d0fd.html#a17e5caf91acc756c23159f76f8b2d0fd" title="Returns value stored in filepos, which keeps track of the current position in the...">GetFilePosition</a>(), token.<a class="code" href="classNxsToken_ae0fb11bf350d907295447864afa714ec.html#ae0fb11bf350d907295447864afa714ec" title="Returns value stored in `fileline&amp;#39;, which keeps track of the current line in...">GetFileLine</a>(), token.<a class="code" href="classNxsToken_a7272fd1469fa6424086a95ec4f92eab0.html#a7272fd1469fa6424086a95ec4f92eab0" title="Returns value stored in `filecol&amp;#39;, which keeps track of the current column in...">GetFileColumn</a>());
<a name="l02293"></a>02293         }
<a name="l02294"></a>02294     <span class="keywordtype">unsigned</span> mapInd = 0;
<a name="l02295"></a>02295     <span class="keywordflow">for</span> (std::vector&lt;bool&gt;::const_iterator b = isR.begin(); b != isR.end(); ++b, ++mapInd)
<a name="l02296"></a>02296         {
<a name="l02297"></a>02297         <span class="keywordflow">if</span> (*b)
<a name="l02298"></a>02298             {
<a name="l02299"></a>02299             DatatypeMapperAndIndexSet &amp;mapper = datatypeMapperVec.at(mapInd);
<a name="l02300"></a>02300             mapper.first.SetWasRestrictionDataype(<span class="keyword">true</span>);
<a name="l02301"></a>02301             }
<a name="l02302"></a>02302         }
<a name="l02303"></a>02303     }
<a name="l02304"></a>02304 
<a name="l02306"></a><a class="code" href="classNxsDiscreteDatatypeMapper_a6eac6a70f5c2eb5ffaa67300f830a467.html#a6eac6a70f5c2eb5ffaa67300f830a467">02306</a> <a class="code" href="classNxsDiscreteDatatypeMapper_a6eac6a70f5c2eb5ffaa67300f830a467.html#a6eac6a70f5c2eb5ffaa67300f830a467" title="creates a standard datatype mapper (symbols &amp;quot;01&amp;quot; and no gaps or equates)...">NxsDiscreteDatatypeMapper::NxsDiscreteDatatypeMapper</a>()
<a name="l02307"></a>02307     :geneticCode(NXS_GCODE_NO_CODE),
<a name="l02308"></a>02308     datatype(<a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a>::standard),
<a name="l02309"></a>02309     restrictionDataype(false),
<a name="l02310"></a>02310     userDefinedEquatesBeforeConversion(false)
<a name="l02311"></a>02311     {
<a name="l02312"></a>02312     symbols.assign(<span class="stringliteral">&quot;01&quot;</span>);
<a name="l02313"></a>02313     matchChar = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l02314"></a>02314     gapChar = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l02315"></a>02315     missing = <span class="charliteral">&#39;?&#39;</span>;
<a name="l02316"></a>02316     respectCase = <span class="keyword">false</span>;
<a name="l02317"></a>02317     RefreshMappings(0L);
<a name="l02318"></a>02318     }
<a name="l02319"></a>02319 
<a name="l02320"></a>02320 <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> &amp; NxsDiscreteDatatypeMapper::operator=(<span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a>&amp; other)
<a name="l02321"></a>02321     {
<a name="l02322"></a>02322     symbols = other.symbols;
<a name="l02323"></a>02323     lcsymbols = other.lcsymbols;
<a name="l02324"></a>02324     nStates = other.nStates;
<a name="l02325"></a>02325     matchChar = other.matchChar;
<a name="l02326"></a>02326     gapChar = other.gapChar;
<a name="l02327"></a>02327     missing = other.missing;
<a name="l02328"></a>02328     respectCase = other.respectCase;
<a name="l02329"></a>02329     extraEquates = other.extraEquates;
<a name="l02330"></a>02330     datatype = other.datatype;
<a name="l02331"></a>02331     geneticCode = other.geneticCode;
<a name="l02332"></a>02332     sclOffset = other.sclOffset;
<a name="l02333"></a>02333     stateSetsVec = other.stateSetsVec;
<a name="l02334"></a>02334     stateCodeLookupPtr = &amp;stateSetsVec[-sclOffset];
<a name="l02335"></a>02335     charToStateCodeLookup = other.charToStateCodeLookup;
<a name="l02336"></a>02336     cLookup = &amp;charToStateCodeLookup[127];
<a name="l02337"></a>02337     restrictionDataype = other.restrictionDataype;
<a name="l02338"></a>02338     userDefinedEquatesBeforeConversion = other.userDefinedEquatesBeforeConversion;
<a name="l02339"></a>02339     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02340"></a>02340     }
<a name="l02341"></a>02341 
<a name="l02346"></a><a class="code" href="classNxsDiscreteDatatypeMapper_ab95388d3b70b42b4e2e5100b70cd55f5.html#ab95388d3b70b42b4e2e5100b70cd55f5">02346</a> <a class="code" href="classNxsDiscreteDatatypeMapper_a6eac6a70f5c2eb5ffaa67300f830a467.html#a6eac6a70f5c2eb5ffaa67300f830a467" title="creates a standard datatype mapper (symbols &amp;quot;01&amp;quot; and no gaps or equates)...">NxsDiscreteDatatypeMapper::NxsDiscreteDatatypeMapper</a>(
<a name="l02347"></a>02347     <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290c" title="values used to represent different basic types of data stored in a CHARACTERS block...">NxsCharactersBlock::DataTypesEnum</a> datatypeE, 
<a name="l02348"></a>02348     <span class="keywordtype">bool</span> usegaps) 
<a name="l02349"></a>02349     :geneticCode(NXS_GCODE_NO_CODE),
<a name="l02350"></a>02350     cLookup(NULL),
<a name="l02351"></a>02351     stateCodeLookupPtr(NULL),
<a name="l02352"></a>02352     matchChar(<span class="stringliteral">&#39;.&#39;</span>),
<a name="l02353"></a>02353     gapChar(<span class="stringliteral">&#39;\0&#39;</span>),
<a name="l02354"></a>02354     missing(<span class="stringliteral">&#39;?&#39;</span>),
<a name="l02355"></a>02355     respectCase(false),
<a name="l02356"></a>02356     datatype(datatypeE),
<a name="l02357"></a>02357     restrictionDataype(false),
<a name="l02358"></a>02358     userDefinedEquatesBeforeConversion(false)
<a name="l02359"></a>02359     {
<a name="l02360"></a>02360     symbols = NxsCharactersBlock::GetDefaultSymbolsForType(datatype);
<a name="l02361"></a>02361     <span class="keywordflow">if</span> (usegaps)
<a name="l02362"></a>02362         gapChar = <span class="charliteral">&#39;-&#39;</span>;
<a name="l02363"></a>02363     <span class="keywordflow">if</span> (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca53544b6c478de9117d5e98a66e5f20d1" title="indicates `matrix&amp;#39; holds continuous data">NxsCharactersBlock::mixed</a>)
<a name="l02364"></a>02364         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Cannot create a mixed datatype mapper&quot;</span>); <span class="comment">// this should be the only empty string-generating datatype</span>
<a name="l02365"></a>02365     RefreshMappings(0L);
<a name="l02366"></a>02366     }
<a name="l02367"></a>02367 
<a name="l02377"></a><a class="code" href="classNxsDiscreteDatatypeMapper_a495505622d8540b88cd03c0f41ac8154.html#a495505622d8540b88cd03c0f41ac8154">02377</a> <span class="keywordtype">bool</span> <a class="code" href="classNxsDiscreteDatatypeMapper_a495505622d8540b88cd03c0f41ac8154.html#a495505622d8540b88cd03c0f41ac8154">NxsDiscreteDatatypeMapper::IsSemanticallyEquivalent</a>(<span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> &amp;other)<span class="keyword"> const</span>
<a name="l02378"></a>02378 <span class="keyword">    </span>{
<a name="l02379"></a>02379     <span class="keywordflow">if</span> (datatype != other.datatype)
<a name="l02380"></a>02380         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02381"></a>02381     <span class="keywordflow">if</span> (symbols != other.symbols)
<a name="l02382"></a>02382         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02383"></a>02383     <span class="keywordtype">bool</span> thisHasGap = (gapChar != <span class="charliteral">&#39;\0&#39;</span>);
<a name="l02384"></a>02384     <span class="keywordtype">bool</span> otherHasGap = (other.gapChar != <span class="charliteral">&#39;\0&#39;</span>);
<a name="l02385"></a>02385     <span class="keywordflow">if</span> (thisHasGap != otherHasGap)
<a name="l02386"></a>02386         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02387"></a>02387     <span class="keyword">const</span> NxsDiscreteStateCell nsc = (NxsDiscreteStateCell)<a class="code" href="classNxsDiscreteDatatypeMapper_a6ef0c84d54793c3e93c4b2f4ad14cacc.html#a6ef0c84d54793c3e93c4b2f4ad14cacc">GetHighestStateCode</a>();
<a name="l02388"></a>02388     <span class="keywordflow">if</span>(nsc != (NxsDiscreteStateCell) other.<a class="code" href="classNxsDiscreteDatatypeMapper_a6ef0c84d54793c3e93c4b2f4ad14cacc.html#a6ef0c84d54793c3e93c4b2f4ad14cacc">GetHighestStateCode</a>())
<a name="l02389"></a>02389         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02390"></a>02390     <span class="keywordflow">for</span> (NxsDiscreteStateCell i = 0; i &lt;= nsc; ++i)
<a name="l02391"></a>02391         {
<a name="l02392"></a>02392         <span class="keywordflow">if</span> (<a class="code" href="classNxsDiscreteDatatypeMapper_ad39cdce419be460c3a197dfa07a96c80.html#ad39cdce419be460c3a197dfa07a96c80" title="Returns the set of state indices that correspond to the states of state code `c`...">GetStateSetForCode</a>(i) != other.<a class="code" href="classNxsDiscreteDatatypeMapper_ad39cdce419be460c3a197dfa07a96c80.html#ad39cdce419be460c3a197dfa07a96c80" title="Returns the set of state indices that correspond to the states of state code `c`...">GetStateSetForCode</a>(i))
<a name="l02393"></a>02393             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02394"></a>02394         }
<a name="l02395"></a>02395     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02396"></a>02396     }
<a name="l02397"></a>02397 
<a name="l02403"></a>02403 <span class="keywordtype">void</span> NxsDiscreteDatatypeMapper::RefreshMappings(<a class="code" href="classNxsToken.html">NxsToken</a> *token)
<a name="l02404"></a>02404     {
<a name="l02405"></a>02405     nStates = (unsigned)symbols.length();
<a name="l02406"></a>02406     <span class="keywordflow">if</span> (nStates ==  0)
<a name="l02407"></a>02407         {
<a name="l02408"></a>02408         <span class="keywordflow">if</span> (datatype != <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>)
<a name="l02409"></a>02409             <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Cannot create a datatype mapper with no symbols&quot;</span>);
<a name="l02410"></a>02410         <span class="keywordflow">return</span>;
<a name="l02411"></a>02411         }
<a name="l02412"></a>02412     <span class="keywordflow">if</span> (!respectCase)
<a name="l02413"></a>02413         {
<a name="l02414"></a>02414         <a class="code" href="classNxsString_afa27910900e7e9f3bdc8d1b9753479a9.html#afa27910900e7e9f3bdc8d1b9753479a9" title="Capitalizes every character in s.">NxsString::to_upper</a>(symbols);
<a name="l02415"></a>02415         lcsymbols = symbols;
<a name="l02416"></a>02416         }
<a name="l02417"></a>02417     <span class="keywordflow">else</span>
<a name="l02418"></a>02418         lcsymbols.clear();
<a name="l02419"></a>02419 
<a name="l02420"></a>02420     <a class="code" href="classNxsString_a8a226fa743e246c3b2b65880deaa81db.html#a8a226fa743e246c3b2b65880deaa81db" title="Capitalizes every character in s.">NxsString::to_lower</a>(lcsymbols);
<a name="l02421"></a>02421 
<a name="l02422"></a>02422     <span class="keywordflow">if</span> (missing == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l02423"></a>02423         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(<span class="stringliteral">&quot;Cannot create a datatype mapper with no missing data symbol&quot;</span>);
<a name="l02424"></a>02424 
<a name="l02425"></a>02425     charToStateCodeLookup.assign(384, NXS_INVALID_STATE_CODE); <span class="comment">/*256+128 = 384 -- this way we can deal with signed or unsigned chars by pointing cLookup to element 128*/</span>
<a name="l02426"></a>02426     cLookup = &amp;charToStateCodeLookup[127];
<a name="l02427"></a>02427     stateIntersectionMatrix.clear();
<a name="l02428"></a>02428     isStateSubsetMatrix.clear();
<a name="l02429"></a>02429     isStateSubsetMatrixGapsMissing.clear();
<a name="l02430"></a>02430 
<a name="l02431"></a>02431     stateSetsVec.clear();
<a name="l02432"></a>02432     stateCodeLookupPtr = 0L;
<a name="l02433"></a>02433     sclOffset = (gapChar == <span class="charliteral">&#39;\0&#39;</span> ? -1 : -2);
<a name="l02434"></a>02434 
<a name="l02435"></a>02435     std::string bogus;
<a name="l02436"></a>02436     std::istringstream bogusStream(bogus);
<a name="l02437"></a>02437     <a class="code" href="classNxsToken.html">NxsToken</a> bogusToken(bogusStream);
<a name="l02438"></a>02438     token = (token == NULL ? &amp;bogusToken : token);
<a name="l02439"></a>02439 
<a name="l02440"></a>02440     <span class="comment">/* add the &quot;fundamental&quot; states. */</span>
<a name="l02441"></a>02441     std::set&lt;NxsDiscreteStateCell&gt; stSet;
<a name="l02442"></a>02442     std::set&lt;NxsDiscreteStateCell&gt; missingSet;
<a name="l02443"></a>02443     <span class="keywordflow">if</span> (gapChar != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l02444"></a>02444         {
<a name="l02445"></a>02445         stSet.insert(NXS_GAP_STATE_CODE);
<a name="l02446"></a>02446         <span class="comment">/* this is the one of only 2 times that  we don&#39;t call AddStateSet to add a state set</span>
<a name="l02447"></a>02447 <span class="comment">            we do this to avoid illegal indexing of stateSets[1] when there</span>
<a name="l02448"></a>02448 <span class="comment">            is only one element in the vector.</span>
<a name="l02449"></a>02449 <span class="comment">        */</span>
<a name="l02450"></a>02450         stateSetsVec.push_back(NxsDiscreteStateSetInfo(stSet, <span class="keyword">false</span>, gapChar));
<a name="l02451"></a>02451         cLookup[(int) gapChar] = NXS_GAP_STATE_CODE;
<a name="l02452"></a>02452 
<a name="l02453"></a>02453         missingSet.insert(NXS_GAP_STATE_CODE);
<a name="l02454"></a>02454         }
<a name="l02455"></a>02455 
<a name="l02456"></a>02456 
<a name="l02457"></a>02457         <span class="comment">/*</span>
<a name="l02458"></a>02458 <span class="comment">            Add the missing state code</span>
<a name="l02459"></a>02459 <span class="comment">            this is the other time that we don&#39;t call AddStateSet (to avoid illegal indexing).</span>
<a name="l02460"></a>02460 <span class="comment">        */</span>
<a name="l02461"></a>02461     NCL_ASSERT(missing != <span class="charliteral">&#39;\0&#39;</span>);
<a name="l02462"></a>02462     NCL_ASSERT(nStates &gt; 0);
<a name="l02463"></a>02463     <span class="keywordflow">for</span> (NxsDiscreteStateCell s = 0; s &lt; (NxsDiscreteStateCell) nStates; ++s)
<a name="l02464"></a>02464         missingSet.insert(s);
<a name="l02465"></a>02465 
<a name="l02466"></a>02466     <span class="keywordtype">char</span> sym = (respectCase ? missing : (char) toupper(missing));
<a name="l02467"></a>02467     stateSetsVec.push_back(NxsDiscreteStateSetInfo(missingSet, <span class="keyword">false</span>, sym));
<a name="l02468"></a>02468     <span class="keyword">const</span> NxsDiscreteStateCell stateCode = (<span class="keyword">const</span> NxsDiscreteStateCell)stateSetsVec.size() + sclOffset - 1;
<a name="l02469"></a>02469     NCL_ASSERT(NXS_MISSING_CODE == stateCode);
<a name="l02470"></a>02470     <span class="keywordflow">if</span> (respectCase)
<a name="l02471"></a>02471         cLookup[(int) missing] = stateCode;
<a name="l02472"></a>02472     <span class="keywordflow">else</span>
<a name="l02473"></a>02473         {
<a name="l02474"></a>02474         cLookup[(int) tolower(missing)] = stateCode;
<a name="l02475"></a>02475         cLookup[(int) toupper(missing)] = stateCode;
<a name="l02476"></a>02476         }
<a name="l02477"></a>02477     NCL_ASSERT(cLookup[(<span class="keywordtype">int</span>) missing] == NXS_MISSING_CODE);
<a name="l02478"></a>02478     <span class="keywordflow">for</span> (NxsDiscreteStateCell s = 0; s &lt; (NxsDiscreteStateCell) nStates; ++s)
<a name="l02479"></a>02479         {
<a name="l02480"></a>02480         stSet.clear();
<a name="l02481"></a>02481         stSet.insert(s);
<a name="l02482"></a>02482         AddStateSet(stSet, symbols[s], respectCase, <span class="keyword">false</span>);
<a name="l02483"></a>02483         }
<a name="l02484"></a>02484 
<a name="l02485"></a>02485     <span class="comment">/* add the default equates */</span>
<a name="l02486"></a>02486     std::map&lt;char, NxsString&gt; defEq = NxsCharactersBlock::GetDefaultEquates(datatype);
<a name="l02487"></a>02487 
<a name="l02488"></a>02488 
<a name="l02489"></a>02489 
<a name="l02490"></a>02490     <span class="keywordtype">bool</span> convertToStandard = <span class="keyword">false</span>;
<a name="l02491"></a>02491     <span class="keywordflow">if</span> (((datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa9ca7e6de7b65840b97d9ecd42c0ad3a" title="indicates `matrix&amp;#39; holds RNA sequences (states A, C, G, U)">NxsCharactersBlock::nucleotide</a>) || (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca0145b9755a4581acaabe1e4c458d7f73" title="indicates `matrix&amp;#39; holds characters with arbitrarily-assigned, discrete states...">NxsCharactersBlock::dna</a>)) &amp;&amp; symbols != <span class="stringliteral">&quot;ACGT&quot;</span>)
<a name="l02492"></a>02492         convertToStandard = <span class="keyword">true</span>;
<a name="l02493"></a>02493     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca9cb7e8ceb8521a96df0b81ecac913814" title="indicates `matrix&amp;#39; holds DNA sequences (states A, C, G, T)">NxsCharactersBlock::rna</a>) &amp;&amp; symbols != <span class="stringliteral">&quot;ACGU&quot;</span>)
<a name="l02494"></a>02494         convertToStandard = <span class="keyword">true</span>;
<a name="l02495"></a>02495     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca6867b9b05a5ce824179b5bdf10c891fc" title="indicates `matrix&amp;#39; holds nucleotide sequences">NxsCharactersBlock::protein</a>) &amp;&amp; symbols != <span class="stringliteral">&quot;ACDEFGHIKLMNPQRSTVWY*&quot;</span>)
<a name="l02496"></a>02496         convertToStandard = <span class="keyword">true</span>;
<a name="l02497"></a>02497     <span class="keywordflow">if</span> (convertToStandard)
<a name="l02498"></a>02498         {
<a name="l02499"></a>02499         <span class="keywordflow">if</span> (!extraEquates.empty())
<a name="l02500"></a>02500             userDefinedEquatesBeforeConversion = <span class="keyword">true</span>;
<a name="l02501"></a>02501         defEq.insert(extraEquates.begin(), extraEquates.end());
<a name="l02502"></a>02502         extraEquates.clear();
<a name="l02503"></a>02503         defEq.swap(extraEquates);
<a name="l02504"></a>02504         <span class="comment">/* respectcase is only &quot;applicable&quot; to Standard datatype</span>
<a name="l02505"></a>02505 <span class="comment">            Any symbol extension will be at the end of the symbols list,</span>
<a name="l02506"></a>02506 <span class="comment">            so here we add the lower case symbols as equates.</span>
<a name="l02507"></a>02507 <span class="comment">        */</span>
<a name="l02508"></a>02508         <span class="keywordflow">if</span> (respectCase)
<a name="l02509"></a>02509             {
<a name="l02510"></a>02510             std::string lcsym = NxsCharactersBlock::GetDefaultSymbolsForType(datatype);
<a name="l02511"></a>02511             <a class="code" href="classNxsString_a8a226fa743e246c3b2b65880deaa81db.html#a8a226fa743e246c3b2b65880deaa81db" title="Capitalizes every character in s.">NxsString::to_lower</a>(lcsym);
<a name="l02512"></a>02512             std::string ucsym = lcsym;
<a name="l02513"></a>02513             <a class="code" href="classNxsString_afa27910900e7e9f3bdc8d1b9753479a9.html#afa27910900e7e9f3bdc8d1b9753479a9" title="Capitalizes every character in s.">NxsString::to_upper</a>(ucsym);
<a name="l02514"></a>02514             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; ucsym.length(); ++i)
<a name="l02515"></a>02515                 {
<a name="l02516"></a>02516                 <span class="keywordflow">if</span> (ucsym[i] != lcsym[i])
<a name="l02517"></a>02517                     {
<a name="l02518"></a>02518                     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> u;
<a name="l02519"></a>02519                     u.append(1, ucsym[i]);
<a name="l02520"></a>02520                     extraEquates[lcsym[i]] = u;
<a name="l02521"></a>02521                     }
<a name="l02522"></a>02522                 }
<a name="l02523"></a>02523             }
<a name="l02524"></a>02524         datatype =  NxsCharactersBlock::standard;
<a name="l02525"></a>02525         }
<a name="l02526"></a>02526 
<a name="l02527"></a>02527     <span class="comment">/* It is nice to put the all-states code at state code = num_states So here, we&#39;ll put this equate in that slot (if such an equate exists)*/</span>
<a name="l02528"></a>02528     std::set&lt;char&gt; targetSet(symbols.begin(), symbols.end());
<a name="l02529"></a>02529     <span class="keywordtype">char</span> allStateEquateKey = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l02530"></a>02530     std::map&lt;char, NxsString&gt;::const_iterator eqIt = defEq.begin();
<a name="l02531"></a>02531     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> taxonName;
<a name="l02532"></a>02532     <span class="keywordflow">for</span> (; eqIt != defEq.end(); ++eqIt)
<a name="l02533"></a>02533         {
<a name="l02534"></a>02534         <span class="keyword">const</span> <span class="keywordtype">char</span> c = eqIt-&gt;first;
<a name="l02535"></a>02535         <span class="keyword">const</span> <span class="keywordtype">char</span> u = toupper(c);
<a name="l02536"></a>02536         <span class="keywordtype">bool</span> addEq = <span class="keyword">true</span>;
<a name="l02537"></a>02537         <span class="keywordflow">if</span> (c == missing || c == matchChar || c == gapChar)
<a name="l02538"></a>02538             addEq = <span class="keyword">false</span>;
<a name="l02539"></a>02539         <span class="keywordflow">if</span> (!respectCase &amp;&amp; (u == toupper(missing) || u == toupper(matchChar) || u == toupper(gapChar)))
<a name="l02540"></a>02540             addEq = <span class="keyword">false</span>;
<a name="l02541"></a>02541         <span class="keywordflow">if</span> (addEq)
<a name="l02542"></a>02542             {
<a name="l02543"></a>02543             <span class="keyword">const</span> <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> &amp; s = eqIt-&gt;second;
<a name="l02544"></a>02544             <span class="keywordtype">unsigned</span> slen = s.length();
<a name="l02545"></a>02545             <span class="keywordflow">if</span> (slen == 2 + symbols.length())
<a name="l02546"></a>02546                 {
<a name="l02547"></a>02547                 <span class="keywordflow">if</span> (s[0] == <span class="charliteral">&#39;{&#39;</span> &amp;&amp; s[slen -1] == <span class="charliteral">&#39;}&#39;</span>)
<a name="l02548"></a>02548                     {
<a name="l02549"></a>02549                     std::set&lt;char&gt; contained;
<a name="l02550"></a>02550                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 1; j &lt; slen - 1; ++j)
<a name="l02551"></a>02551                         contained.insert(s[j]);
<a name="l02552"></a>02552                     <span class="keywordflow">if</span> (contained == targetSet)
<a name="l02553"></a>02553                         {
<a name="l02554"></a>02554                         allStateEquateKey = c;
<a name="l02555"></a>02555                         NxsDiscreteStateCell sc = StateCodeForNexusPossibleMultiStateSet(allStateEquateKey, s, *token, UINT_MAX, UINT_MAX, 0L, taxonName);
<a name="l02556"></a>02556                         cLookup[(int) allStateEquateKey] = sc;
<a name="l02557"></a>02557                         <span class="keywordflow">break</span>;
<a name="l02558"></a>02558                         }
<a name="l02559"></a>02559                     }
<a name="l02560"></a>02560                 }
<a name="l02561"></a>02561 
<a name="l02562"></a>02562             }
<a name="l02563"></a>02563         }
<a name="l02564"></a>02564 
<a name="l02565"></a>02565     eqIt = defEq.begin();
<a name="l02566"></a>02566     <span class="keywordflow">for</span> (; eqIt != defEq.end(); ++eqIt)
<a name="l02567"></a>02567         {
<a name="l02568"></a>02568         <span class="keyword">const</span> <span class="keywordtype">char</span> c = eqIt-&gt;first;
<a name="l02569"></a>02569         <span class="keywordflow">if</span> (c == allStateEquateKey)
<a name="l02570"></a>02570             <span class="keywordflow">continue</span>;
<a name="l02571"></a>02571         <span class="keyword">const</span> <span class="keywordtype">char</span> u = toupper(c);
<a name="l02572"></a>02572         <span class="keywordtype">bool</span> addEq = <span class="keyword">true</span>;
<a name="l02573"></a>02573         <span class="keywordflow">if</span> (c == missing || c == matchChar || c == gapChar)
<a name="l02574"></a>02574             addEq = <span class="keyword">false</span>;
<a name="l02575"></a>02575         <span class="keywordflow">if</span> (!respectCase &amp;&amp; (u == toupper(missing) || u == toupper(matchChar) || u == toupper(gapChar)))
<a name="l02576"></a>02576             addEq = <span class="keyword">false</span>;
<a name="l02577"></a>02577         <span class="keywordflow">if</span> (addEq)
<a name="l02578"></a>02578             {
<a name="l02579"></a>02579             <span class="keyword">const</span> <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> &amp; s = eqIt-&gt;second;
<a name="l02580"></a>02580             NxsDiscreteStateCell sc = StateCodeForNexusPossibleMultiStateSet(c, s, *token, UINT_MAX, UINT_MAX, 0L, taxonName);
<a name="l02581"></a>02581             cLookup[(int) c] = sc;
<a name="l02582"></a>02582             }
<a name="l02583"></a>02583         }
<a name="l02584"></a>02584 
<a name="l02585"></a>02585 
<a name="l02586"></a>02586 
<a name="l02587"></a>02587 
<a name="l02588"></a>02588     <span class="comment">/* add user-defined equates, and only retain the new ones (those that are not datatype defaults). */</span>
<a name="l02589"></a>02589     std::map&lt;char, NxsString&gt; neededExtraEquates;
<a name="l02590"></a>02590     <span class="keywordflow">for</span> (eqIt = extraEquates.begin(); eqIt != extraEquates.end(); ++eqIt)
<a name="l02591"></a>02591         {
<a name="l02592"></a>02592         <span class="keyword">const</span> <span class="keywordtype">char</span> c = eqIt-&gt;first;
<a name="l02593"></a>02593         <span class="keyword">const</span> <span class="keywordtype">char</span> u = toupper(c);
<a name="l02594"></a>02594         <span class="keywordflow">if</span> (<a class="code" href="classNxsDiscreteDatatypeMapper_a28dc664593857681cafc6afcdd06693f.html#a28dc664593857681cafc6afcdd06693f" title="Returns NXS_INVALID_STATE_CODE or the index of `c` in the symbols list.">PositionInSymbols</a>(c) == NXS_INVALID_STATE_CODE)
<a name="l02595"></a>02595             {
<a name="l02596"></a>02596             <span class="keywordtype">bool</span> addEq = <span class="keyword">true</span>;
<a name="l02597"></a>02597             <span class="keywordflow">if</span> (c == missing || c == matchChar || c == gapChar)
<a name="l02598"></a>02598                 addEq = <span class="keyword">false</span>;
<a name="l02599"></a>02599             <span class="keywordflow">if</span> (!respectCase &amp;&amp; (u == toupper(missing) || u == toupper(matchChar) || u == toupper(gapChar)))
<a name="l02600"></a>02600                 addEq = <span class="keyword">false</span>;
<a name="l02601"></a>02601             <span class="keywordflow">if</span> (addEq)
<a name="l02602"></a>02602                 {
<a name="l02603"></a>02603                 <span class="keyword">const</span> NxsDiscreteStateCell prevCode = cLookup[(int) c];
<a name="l02604"></a>02604                 <span class="keyword">const</span> <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> &amp; s = eqIt-&gt;second;
<a name="l02605"></a>02605                 NxsDiscreteStateCell sc = StateCodeForNexusPossibleMultiStateSet(c, s, *token, UINT_MAX, UINT_MAX, 0L, taxonName);
<a name="l02606"></a>02606                 cLookup[(int) c] = sc;
<a name="l02607"></a>02607                 <span class="keywordflow">if</span> (sc != prevCode) <span class="comment">/* the equate was new */</span>
<a name="l02608"></a>02608                     neededExtraEquates[c] = s;
<a name="l02609"></a>02609                 }
<a name="l02610"></a>02610             }
<a name="l02611"></a>02611         <span class="keywordflow">else</span>
<a name="l02612"></a>02612             {
<a name="l02613"></a>02613             NCL_ASSERT(convertToStandard); <span class="comment">// a equate key that is equal to a symbol can happen if the symbols list is augmented (resulting in a conversion to standard datatype)</span>
<a name="l02614"></a>02614             }
<a name="l02615"></a>02615         }
<a name="l02616"></a>02616     extraEquates = neededExtraEquates;
<a name="l02617"></a>02617     }
<a name="l02618"></a>02618 
<a name="l02630"></a><a class="code" href="classNxsDiscreteDatatypeMapper_a0e253cf7f7452d69062071932644df4a.html#a0e253cf7f7452d69062071932644df4a">02630</a> NxsDiscreteStateCell <a class="code" href="classNxsDiscreteDatatypeMapper_a0e253cf7f7452d69062071932644df4a.html#a0e253cf7f7452d69062071932644df4a" title="Returns the state code of a (possible new state set) `sset`.">NxsDiscreteDatatypeMapper::StateCodeForStateSet</a>(<span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt; &amp; sset, <span class="keywordtype">bool</span> isPolymorphic, <span class="keywordtype">bool</span> addToLookup, <span class="keywordtype">char</span> nexusSymbol)
<a name="l02631"></a>02631     {
<a name="l02632"></a>02632     <span class="keywordflow">if</span> (sset.size() == 1)
<a name="l02633"></a>02633         {
<a name="l02634"></a>02634         NxsDiscreteStateCell c = *sset.begin();
<a name="l02635"></a>02635         ValidateStateIndex(c);
<a name="l02636"></a>02636         <span class="keywordflow">return</span> c;
<a name="l02637"></a>02637         }
<a name="l02638"></a>02638     NCL_ASSERT(stateCodeLookupPtr);
<a name="l02639"></a>02639     NxsDiscreteStateSetInfo *sclStart = stateCodeLookupPtr + nStates;
<a name="l02640"></a>02640     <span class="keyword">const</span> NxsDiscreteStateCell nCodes = (NxsDiscreteStateCell)stateSetsVec.size();
<a name="l02641"></a>02641 
<a name="l02642"></a>02642     <span class="comment">/*we can start at nStates, because &lt; nStates will be handled in the sset.size() == 1 above */</span>
<a name="l02643"></a>02643     <span class="keywordflow">for</span> (NxsDiscreteStateCell i = nStates - sclOffset; i &lt; nCodes; ++i)
<a name="l02644"></a>02644         {
<a name="l02645"></a>02645         NxsDiscreteStateSetInfo &amp; stateSetInfo = *sclStart++;
<a name="l02646"></a>02646         <span class="keywordflow">if</span> (sset == stateSetInfo.states &amp;&amp; isPolymorphic == stateSetInfo.isPolymorphic)
<a name="l02647"></a>02647             <span class="keywordflow">return</span> i + sclOffset;
<a name="l02648"></a>02648         }
<a name="l02649"></a>02649     <span class="keywordflow">for</span> (std::set&lt;NxsDiscreteStateCell&gt;::const_iterator sIt = sset.begin(); sIt != sset.end(); ++sIt)
<a name="l02650"></a>02650         ValidateStateIndex(*sIt);
<a name="l02651"></a>02651     <span class="keywordflow">if</span> (!isPolymorphic)
<a name="l02652"></a>02652         {
<a name="l02653"></a>02653         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nsymbs = (<span class="keyword">const</span> unsigned)sset.size();
<a name="l02654"></a>02654         <span class="keywordflow">if</span> (gapChar != <span class="charliteral">&#39;\0&#39;</span> &amp;&amp; nsymbs == GetNumStatesIncludingGap())
<a name="l02655"></a>02655             <span class="keywordflow">return</span> NXS_MISSING_CODE;
<a name="l02656"></a>02656         }
<a name="l02657"></a>02657     <span class="keywordflow">if</span> (!addToLookup)
<a name="l02658"></a>02658         <span class="keywordflow">return</span> NXS_INVALID_STATE_CODE;
<a name="l02659"></a>02659     <span class="keywordflow">return</span> AddStateSet(sset, nexusSymbol, <span class="keyword">true</span>, isPolymorphic);
<a name="l02660"></a>02660     }
<a name="l02661"></a>02661 
<a name="l02668"></a>02668 NxsDiscreteStateCell NxsDiscreteDatatypeMapper::AddStateSet(<span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt; &amp; states, <span class="keywordtype">char</span> nexusSymbol, <span class="keywordtype">bool</span> symRespectCase, <span class="keywordtype">bool</span> isPolymorphic)
<a name="l02669"></a>02669     {
<a name="l02670"></a>02670     stateIntersectionMatrix.clear();
<a name="l02671"></a>02671     isStateSubsetMatrix.clear();
<a name="l02672"></a>02672     isStateSubsetMatrixGapsMissing.clear();
<a name="l02673"></a>02673 
<a name="l02674"></a>02674 
<a name="l02675"></a>02675     <span class="keywordtype">bool</span> reallyIsPoly = (states.size() &gt; 1 &amp;&amp; isPolymorphic);
<a name="l02676"></a>02676     <span class="keywordtype">char</span> sym = (symRespectCase ? nexusSymbol : (char) toupper(nexusSymbol));
<a name="l02677"></a>02677     stateSetsVec.push_back(NxsDiscreteStateSetInfo(states, reallyIsPoly, sym));
<a name="l02678"></a>02678     <span class="comment">/* if we have gaps, then the sclOffset is -1 and we want to enable</span>
<a name="l02679"></a>02679 <span class="comment">        stateCodeLookup[-1], so we set stateCodeLookup to &amp;stateSets[1]</span>
<a name="l02680"></a>02680 <span class="comment">        hence the -sclOffset below</span>
<a name="l02681"></a>02681 <span class="comment">    */</span>
<a name="l02682"></a>02682     stateCodeLookupPtr = &amp;stateSetsVec[-sclOffset];
<a name="l02683"></a>02683 
<a name="l02684"></a>02684     <span class="keyword">const</span> NxsDiscreteStateCell stateCode = (<span class="keyword">const</span> NxsDiscreteStateCell)stateSetsVec.size() + sclOffset - 1;
<a name="l02685"></a>02685     <span class="keywordflow">if</span> (nexusSymbol != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l02686"></a>02686         {
<a name="l02687"></a>02687         <span class="keywordflow">if</span> (symRespectCase)
<a name="l02688"></a>02688             cLookup[(int) nexusSymbol] = stateCode;
<a name="l02689"></a>02689         <span class="keywordflow">else</span>
<a name="l02690"></a>02690             {
<a name="l02691"></a>02691             cLookup[(int) tolower(nexusSymbol)] = stateCode;
<a name="l02692"></a>02692             cLookup[(int) toupper(nexusSymbol)] = stateCode;
<a name="l02693"></a>02693             }
<a name="l02694"></a>02694         }
<a name="l02695"></a>02695     <span class="keywordflow">return</span> stateCode;
<a name="l02696"></a>02696     }
<a name="l02697"></a>02697 
<a name="l02698"></a>02698 
<a name="l02699"></a>02699 
<a name="l02703"></a>02703 <span class="keywordtype">void</span> NxsDiscreteDatatypeMapper::ValidateStateIndex(NxsDiscreteStateCell c)<span class="keyword"> const</span>
<a name="l02704"></a>02704 <span class="keyword">    </span>{
<a name="l02705"></a>02705     <span class="keywordflow">if</span> (c &lt; NXS_MISSING_CODE)
<a name="l02706"></a>02706         {
<a name="l02707"></a>02707         <span class="keywordflow">if</span> (c == NXS_GAP_STATE_CODE)
<a name="l02708"></a>02708             {
<a name="l02709"></a>02709             <span class="keywordflow">if</span> (gapChar == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l02710"></a>02710                 <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(<span class="stringliteral">&quot;Illegal usage of NXS_GAP_STATE_CODE in a datatype without gaps&quot;</span>);
<a name="l02711"></a>02711             <span class="keywordflow">return</span>;
<a name="l02712"></a>02712             }
<a name="l02713"></a>02713         <span class="keywordflow">if</span> (c == NXS_INVALID_STATE_CODE)
<a name="l02714"></a>02714             <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(<span class="stringliteral">&quot;Illegal usage of NXS_INVALID_STATE_CODE as a state index&quot;</span>);
<a name="l02715"></a>02715         <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(<span class="stringliteral">&quot;Illegal usage of unknown negative state index&quot;</span>);
<a name="l02716"></a>02716         }
<a name="l02717"></a>02717     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c &gt;= (NxsDiscreteStateCell) nStates)
<a name="l02718"></a>02718         <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(<span class="stringliteral">&quot;Illegal usage of state index &gt;= the number of states&quot;</span>);
<a name="l02719"></a>02719     }
<a name="l02720"></a>02720 
<a name="l02724"></a>02724 <span class="keywordtype">void</span> NxsDiscreteDatatypeMapper::ValidateStateCode(NxsDiscreteStateCell c)<span class="keyword"> const</span>
<a name="l02725"></a>02725 <span class="keyword">    </span>{
<a name="l02726"></a>02726     <span class="keywordflow">if</span> (c &lt; sclOffset)
<a name="l02727"></a>02727         {
<a name="l02728"></a>02728         <span class="keywordflow">if</span> (c == NXS_GAP_STATE_CODE)
<a name="l02729"></a>02729             <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(<span class="stringliteral">&quot;Illegal usage of NXS_GAP_STATE_CODE in a datatype without gaps&quot;</span>);
<a name="l02730"></a>02730         <span class="keywordflow">if</span> (c == NXS_INVALID_STATE_CODE)
<a name="l02731"></a>02731             <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(<span class="stringliteral">&quot;Illegal usage of NXS_INVALID_STATE_CODE as a state code&quot;</span>);
<a name="l02732"></a>02732         <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(<span class="stringliteral">&quot;Illegal usage of unknown negative state index&quot;</span>);
<a name="l02733"></a>02733         }
<a name="l02734"></a>02734     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c &gt;= (((NxsDiscreteStateCell) stateSetsVec.size()) + sclOffset))
<a name="l02735"></a>02735         <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(<span class="stringliteral">&quot;Illegal usage of state code &gt; the highest state code&quot;</span>);
<a name="l02736"></a>02736     }
<a name="l02737"></a>02737 
<a name="l02738"></a>02738 
<a name="l02739"></a>02739 <span class="keywordtype">void</span> NxsDiscreteDatatypeMapper::GenerateNxsExceptionMatrixReading(<span class="keywordtype">char</span> <span class="keyword">const</span>* message, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> taxInd, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> charInd,
<a name="l02740"></a>02740 <a class="code" href="classNxsToken.html">NxsToken</a>&amp; token, <span class="keyword">const</span> <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> &amp;nameStr)
<a name="l02741"></a>02741     {
<a name="l02742"></a>02742     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> e = <span class="stringliteral">&quot;Error reading character &quot;</span>;
<a name="l02743"></a>02743     e &lt;&lt; charInd + 1&lt;&lt;<span class="stringliteral">&quot; for taxon &quot;</span> &lt;&lt; taxInd + 1;
<a name="l02744"></a>02744     <span class="keywordflow">if</span> (!nameStr.empty())
<a name="l02745"></a>02745         {
<a name="l02746"></a>02746         <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> nasn;
<a name="l02747"></a>02747         nasn &lt;&lt; taxInd + 1;
<a name="l02748"></a>02748         <span class="keywordflow">if</span> (nasn != nameStr)
<a name="l02749"></a>02749             e &lt;&lt; <span class="stringliteral">&quot; (name \&quot;&quot;</span>&lt;&lt; nameStr &lt;&lt;<span class="stringliteral">&quot;\&quot;)&quot;</span>;
<a name="l02750"></a>02750         }
<a name="l02751"></a>02751     e &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span> &lt;&lt; message;
<a name="l02752"></a>02752     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(e, token);
<a name="l02753"></a>02753     }
<a name="l02754"></a>02754 
<a name="l02759"></a><a class="code" href="classNxsDiscreteDatatypeMapper_afe4f8b3edb65863211bcd5a2746215e3.html#afe4f8b3edb65863211bcd5a2746215e3">02759</a> <span class="keywordtype">bool</span> <a class="code" href="classNxsDiscreteDatatypeMapper_afe4f8b3edb65863211bcd5a2746215e3.html#afe4f8b3edb65863211bcd5a2746215e3" title="Returns true if the state code maps to a collection of states that were flagged as...">NxsDiscreteDatatypeMapper::IsPolymorphic</a>(NxsDiscreteStateCell c)<span class="keyword"> const</span>
<a name="l02760"></a>02760 <span class="keyword">    </span>{
<a name="l02761"></a>02761     NCL_ASSERT(stateCodeLookupPtr);
<a name="l02762"></a>02762     ValidateStateCode(c);
<a name="l02763"></a>02763     <span class="keywordflow">return</span> stateCodeLookupPtr[c].isPolymorphic;
<a name="l02764"></a>02764     }
<a name="l02765"></a>02765 
<a name="l02766"></a>02766 
<a name="l02773"></a><a class="code" href="classNxsDiscreteDatatypeMapper_a28dc664593857681cafc6afcdd06693f.html#a28dc664593857681cafc6afcdd06693f">02773</a> NxsDiscreteStateCell <a class="code" href="classNxsDiscreteDatatypeMapper_a28dc664593857681cafc6afcdd06693f.html#a28dc664593857681cafc6afcdd06693f" title="Returns NXS_INVALID_STATE_CODE or the index of `c` in the symbols list.">NxsDiscreteDatatypeMapper::PositionInSymbols</a>(<span class="keywordtype">char</span> c)<span class="keyword"> const</span>
<a name="l02774"></a>02774 <span class="keyword">    </span>{
<a name="l02775"></a>02775     NxsDiscreteStateCell p = (NxsDiscreteStateCell)symbols.find(c);
<a name="l02776"></a>02776     <span class="keywordflow">if</span> (p &gt;= 0 &amp;&amp; p &lt; (NxsDiscreteStateCell) nStates)
<a name="l02777"></a>02777         <span class="keywordflow">return</span> p;
<a name="l02778"></a>02778     <span class="keywordflow">if</span> (!respectCase)
<a name="l02779"></a>02779         {
<a name="l02780"></a>02780         p = (NxsDiscreteStateCell)lcsymbols.find(c);
<a name="l02781"></a>02781         <span class="keywordflow">if</span> (p &gt;= 0 &amp;&amp; p &lt; (NxsDiscreteStateCell) nStates)
<a name="l02782"></a>02782             <span class="keywordflow">return</span> p;
<a name="l02783"></a>02783         }
<a name="l02784"></a>02784     <span class="keywordflow">return</span> NXS_INVALID_STATE_CODE;
<a name="l02785"></a>02785     }
<a name="l02786"></a>02786 
<a name="l02787"></a>02787 
<a name="l02797"></a><a class="code" href="classNxsDiscreteDatatypeMapper_a60f67a89207c16b0f5e297c6d43a313a.html#a60f67a89207c16b0f5e297c6d43a313a">02797</a> <span class="keywordtype">void</span> <a class="code" href="classNxsDiscreteDatatypeMapper_a60f67a89207c16b0f5e297c6d43a313a.html#a60f67a89207c16b0f5e297c6d43a313a" title="Returns the NEXUS reperesenation of the state code `scode` which may be a multiple...">NxsDiscreteDatatypeMapper::WriteStateCodeAsNexusString</a>(std::ostream &amp; out, NxsDiscreteStateCell scode, <span class="keywordtype">bool</span> demandSymbols)<span class="keyword"> const</span>
<a name="l02798"></a>02798 <span class="keyword">    </span>{
<a name="l02799"></a>02799     ValidateStateCode(scode);
<a name="l02800"></a>02800     <span class="keyword">const</span> NxsDiscreteStateSetInfo * ssi = &amp;(stateSetsVec.at(scode-sclOffset));
<a name="l02801"></a>02801     <span class="keyword">const</span> NxsDiscreteStateSetInfo &amp; stateSetInfo =  stateCodeLookupPtr[scode];
<a name="l02802"></a>02802     NCL_ASSERT (ssi == &amp;stateSetInfo);
<a name="l02803"></a>02803     <span class="keywordtype">char</span> c = stateSetInfo.nexusSymbol;
<a name="l02804"></a>02804     <span class="keywordflow">if</span> (c != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l02805"></a>02805         {
<a name="l02806"></a>02806         out &lt;&lt; c;
<a name="l02807"></a>02807         <span class="keywordflow">return</span>;
<a name="l02808"></a>02808         }
<a name="l02809"></a>02809     std::string towrite;
<a name="l02810"></a>02810     std::set&lt;NxsDiscreteStateCell&gt;::const_iterator sIt = stateSetInfo.states.begin();
<a name="l02811"></a>02811     <span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt;::const_iterator endIt = stateSetInfo.states.end();
<a name="l02812"></a>02812     <span class="keywordflow">for</span> (; sIt != endIt; ++sIt)
<a name="l02813"></a>02813         {
<a name="l02814"></a>02814         <span class="keyword">const</span> NxsDiscreteStateCell state = *sIt;
<a name="l02815"></a>02815         <span class="keyword">const</span> NxsDiscreteStateSetInfo &amp; subStateSetInfo =  stateCodeLookupPtr[state];
<a name="l02816"></a>02816         <span class="keyword">const</span> <span class="keywordtype">char</span> subc = subStateSetInfo.nexusSymbol;
<a name="l02817"></a>02817         <span class="keywordflow">if</span> (subc != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l02818"></a>02818             towrite.append(1, subc);
<a name="l02819"></a>02819         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (demandSymbols)
<a name="l02820"></a>02820             {
<a name="l02821"></a>02821             <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> err(<span class="stringliteral">&quot;No symbol found for state code &quot;</span>);
<a name="l02822"></a>02822             err &lt;&lt; state;
<a name="l02823"></a>02823             <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(err);
<a name="l02824"></a>02824             }
<a name="l02825"></a>02825         <span class="keywordflow">else</span>
<a name="l02826"></a>02826             <span class="keywordflow">return</span>;
<a name="l02827"></a>02827         }
<a name="l02828"></a>02828 
<a name="l02829"></a>02829     out &lt;&lt;  (stateSetInfo.isPolymorphic ? <span class="charliteral">&#39;(&#39;</span> : <span class="charliteral">&#39;{&#39;</span>);
<a name="l02830"></a>02830     out &lt;&lt; towrite;
<a name="l02831"></a>02831     out &lt;&lt;  (stateSetInfo.isPolymorphic ? <span class="charliteral">&#39;)&#39;</span> : <span class="charliteral">&#39;}&#39;</span>);
<a name="l02832"></a>02832     }
<a name="l02833"></a>02833 
<a name="l02834"></a>02834 <span class="keywordtype">unsigned</span> NxsDiscreteDatatypeMapper::GetNumStatesInStateCode(NxsDiscreteStateCell scode)<span class="keyword"> const</span>
<a name="l02835"></a>02835 <span class="keyword">    </span>{
<a name="l02836"></a>02836     ValidateStateCode(scode);
<a name="l02837"></a>02837     <span class="keyword">const</span> NxsDiscreteStateSetInfo &amp; stateSetInfo =  stateCodeLookupPtr[scode];
<a name="l02838"></a>02838     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span>)stateSetInfo.states.size();
<a name="l02839"></a>02839     }
<a name="l02840"></a>02840 
<a name="l02841"></a>02841 <span class="keywordtype">void</span> NxsDiscreteDatatypeMapper::WriteStartOfFormatCommand(std::ostream &amp; out)<span class="keyword"> const</span>
<a name="l02842"></a>02842 <span class="keyword">    </span>{
<a name="l02843"></a>02843     out &lt;&lt; <span class="stringliteral">&quot;    FORMAT Datatype=&quot;</span> &lt;&lt; NxsCharactersBlock::GetNameOfDatatype(datatype);
<a name="l02844"></a>02844     <span class="keywordflow">if</span> (this-&gt;missing != <span class="charliteral">&#39;?&#39;</span>)
<a name="l02845"></a>02845         {
<a name="l02846"></a>02846         out &lt;&lt; <span class="stringliteral">&quot; Missing=&quot;</span>;
<a name="l02847"></a>02847         out &lt;&lt; this-&gt;missing;
<a name="l02848"></a>02848         }
<a name="l02849"></a>02849     <span class="keywordflow">if</span> (this-&gt;gapChar != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l02850"></a>02850         {
<a name="l02851"></a>02851         out &lt;&lt; <span class="stringliteral">&quot;  Gap=&quot;</span>;
<a name="l02852"></a>02852         out &lt;&lt; this-&gt;gapChar;
<a name="l02853"></a>02853         }
<a name="l02854"></a>02854     <span class="keywordflow">if</span> (this-&gt;datatype != <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>)
<a name="l02855"></a>02855         {
<a name="l02856"></a>02856         <span class="keywordtype">unsigned</span> numDefStates = 4;
<a name="l02857"></a>02857         <span class="keywordflow">if</span> (this-&gt;datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca6867b9b05a5ce824179b5bdf10c891fc" title="indicates `matrix&amp;#39; holds nucleotide sequences">NxsCharactersBlock::protein</a>)
<a name="l02858"></a>02858             numDefStates = 21;
<a name="l02859"></a>02859         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this-&gt;datatype == NxsCharactersBlock::standard)
<a name="l02860"></a>02860             numDefStates = 0;
<a name="l02861"></a>02861         <span class="keywordtype">unsigned</span> nSym = (unsigned)this-&gt;symbols.length();
<a name="l02862"></a>02862         <span class="keywordflow">if</span> (nSym &gt; numDefStates &amp;&amp; this-&gt;datatype != <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa11d7fb339c6f83517338e0e6faac722" title="indicates `matrix&amp;#39; holds amino acid sequences">NxsCharactersBlock::codon</a>)
<a name="l02863"></a>02863             {
<a name="l02864"></a>02864             out &lt;&lt; <span class="stringliteral">&quot; Symbols=\&quot;&quot;</span>;
<a name="l02865"></a>02865             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = numDefStates; i &lt; nSym; ++i)
<a name="l02866"></a>02866                 {
<a name="l02867"></a>02867                 <span class="keywordtype">char</span> c = symbols[i];
<a name="l02868"></a>02868                 <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;\0&#39;</span>)
<a name="l02869"></a>02869                     <span class="keywordflow">break</span>;
<a name="l02870"></a>02870                 out &lt;&lt; c;
<a name="l02871"></a>02871                 }
<a name="l02872"></a>02872             out &lt;&lt;<span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l02873"></a>02873             }
<a name="l02874"></a>02874         }
<a name="l02875"></a>02875     <span class="keyword">const</span> std::map&lt;char, NxsString&gt; defEquates = NxsCharactersBlock::GetDefaultEquates(datatype);
<a name="l02876"></a>02876     std::map&lt;char, NxsString&gt; toWrite;
<a name="l02877"></a>02877     <span class="keyword">const</span> std::map&lt;char, NxsString&gt;::const_iterator notFound = defEquates.end();
<a name="l02878"></a>02878     std::map&lt;char, NxsString&gt;::const_iterator inDefEquates;
<a name="l02879"></a>02879     <span class="keywordflow">for</span> (std::map&lt;char, NxsString&gt;::const_iterator i = extraEquates.begin(); i != extraEquates.end(); ++i)
<a name="l02880"></a>02880         {
<a name="l02881"></a>02881         <span class="keyword">const</span> <span class="keywordtype">char</span> key =  (*i).first;
<a name="l02882"></a>02882         <span class="keyword">const</span> <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> val =  i-&gt;second;
<a name="l02883"></a>02883         inDefEquates = defEquates.find(key);
<a name="l02884"></a>02884         <span class="keywordflow">if</span> (inDefEquates == notFound || inDefEquates-&gt;second != val)
<a name="l02885"></a>02885             toWrite[key] = val;
<a name="l02886"></a>02886         }
<a name="l02887"></a>02887     <span class="keywordflow">if</span> (toWrite.size() &gt; 0)
<a name="l02888"></a>02888         {
<a name="l02889"></a>02889         out &lt;&lt; <span class="stringliteral">&quot; Equate=\&quot;&quot;</span>;
<a name="l02890"></a>02890         <span class="keywordflow">for</span> (std::map&lt;char, NxsString&gt;::const_iterator j = toWrite.begin(); j != toWrite.end(); ++j)
<a name="l02891"></a>02891             out &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; j-&gt;first &lt;&lt; <span class="charliteral">&#39;=&#39;</span> &lt;&lt; j-&gt;second;
<a name="l02892"></a>02892         out &lt;&lt;<span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l02893"></a>02893         }
<a name="l02894"></a>02894     }
<a name="l02895"></a>02895 
<a name="l02896"></a>02896 <span class="keywordtype">bool</span> NxsCharactersBlock::HandleNextContinuousState(<a class="code" href="classNxsToken.html">NxsToken</a> &amp;token, <span class="keywordtype">unsigned</span> taxNum, <span class="keywordtype">unsigned</span> charNum, ContinuousCharRow &amp; row, <span class="keyword">const</span> <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> &amp; )
<a name="l02897"></a>02897     {
<a name="l02898"></a>02898     <span class="keywordflow">if</span> (interleaving)
<a name="l02899"></a>02899         token.<a class="code" href="classNxsToken_afa5232738ca19e069173e8befe75e730.html#afa5232738ca19e069173e8befe75e730" title="Sets the bit specified in the variable `labileFlags&amp;#39;.">SetLabileFlagBit</a>(NxsToken::newlineIsToken);
<a name="l02900"></a>02900     token.<a class="code" href="classNxsToken_afa5232738ca19e069173e8befe75e730.html#afa5232738ca19e069173e8befe75e730" title="Sets the bit specified in the variable `labileFlags&amp;#39;.">SetLabileFlagBit</a>(NxsToken::hyphenNotPunctuation);
<a name="l02901"></a>02901     std::vector&lt;double&gt; v;
<a name="l02902"></a>02902     std::vector&lt;int&gt; scored;
<a name="l02903"></a>02903     token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l02904"></a>02904     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> t;
<a name="l02905"></a>02905     <span class="keywordflow">if</span> (interleaving &amp;&amp; token.<a class="code" href="classNxsToken_ad2671eb776f8f76ac946fd5b76e93c0a.html#ad2671eb776f8f76ac946fd5b76e93c0a" title="Returns true if and only if last call to GetNextToken encountered the newline character...">AtEOL</a>())
<a name="l02906"></a>02906         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02907"></a>02907     <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;(&quot;</span>))
<a name="l02908"></a>02908         {
<a name="l02909"></a>02909         token.<a class="code" href="classNxsToken_afa5232738ca19e069173e8befe75e730.html#afa5232738ca19e069173e8befe75e730" title="Sets the bit specified in the variable `labileFlags&amp;#39;.">SetLabileFlagBit</a>(NxsToken::hyphenNotPunctuation);
<a name="l02910"></a>02910         token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l02911"></a>02911         <span class="keywordflow">while</span> (!token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;)&quot;</span>))
<a name="l02912"></a>02912             {
<a name="l02913"></a>02913             t = token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>();
<a name="l02914"></a>02914             <span class="keywordflow">if</span> (t.length() == 1 &amp;&amp; (t[0] == missing || t[0] == gap))
<a name="l02915"></a>02915                 {
<a name="l02916"></a>02916                 v.push_back(DBL_MAX);
<a name="l02917"></a>02917                 scored.push_back(0);
<a name="l02918"></a>02918                 }
<a name="l02919"></a>02919             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t.length() == 1 &amp;&amp; t[0] == matchchar)
<a name="l02920"></a>02920                 {
<a name="l02921"></a>02921                 v.push_back(DBL_MAX);
<a name="l02922"></a>02922                 scored.push_back(2);
<a name="l02923"></a>02923                 }
<a name="l02924"></a>02924             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!t.<a class="code" href="classNxsString_a75e55f7b719838d83e6af1581170dbd9.html#a75e55f7b719838d83e6af1581170dbd9" title="Returns true if the stored string can be interpreted as a double value, and returns...">IsADouble</a>())
<a name="l02925"></a>02925                 <a class="code" href="classNxsBlock_a913d7706d555abfb1570e036875ba9be.html#a913d7706d555abfb1570e036875ba9be" title="throws a NxsException with the token info for `token` `expected` should fill in the...">GenerateUnexpectedTokenNxsException</a>(token, <span class="stringliteral">&quot;a number&quot;</span>);
<a name="l02926"></a>02926             <span class="keywordflow">else</span>
<a name="l02927"></a>02927                 {
<a name="l02928"></a>02928                 v.push_back(t.<a class="code" href="classNxsString_ab0ba8827ba9778ace41c65e5c4908471.html#ab0ba8827ba9778ace41c65e5c4908471" title="Converts the stored string to a double using the standard C function strtod, throwing...">ConvertToDouble</a>());
<a name="l02929"></a>02929                 scored.push_back(1);
<a name="l02930"></a>02930                 }
<a name="l02931"></a>02931             token.<a class="code" href="classNxsToken_afa5232738ca19e069173e8befe75e730.html#afa5232738ca19e069173e8befe75e730" title="Sets the bit specified in the variable `labileFlags&amp;#39;.">SetLabileFlagBit</a>(NxsToken::hyphenNotPunctuation);
<a name="l02932"></a>02932             token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l02933"></a>02933             }
<a name="l02934"></a>02934         }
<a name="l02935"></a>02935     <span class="keywordflow">else</span>
<a name="l02936"></a>02936         {
<a name="l02937"></a>02937         t = token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>();
<a name="l02938"></a>02938         <span class="keywordflow">if</span> (t.length() == 1 &amp;&amp; (t[0] == missing || t[0] == gap))
<a name="l02939"></a>02939             {
<a name="l02940"></a>02940             v.push_back(DBL_MAX);
<a name="l02941"></a>02941             scored.push_back(0);
<a name="l02942"></a>02942             }
<a name="l02943"></a>02943         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t.length() == 1 &amp;&amp; t[0] == matchchar)
<a name="l02944"></a>02944             {
<a name="l02945"></a>02945             v.push_back(DBL_MAX);
<a name="l02946"></a>02946             scored.push_back(2);
<a name="l02947"></a>02947             }
<a name="l02948"></a>02948         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!t.<a class="code" href="classNxsString_a75e55f7b719838d83e6af1581170dbd9.html#a75e55f7b719838d83e6af1581170dbd9" title="Returns true if the stored string can be interpreted as a double value, and returns...">IsADouble</a>())
<a name="l02949"></a>02949             <a class="code" href="classNxsBlock_a913d7706d555abfb1570e036875ba9be.html#a913d7706d555abfb1570e036875ba9be" title="throws a NxsException with the token info for `token` `expected` should fill in the...">GenerateUnexpectedTokenNxsException</a>(token, <span class="stringliteral">&quot;a number&quot;</span>);
<a name="l02950"></a>02950         <span class="keywordflow">else</span>
<a name="l02951"></a>02951             {
<a name="l02952"></a>02952             v.push_back(t.<a class="code" href="classNxsString_ab0ba8827ba9778ace41c65e5c4908471.html#ab0ba8827ba9778ace41c65e5c4908471" title="Converts the stored string to a double using the standard C function strtod, throwing...">ConvertToDouble</a>());
<a name="l02953"></a>02953             scored.push_back(1);
<a name="l02954"></a>02954             }
<a name="l02955"></a>02955         }
<a name="l02956"></a>02956     <span class="keywordtype">unsigned</span> n_read = (unsigned)v.size();
<a name="l02957"></a>02957     <span class="keywordflow">if</span> (n_read &lt; items.size())
<a name="l02958"></a>02958         {
<a name="l02959"></a>02959         errormsg.<a class="code" href="classNxsString_abbf904c772d9776139dcae602c9fd06b.html#abbf904c772d9776139dcae602c9fd06b" title="Most containers in the standard template library can be completely erased using the...">clear</a>();
<a name="l02960"></a>02960         errormsg &lt;&lt; <span class="stringliteral">&quot;For each cell of the MATRIX a value for each of the &quot;</span> &lt;&lt; (unsigned)items.size() &lt;&lt;  <span class="stringliteral">&quot; ITEMS listed in the FORMAT command is expected.\nOnly &quot;</span> &lt;&lt;  n_read &lt;&lt; <span class="stringliteral">&quot; values read.&quot;</span>;
<a name="l02961"></a>02961         <a class="code" href="classNxsBlock_a9106779865a661477259f3d84edb36a5.html#a9106779865a661477259f3d84edb36a5" title="throws a NxsException with the token info for `token` `expected` should fill in the...">GenerateNxsException</a>(token);
<a name="l02962"></a>02962         }
<a name="l02963"></a>02963     <span class="comment">// We&#39;ve read in the state now, so if this character has been eliminated, we don&#39;t want to go any further with it</span>
<a name="l02964"></a>02964     <span class="comment">//</span>
<a name="l02965"></a>02965     <span class="keywordflow">if</span> (charNum == UINT_MAX)
<a name="l02966"></a>02966         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02967"></a>02967 
<a name="l02968"></a>02968     <span class="keywordflow">if</span> (charNum &gt; row.size())
<a name="l02969"></a>02969         <a class="code" href="classNxsBlock_a9106779865a661477259f3d84edb36a5.html#a9106779865a661477259f3d84edb36a5" title="throws a NxsException with the token info for `token` `expected` should fill in the...">GenerateNxsException</a>(token, <span class="stringliteral">&quot;Internal Error: character index out of range in continuousMatrix.&quot;</span>);
<a name="l02970"></a>02970 
<a name="l02971"></a>02971     ContinuousCharCell &amp; cell = row[charNum];
<a name="l02972"></a>02972     cell.clear();
<a name="l02973"></a>02973 
<a name="l02974"></a>02974     std::vector&lt;std::string &gt;::const_iterator itemIt = items.begin();
<a name="l02975"></a>02975     std::string key;
<a name="l02976"></a>02976     <span class="keywordtype">unsigned</span> curr_ind_in_v = 0;
<a name="l02977"></a>02977     <span class="keywordflow">for</span> (; itemIt != items.end(); ++itemIt, ++curr_ind_in_v)
<a name="l02978"></a>02978         {
<a name="l02979"></a>02979         key = *itemIt;
<a name="l02980"></a>02980         <span class="keywordflow">if</span> (scored[curr_ind_in_v] == 1)
<a name="l02981"></a>02981             cell[key] = vector&lt;double&gt;(1, v[curr_ind_in_v]);
<a name="l02982"></a>02982         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (scored[curr_ind_in_v] == 0)
<a name="l02983"></a>02983             cell[key] = vector&lt;double&gt;();
<a name="l02984"></a>02984         <span class="keywordflow">else</span>
<a name="l02985"></a>02985             {
<a name="l02986"></a>02986             <span class="keywordflow">if</span> (taxNum == 0)
<a name="l02987"></a>02987                 <a class="code" href="classNxsBlock_a9106779865a661477259f3d84edb36a5.html#a9106779865a661477259f3d84edb36a5" title="throws a NxsException with the token info for `token` `expected` should fill in the...">GenerateNxsException</a>(token, <span class="stringliteral">&quot;MATCHCHAR cannot be used in the first taxon&quot;</span>);
<a name="l02988"></a>02988             <span class="keyword">const</span> vector&lt;double&gt; &amp; first_taxon_vector = continuousMatrix[0][charNum][key];
<a name="l02989"></a>02989             <span class="keywordflow">if</span> (first_taxon_vector.empty())
<a name="l02990"></a>02990                 <a class="code" href="classNxsBlock_a9106779865a661477259f3d84edb36a5.html#a9106779865a661477259f3d84edb36a5" title="throws a NxsException with the token info for `token` `expected` should fill in the...">GenerateNxsException</a>(token, <span class="stringliteral">&quot;First taxon does not have a value to copy, but a MATCHCHAR was found.&quot;</span>);
<a name="l02991"></a>02991             <span class="keywordflow">else</span>
<a name="l02992"></a>02992                 cell[key] = vector&lt;double&gt;(1, first_taxon_vector[0]);
<a name="l02993"></a>02993             }
<a name="l02994"></a>02994         }
<a name="l02995"></a>02995     <span class="keywordtype">unsigned</span> curr_ind_mapped = 1;
<a name="l02996"></a>02996     <span class="keywordflow">if</span> (!key.empty() &amp;&amp; curr_ind_in_v &lt; n_read)
<a name="l02997"></a>02997         {
<a name="l02998"></a>02998         vector&lt;double&gt; &amp; curr_cell_vector = cell[key];
<a name="l02999"></a>02999         <span class="keywordflow">for</span> (; curr_ind_in_v &lt; n_read; ++curr_ind_in_v, ++curr_ind_mapped)
<a name="l03000"></a>03000             {
<a name="l03001"></a>03001             <span class="keywordflow">if</span> (scored[curr_ind_in_v] == 1)
<a name="l03002"></a>03002                 curr_cell_vector.push_back(v[curr_ind_in_v]);
<a name="l03003"></a>03003             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (scored[curr_ind_in_v] != 0)
<a name="l03004"></a>03004                 curr_cell_vector.push_back(DBL_MAX);
<a name="l03005"></a>03005             <span class="keywordflow">else</span>
<a name="l03006"></a>03006                 {
<a name="l03007"></a>03007                 <span class="keywordflow">if</span> (taxNum == 0)
<a name="l03008"></a>03008                     <a class="code" href="classNxsBlock_a9106779865a661477259f3d84edb36a5.html#a9106779865a661477259f3d84edb36a5" title="throws a NxsException with the token info for `token` `expected` should fill in the...">GenerateNxsException</a>(token, <span class="stringliteral">&quot;MATCHCHAR cannot be used in the first taxon&quot;</span>);
<a name="l03009"></a>03009                 <span class="keyword">const</span> vector&lt;double&gt; &amp; first_taxon_vector = continuousMatrix[0][charNum][key];
<a name="l03010"></a>03010                 <span class="keywordflow">if</span> (first_taxon_vector.size() &lt; curr_ind_mapped+1)
<a name="l03011"></a>03011                     <a class="code" href="classNxsBlock_a9106779865a661477259f3d84edb36a5.html#a9106779865a661477259f3d84edb36a5" title="throws a NxsException with the token info for `token` `expected` should fill in the...">GenerateNxsException</a>(token, <span class="stringliteral">&quot;First taxon does not have a value to copy, but a MATCHCHAR was found.&quot;</span>);
<a name="l03012"></a>03012                 <span class="keywordflow">else</span>
<a name="l03013"></a>03013                     curr_cell_vector.push_back(first_taxon_vector[curr_ind_mapped]);
<a name="l03014"></a>03014                 }
<a name="l03015"></a>03015             }
<a name="l03016"></a>03016         }
<a name="l03017"></a>03017     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03018"></a>03018     }
<a name="l03019"></a>03019 
<a name="l03020"></a>03020 NxsDiscreteStateCell NxsDiscreteDatatypeMapper::StateCodeForNexusChar(
<a name="l03021"></a>03021   <span class="keyword">const</span> <span class="keywordtype">char</span> currChar,
<a name="l03022"></a>03022   <a class="code" href="classNxsToken.html">NxsToken</a> &amp;token,
<a name="l03023"></a>03023   <span class="keywordtype">unsigned</span> taxNum,      <span class="comment">/* the taxon index, in range [0..`ntax&#39;) */</span>
<a name="l03024"></a>03024   <span class="keywordtype">unsigned</span> charNum,     <span class="comment">/* the character index, in range [0..`nChar&#39;) */</span>
<a name="l03025"></a>03025   <span class="keyword">const</span> NxsDiscreteStateRow * firstTaxonRow,
<a name="l03026"></a>03026   <span class="keyword">const</span> <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> &amp; nameStr)<span class="keyword"> const</span>
<a name="l03027"></a>03027 <span class="keyword">    </span>{
<a name="l03028"></a>03028     NxsDiscreteStateCell currState = cLookup[<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(currChar)];
<a name="l03029"></a>03029     <span class="keywordflow">if</span> (currState == NXS_INVALID_STATE_CODE)
<a name="l03030"></a>03030         {
<a name="l03031"></a>03031         <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> emsg;
<a name="l03032"></a>03032         <span class="keywordflow">if</span> (currChar == matchChar)
<a name="l03033"></a>03033             {
<a name="l03034"></a>03034             <span class="keywordflow">if</span> (firstTaxonRow == NULL)
<a name="l03035"></a>03035                 GenerateNxsExceptionMatrixReading(<span class="stringliteral">&quot;Unexpected use of MatchChar in first taxon with data.&quot;</span>, taxNum, charNum, token, nameStr);
<a name="l03036"></a>03036             <span class="keywordflow">if</span> (firstTaxonRow-&gt;size() &lt;= charNum)
<a name="l03037"></a>03037                 {
<a name="l03038"></a>03038                 emsg &lt;&lt; <span class="stringliteral">&quot;MatchChar found for character number &quot;</span>  &lt;&lt; charNum+1 &lt;&lt; <span class="stringliteral">&quot; but the first taxon does not have a character state stored for this character.&quot;</span>;
<a name="l03039"></a>03039                 GenerateNxsExceptionMatrixReading(emsg, taxNum, charNum, token, nameStr);
<a name="l03040"></a>03040                 }
<a name="l03041"></a>03041             currState = (*firstTaxonRow)[charNum];
<a name="l03042"></a>03042             }
<a name="l03043"></a>03043         <span class="keywordflow">else</span>
<a name="l03044"></a>03044             {
<a name="l03045"></a>03045             emsg &lt;&lt; <span class="stringliteral">&quot;Invalid state specified \&quot;&quot;</span> &lt;&lt; token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>() &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l03046"></a>03046             GenerateNxsExceptionMatrixReading(emsg, taxNum, charNum, token, nameStr);
<a name="l03047"></a>03047             }
<a name="l03048"></a>03048         }
<a name="l03049"></a>03049     <span class="keywordflow">return</span> currState;
<a name="l03050"></a>03050     }
<a name="l03051"></a>03051 
<a name="l03052"></a>03052 <span class="keywordtype">bool</span> NxsCharactersBlock::HandleNextDiscreteState(
<a name="l03053"></a>03053   <a class="code" href="classNxsToken.html">NxsToken</a> &amp;token,
<a name="l03054"></a>03054   <span class="keywordtype">unsigned</span> taxNum,
<a name="l03055"></a>03055   <span class="keywordtype">unsigned</span> charNum,
<a name="l03056"></a>03056   NxsDiscreteStateRow &amp; row,
<a name="l03057"></a>03057   <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> &amp;mapper,
<a name="l03058"></a>03058   <span class="keyword">const</span> NxsDiscreteStateRow * firstTaxonRow,
<a name="l03059"></a>03059   <span class="keyword">const</span> <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> &amp; nameStr)
<a name="l03060"></a>03060     {
<a name="l03061"></a>03061     <span class="keywordflow">if</span> (interleaving)
<a name="l03062"></a>03062         token.<a class="code" href="classNxsToken_afa5232738ca19e069173e8befe75e730.html#afa5232738ca19e069173e8befe75e730" title="Sets the bit specified in the variable `labileFlags&amp;#39;.">SetLabileFlagBit</a>(NxsToken::newlineIsToken);
<a name="l03063"></a>03063     NCL_ASSERT(!tokens);
<a name="l03064"></a>03064     token.<a class="code" href="classNxsToken_afa5232738ca19e069173e8befe75e730.html#afa5232738ca19e069173e8befe75e730" title="Sets the bit specified in the variable `labileFlags&amp;#39;.">SetLabileFlagBit</a>(NxsToken::parentheticalToken);
<a name="l03065"></a>03065     token.<a class="code" href="classNxsToken_afa5232738ca19e069173e8befe75e730.html#afa5232738ca19e069173e8befe75e730" title="Sets the bit specified in the variable `labileFlags&amp;#39;.">SetLabileFlagBit</a>(NxsToken::curlyBracketedToken);
<a name="l03066"></a>03066     token.<a class="code" href="classNxsToken_afa5232738ca19e069173e8befe75e730.html#afa5232738ca19e069173e8befe75e730" title="Sets the bit specified in the variable `labileFlags&amp;#39;.">SetLabileFlagBit</a>(NxsToken::singleCharacterToken);
<a name="l03067"></a>03067 
<a name="l03068"></a>03068     token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l03069"></a>03069 
<a name="l03070"></a>03070     <span class="keywordflow">if</span> (interleaving &amp;&amp; token.<a class="code" href="classNxsToken_ad2671eb776f8f76ac946fd5b76e93c0a.html#ad2671eb776f8f76ac946fd5b76e93c0a" title="Returns true if and only if last call to GetNextToken encountered the newline character...">AtEOL</a>())
<a name="l03071"></a>03071         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03072"></a>03072     <span class="keyword">const</span> <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> &amp;stateAsNexus = token.<a class="code" href="classNxsToken_a83fb9fa31b17d84caaa2c50c664d195a.html#a83fb9fa31b17d84caaa2c50c664d195a" title="Returns the token for functions that only need read only access - faster than GetToken...">GetTokenReference</a>();
<a name="l03073"></a>03073     NxsDiscreteStateCell sc =  mapper.<a class="code" href="classNxsDiscreteDatatypeMapper_a38754dbada3764610403d269a6cd2ce9.html#a38754dbada3764610403d269a6cd2ce9" title="Called from HandleStdMatrix or HandleTransposedMatrix function to read in the next...">EncodeNexusStateString</a>(stateAsNexus, token, taxNum, charNum, firstTaxonRow, nameStr);
<a name="l03074"></a>03074     NCL_ASSERT(charNum &lt; row.size());
<a name="l03075"></a>03075     row[charNum] = sc;
<a name="l03076"></a>03076     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03077"></a>03077     }
<a name="l03078"></a>03078 
<a name="l03079"></a>03079 NxsDiscreteStateCell NxsDiscreteDatatypeMapper::StateCodeForNexusPossibleMultiStateSet(
<a name="l03080"></a>03080   <span class="keyword">const</span> <span class="keywordtype">char</span> nexusSymbol,
<a name="l03081"></a>03081   <span class="keyword">const</span> std::string &amp;stateAsNexus,
<a name="l03082"></a>03082   <a class="code" href="classNxsToken.html">NxsToken</a> &amp; token, <span class="comment">/* the token used to read from `in&#39; */</span>
<a name="l03083"></a>03083   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> taxNum,        <span class="comment">/* the taxon index, in range [0..`ntax&#39;) */</span>
<a name="l03084"></a>03084   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> charNum,       <span class="comment">/* the character index, in range [0..`nChar&#39;) */</span>
<a name="l03085"></a>03085   <span class="keyword">const</span> NxsDiscreteStateRow * firstTaxonRow, <span class="keyword">const</span> <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> &amp;nameStr)
<a name="l03086"></a>03086     {
<a name="l03087"></a>03087     NCL_ASSERT(stateAsNexus.length() &gt; 0);
<a name="l03088"></a>03088     <span class="keyword">const</span> <span class="keywordtype">char</span> firstChar = stateAsNexus[0];
<a name="l03089"></a>03089     <span class="keywordflow">if</span> (firstChar == <span class="charliteral">&#39;(&#39;</span> || firstChar == <span class="charliteral">&#39;{&#39;</span>)
<a name="l03090"></a>03090         <span class="keywordflow">return</span> StateCodeForNexusMultiStateSet(nexusSymbol, stateAsNexus, token, taxNum, charNum, firstTaxonRow, nameStr);
<a name="l03091"></a>03091     <span class="keywordflow">if</span> (stateAsNexus.length() &gt; 1)
<a name="l03092"></a>03092         {
<a name="l03093"></a>03093         <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> emsg;
<a name="l03094"></a>03094         emsg &lt;&lt; <span class="stringliteral">&quot;Expecting  {} or () around a multiple character state set.  Found &quot;</span> &lt;&lt; stateAsNexus &lt;&lt; <span class="stringliteral">&quot; for taxon &quot;</span> &lt;&lt; nameStr;
<a name="l03095"></a>03095         GenerateNxsExceptionMatrixReading(emsg, taxNum, charNum, token, nameStr);
<a name="l03096"></a>03096         }
<a name="l03097"></a>03097 
<a name="l03098"></a>03098     NxsDiscreteStateCell currState = StateCodeForNexusChar(firstChar, token, taxNum, charNum, firstTaxonRow, nameStr);
<a name="l03099"></a>03099     cLookup[(int) nexusSymbol] = currState;
<a name="l03100"></a>03100     <span class="keywordflow">return</span> currState;
<a name="l03101"></a>03101     }
<a name="l03102"></a>03102 
<a name="l03103"></a>03103 NxsDiscreteStateCell NxsDiscreteDatatypeMapper::StateCodeForNexusMultiStateSet(
<a name="l03104"></a>03104   <span class="keyword">const</span> <span class="keywordtype">char</span> nexusSymbol,
<a name="l03105"></a>03105   <span class="keyword">const</span> std::string &amp;stateAsNexus,
<a name="l03106"></a>03106   <a class="code" href="classNxsToken.html">NxsToken</a> &amp; token, <span class="comment">/* the token used to read from `in&#39; */</span>
<a name="l03107"></a>03107   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> taxNum,        <span class="comment">/* the taxon index, in range [0..`ntax&#39;) */</span>
<a name="l03108"></a>03108   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> charNum,       <span class="comment">/* the character index, in range [0..`nChar&#39;) */</span>
<a name="l03109"></a>03109   <span class="keyword">const</span> NxsDiscreteStateRow * firstTaxonRow,
<a name="l03110"></a>03110   <span class="keyword">const</span> <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> &amp;nameStr)
<a name="l03111"></a>03111     {
<a name="l03112"></a>03112     <span class="keyword">const</span> <span class="keywordtype">char</span> firstChar = stateAsNexus[0];
<a name="l03113"></a>03113     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> emsg;
<a name="l03114"></a>03114     <span class="keyword">const</span> <span class="keywordtype">bool</span> poly = (firstChar == <span class="charliteral">&#39;(&#39;</span>);
<a name="l03115"></a>03115     <span class="keywordflow">if</span> ((!poly) &amp;&amp; firstChar != <span class="charliteral">&#39;{&#39;</span>)
<a name="l03116"></a>03116         {
<a name="l03117"></a>03117         emsg &lt;&lt; <span class="stringliteral">&quot;Expecting a state symbol of set of symbols in () or  {} braces.  Found &quot;</span> &lt;&lt; stateAsNexus;
<a name="l03118"></a>03118         GenerateNxsExceptionMatrixReading(emsg, taxNum, charNum, token, nameStr);
<a name="l03119"></a>03119         }
<a name="l03120"></a>03120     <span class="keywordtype">bool</span> tildeFound = <span class="keyword">false</span>;
<a name="l03121"></a>03121     NxsDiscreteStateCell prevState = NXS_INVALID_STATE_CODE;
<a name="l03122"></a>03122     <span class="keywordtype">char</span> prevChar = firstChar;
<a name="l03123"></a>03123     std::string::const_iterator cIt = stateAsNexus.begin();
<a name="l03124"></a>03124     std::string::const_iterator endIt = stateAsNexus.end();
<a name="l03125"></a>03125     --endIt;
<a name="l03126"></a>03126     NCL_ASSERT((poly &amp;&amp; *endIt == <span class="charliteral">&#39;)&#39;</span>) || (!poly &amp;&amp; *endIt == <span class="charliteral">&#39;}&#39;</span>));
<a name="l03127"></a>03127     std::set&lt;NxsDiscreteStateCell&gt; sset;
<a name="l03128"></a>03128     <span class="keywordflow">for</span> (++cIt; cIt != endIt; ++cIt)
<a name="l03129"></a>03129         {
<a name="l03130"></a>03130         <span class="keyword">const</span> <span class="keywordtype">char</span> currChar = *cIt;
<a name="l03131"></a>03131         <span class="keywordflow">if</span> ((strchr(<span class="stringliteral">&quot;\n\r \t&quot;</span>, currChar) == NULL) &amp;&amp; currChar != <span class="charliteral">&#39;,&#39;</span>)
<a name="l03132"></a>03132             {
<a name="l03133"></a>03133             <span class="keywordflow">if</span> (currChar == <span class="charliteral">&#39;~&#39;</span>)
<a name="l03134"></a>03134                 {
<a name="l03135"></a>03135                 <span class="keywordflow">if</span> (prevState &lt; 0 || prevState &gt;= (NxsDiscreteStateCell)nStates)
<a name="l03136"></a>03136                     {
<a name="l03137"></a>03137                     emsg &lt;&lt; <span class="stringliteral">&quot;A state range cannot start with &quot;</span> &lt;&lt; prevChar;
<a name="l03138"></a>03138                     GenerateNxsExceptionMatrixReading(emsg, taxNum, charNum, token, nameStr);
<a name="l03139"></a>03139                     }
<a name="l03140"></a>03140                 tildeFound = <span class="keyword">true</span>;
<a name="l03141"></a>03141                 }
<a name="l03142"></a>03142             <span class="keywordflow">else</span>
<a name="l03143"></a>03143                 {
<a name="l03144"></a>03144                 <span class="comment">// Add state symbol and record if it is the first or last one in case we encounter a tilde</span>
<a name="l03145"></a>03145                 NxsDiscreteStateCell currState;
<a name="l03146"></a>03146                 <span class="keywordflow">if</span> (tildeFound)
<a name="l03147"></a>03147                     {
<a name="l03148"></a>03148                     currState = <a class="code" href="classNxsDiscreteDatatypeMapper_a28dc664593857681cafc6afcdd06693f.html#a28dc664593857681cafc6afcdd06693f" title="Returns NXS_INVALID_STATE_CODE or the index of `c` in the symbols list.">PositionInSymbols</a>(currChar);
<a name="l03149"></a>03149                     <span class="keywordflow">if</span> (currState == NXS_INVALID_STATE_CODE)
<a name="l03150"></a>03150                         {
<a name="l03151"></a>03151                         emsg &lt;&lt; <span class="stringliteral">&quot;A state range cannot end with &quot;</span> &lt;&lt; currChar;
<a name="l03152"></a>03152                         GenerateNxsExceptionMatrixReading(emsg, taxNum, charNum, token, nameStr);
<a name="l03153"></a>03153                         }
<a name="l03154"></a>03154                     <span class="keywordflow">if</span> (currState &lt; prevState)
<a name="l03155"></a>03155                         {
<a name="l03156"></a>03156                         emsg &lt;&lt; prevChar &lt;&lt; <span class="charliteral">&#39;~&#39;</span> &lt;&lt; currChar &lt;&lt; <span class="stringliteral">&quot; is not a valid state range (the end state is a lower index than the start)&quot;</span>;
<a name="l03157"></a>03157                         GenerateNxsExceptionMatrixReading(emsg, taxNum, charNum, token, nameStr);
<a name="l03158"></a>03158                         }
<a name="l03159"></a>03159                     <span class="keywordflow">for</span> (NxsDiscreteStateCell i = prevState; i &lt;= currState; ++i)
<a name="l03160"></a>03160                         sset.insert(i);
<a name="l03161"></a>03161                     tildeFound = <span class="keyword">false</span>;
<a name="l03162"></a>03162                     }
<a name="l03163"></a>03163                 <span class="keywordflow">else</span>
<a name="l03164"></a>03164                     {
<a name="l03165"></a>03165                     currState = StateCodeForNexusChar(currChar, token, taxNum, charNum, firstTaxonRow, nameStr);
<a name="l03166"></a>03166                     sset.insert(currState);
<a name="l03167"></a>03167                     }
<a name="l03168"></a>03168                 prevState = currState;
<a name="l03169"></a>03169                 prevChar = currChar;
<a name="l03170"></a>03170                 }
<a name="l03171"></a>03171             }
<a name="l03172"></a>03172         }
<a name="l03173"></a>03173     <span class="keywordflow">if</span> (prevChar == <span class="charliteral">&#39;~&#39;</span>)
<a name="l03174"></a>03174         {
<a name="l03175"></a>03175         emsg &lt;&lt; <span class="stringliteral">&quot;State range not terminated -- ending in ~&quot;</span> &lt;&lt; *endIt;
<a name="l03176"></a>03176         GenerateNxsExceptionMatrixReading(emsg, taxNum, charNum, token, nameStr);
<a name="l03177"></a>03177         }
<a name="l03178"></a>03178     <span class="keywordflow">if</span> (sset.empty())
<a name="l03179"></a>03179         {
<a name="l03180"></a>03180         emsg &lt;&lt; <span class="stringliteral">&quot;An illegal (empty) state range was found \&quot;&quot;</span> &lt;&lt; stateAsNexus &lt;&lt; <span class="charliteral">&#39;\&quot;&#39;</span>;
<a name="l03181"></a>03181         GenerateNxsExceptionMatrixReading(emsg, taxNum, charNum, token, nameStr);
<a name="l03182"></a>03182         }
<a name="l03183"></a>03183     <span class="keywordflow">return</span> <a class="code" href="classNxsDiscreteDatatypeMapper_a0e253cf7f7452d69062071932644df4a.html#a0e253cf7f7452d69062071932644df4a" title="Returns the state code of a (possible new state set) `sset`.">StateCodeForStateSet</a>(sset, poly, <span class="keyword">true</span>, nexusSymbol);
<a name="l03184"></a>03184     }
<a name="l03185"></a>03185 
<a name="l03186"></a>03186 
<a name="l03187"></a>03187 
<a name="l03194"></a><a class="code" href="classNxsCharactersBlock_abf0d355d3a40d6ce27d91b6a8c1ca88f.html#abf0d355d3a40d6ce27d91b6a8c1ca88f">03194</a> <span class="keywordtype">bool</span> <a class="code" href="classNxsCharactersBlock_abf0d355d3a40d6ce27d91b6a8c1ca88f.html#abf0d355d3a40d6ce27d91b6a8c1ca88f" title="Called from HandleNextState to read in the next state when TOKENS was specified.">NxsCharactersBlock::HandleNextTokenState</a>(
<a name="l03195"></a>03195   <a class="code" href="classNxsToken.html">NxsToken</a> &amp;token,
<a name="l03196"></a>03196   <span class="keywordtype">unsigned</span> taxNum,
<a name="l03197"></a>03197   <span class="keywordtype">unsigned</span> charNum,
<a name="l03198"></a>03198   NxsDiscreteStateRow &amp; row,
<a name="l03199"></a>03199   <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> &amp;mapper,
<a name="l03200"></a>03200   <span class="keyword">const</span> NxsDiscreteStateRow * firstTaxonRow,
<a name="l03201"></a>03201   <span class="keyword">const</span> <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> &amp; nameStr)
<a name="l03202"></a>03202   {
<a name="l03203"></a>03203     <span class="keywordflow">if</span> (interleaving)
<a name="l03204"></a>03204         token.<a class="code" href="classNxsToken_afa5232738ca19e069173e8befe75e730.html#afa5232738ca19e069173e8befe75e730" title="Sets the bit specified in the variable `labileFlags&amp;#39;.">SetLabileFlagBit</a>(NxsToken::newlineIsToken);
<a name="l03205"></a>03205     token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l03206"></a>03206     <span class="keywordflow">if</span> (interleaving &amp;&amp; token.<a class="code" href="classNxsToken_ad2671eb776f8f76ac946fd5b76e93c0a.html#ad2671eb776f8f76ac946fd5b76e93c0a" title="Returns true if and only if last call to GetNextToken encountered the newline character...">AtEOL</a>())
<a name="l03207"></a>03207         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03208"></a>03208     <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a8231aba780039e4ef1fe2fbf24e21dba.html#a8231aba780039e4ef1fe2fbf24e21dba" title="Returns token.size().">GetTokenLength</a>() ==  0)
<a name="l03209"></a>03209         <a class="code" href="classNxsBlock_a9106779865a661477259f3d84edb36a5.html#a9106779865a661477259f3d84edb36a5" title="throws a NxsException with the token info for `token` `expected` should fill in the...">GenerateNxsException</a>(token, <span class="stringliteral">&quot;Unexpected empty token encountered&quot;</span>);
<a name="l03210"></a>03210 
<a name="l03211"></a>03211     <span class="keywordtype">int</span> polymorphism = token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;(&quot;</span>);
<a name="l03212"></a>03212     <span class="keywordtype">int</span> uncertainty  = token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;{&quot;</span>);
<a name="l03213"></a>03213     <span class="keywordflow">if</span> (!uncertainty &amp;&amp; !polymorphism)
<a name="l03214"></a>03214         {
<a name="l03215"></a>03215         row[charNum] = HandleTokenState(token, taxNum, charNum, mapper, firstTaxonRow, nameStr);
<a name="l03216"></a>03216         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03217"></a>03217         }
<a name="l03218"></a>03218 
<a name="l03219"></a>03219     <span class="comment">/*TODO - supporting this requires more bookeeping to allow the mapper to deal with</span>
<a name="l03220"></a>03220 <span class="comment">    anonymous fundamental states  -- difficult because we don&#39;t know the number of symbols in TOKENS mode.*/</span>
<a name="l03221"></a>03221     errormsg = <span class="stringliteral">&quot;Currently polymorphism and ambiguity are not supported for matrices in TOKENS mode: &quot;</span>;
<a name="l03222"></a>03222     errormsg &lt;&lt; token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>() &lt;&lt; <span class="stringliteral">&quot; found while reading character &quot;</span> &lt;&lt; charNum + 1 &lt;&lt; <span class="stringliteral">&quot; of taxon \&quot;&quot;</span> &lt;&lt; nameStr &lt;&lt; <span class="charliteral">&#39;\&quot;&#39;</span>;
<a name="l03223"></a>03223     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l03224"></a>03224 
<a name="l03225"></a>03225     <span class="keywordtype">bool</span> tildeFound = <span class="keyword">false</span>;
<a name="l03226"></a>03226     NxsDiscreteStateCell prevState = NXS_INVALID_STATE_CODE;
<a name="l03227"></a>03227     std::string prevToken = token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>();
<a name="l03228"></a>03228     std::set&lt;NxsDiscreteStateCell&gt; sset;
<a name="l03229"></a>03229     <span class="keywordflow">for</span> (;;)
<a name="l03230"></a>03230         {
<a name="l03231"></a>03231         <span class="comment">// OPEN ISSUE: What about newlines if interleaving? I&#39;m assuming</span>
<a name="l03232"></a>03232         <span class="comment">// that the newline must come between characters to count.</span>
<a name="l03233"></a>03233 
<a name="l03234"></a>03234         token.<a class="code" href="classNxsToken_afa5232738ca19e069173e8befe75e730.html#afa5232738ca19e069173e8befe75e730" title="Sets the bit specified in the variable `labileFlags&amp;#39;.">SetLabileFlagBit</a>(NxsToken::tildeIsPunctuation);
<a name="l03235"></a>03235         token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l03236"></a>03236 
<a name="l03237"></a>03237         <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;,&quot;</span>))
<a name="l03238"></a>03238             {
<a name="l03239"></a>03239             ; <span class="comment">/*Mesquite exports with , in state sets. We&#39;ll ignore the comma*/</span>
<a name="l03240"></a>03240             }
<a name="l03241"></a>03241         <span class="keywordflow">if</span> (polymorphism)
<a name="l03242"></a>03242             {
<a name="l03243"></a>03243             <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;)&quot;</span>))
<a name="l03244"></a>03244                 {
<a name="l03245"></a>03245                 <span class="keywordflow">if</span> (tildeFound)
<a name="l03246"></a>03246                     mapper.GenerateNxsExceptionMatrixReading(<span class="stringliteral">&quot;Range of states still being specified when &#39;)&#39; encountered&quot;</span>, taxNum, charNum, token, nameStr);
<a name="l03247"></a>03247                 <span class="keywordflow">break</span>;
<a name="l03248"></a>03248                 }
<a name="l03249"></a>03249             <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;{&quot;</span>))
<a name="l03250"></a>03250                 mapper.GenerateNxsExceptionMatrixReading(<span class="stringliteral">&quot;Illegal range of states &#39;{&#39; found inside &#39;()&#39;&quot;</span>, taxNum, charNum, token, nameStr);
<a name="l03251"></a>03251 
<a name="l03252"></a>03252             }
<a name="l03253"></a>03253         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (uncertainty)
<a name="l03254"></a>03254             {
<a name="l03255"></a>03255             <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;}&quot;</span>))
<a name="l03256"></a>03256                 {
<a name="l03257"></a>03257                 <span class="keywordflow">if</span> (tildeFound)
<a name="l03258"></a>03258                     mapper.GenerateNxsExceptionMatrixReading(<span class="stringliteral">&quot;Range of states still being specified when &#39;}&#39; encountered&quot;</span>, taxNum, charNum, token, nameStr);
<a name="l03259"></a>03259                 <span class="keywordflow">break</span>;
<a name="l03260"></a>03260                 }
<a name="l03261"></a>03261             <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;(&quot;</span>))
<a name="l03262"></a>03262                 mapper.GenerateNxsExceptionMatrixReading(<span class="stringliteral">&quot;Illegal range of states &#39;(&#39; found inside &#39;{}&#39;&quot;</span>, taxNum, charNum, token, nameStr);
<a name="l03263"></a>03263             }
<a name="l03264"></a>03264         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;~&quot;</span>))
<a name="l03265"></a>03265             {
<a name="l03266"></a>03266             <span class="keywordflow">if</span> (prevState &lt; 0 || prevState &gt;= (NxsDiscreteStateCell)symbols.length())
<a name="l03267"></a>03267                 {
<a name="l03268"></a>03268                 errormsg.<a class="code" href="classNxsString_abbf904c772d9776139dcae602c9fd06b.html#abbf904c772d9776139dcae602c9fd06b" title="Most containers in the standard template library can be completely erased using the...">clear</a>();
<a name="l03269"></a>03269                 errormsg &lt;&lt; <span class="stringliteral">&quot;A state range cannot start with &quot;</span> &lt;&lt; prevToken;
<a name="l03270"></a>03270                 mapper.GenerateNxsExceptionMatrixReading(errormsg, taxNum, charNum, token, nameStr);
<a name="l03271"></a>03271                 }
<a name="l03272"></a>03272             tildeFound = <span class="keyword">true</span>;
<a name="l03273"></a>03273             }
<a name="l03274"></a>03274         <span class="keywordflow">else</span>
<a name="l03275"></a>03275             {
<a name="l03276"></a>03276             NxsDiscreteStateCell currState;
<a name="l03277"></a>03277             <span class="keywordflow">if</span> (tildeFound)
<a name="l03278"></a>03278                 {
<a name="l03279"></a>03279                 currState = HandleTokenState(token, taxNum, charNum, mapper, firstTaxonRow, nameStr);
<a name="l03280"></a>03280                 <span class="keywordflow">if</span> (currState &lt;= prevState)
<a name="l03281"></a>03281                     {
<a name="l03282"></a>03282                     errormsg = <span class="stringliteral">&quot;Last state in specified range (&quot;</span>;
<a name="l03283"></a>03283                     errormsg &lt;&lt; token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>() &lt;&lt; <span class="stringliteral">&quot;) must be greater than the first&quot;</span>;
<a name="l03284"></a>03284                     mapper.GenerateNxsExceptionMatrixReading(errormsg, taxNum, charNum, token, nameStr);
<a name="l03285"></a>03285                     }
<a name="l03286"></a>03286                 <span class="keywordflow">for</span> (NxsDiscreteStateCell i = prevState; i &lt;= currState; ++i)
<a name="l03287"></a>03287                     sset.insert(i);
<a name="l03288"></a>03288                 tildeFound = <span class="keyword">false</span>;
<a name="l03289"></a>03289                 }
<a name="l03290"></a>03290             <span class="keywordflow">else</span>
<a name="l03291"></a>03291                 {
<a name="l03292"></a>03292                 <span class="comment">// Add current state, then set first to that state&#39;s value</span>
<a name="l03293"></a>03293                 <span class="comment">// State&#39;s value is its position within the list of states</span>
<a name="l03294"></a>03294                 <span class="comment">// for that character</span>
<a name="l03295"></a>03295                 <span class="comment">//</span>
<a name="l03296"></a>03296                 currState = HandleTokenState(token, taxNum, charNum, mapper, firstTaxonRow, nameStr);
<a name="l03297"></a>03297                 sset.insert(currState);
<a name="l03298"></a>03298                 }
<a name="l03299"></a>03299             prevState = currState;
<a name="l03300"></a>03300             prevToken = token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>();
<a name="l03301"></a>03301             }
<a name="l03302"></a>03302         }
<a name="l03303"></a>03303 
<a name="l03304"></a>03304     <span class="keywordflow">if</span> (prevToken == <span class="stringliteral">&quot;~&quot;</span>)
<a name="l03305"></a>03305         {
<a name="l03306"></a>03306         errormsg.<a class="code" href="classNxsString_abbf904c772d9776139dcae602c9fd06b.html#abbf904c772d9776139dcae602c9fd06b" title="Most containers in the standard template library can be completely erased using the...">clear</a>();
<a name="l03307"></a>03307         errormsg &lt;&lt; <span class="stringliteral">&quot;State range not terminated -- ending in ~&quot;</span> &lt;&lt; token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>();
<a name="l03308"></a>03308         mapper.GenerateNxsExceptionMatrixReading(errormsg, taxNum, charNum, token, nameStr);
<a name="l03309"></a>03309         }
<a name="l03310"></a>03310     <span class="keywordflow">if</span> (sset.empty())
<a name="l03311"></a>03311         {
<a name="l03312"></a>03312         errormsg.<a class="code" href="classNxsString_abbf904c772d9776139dcae602c9fd06b.html#abbf904c772d9776139dcae602c9fd06b" title="Most containers in the standard template library can be completely erased using the...">clear</a>();
<a name="l03313"></a>03313         errormsg &lt;&lt; <span class="stringliteral">&quot;An illegal (empty) state range -- either  {} or ()&quot;</span>;
<a name="l03314"></a>03314         mapper.GenerateNxsExceptionMatrixReading(errormsg, taxNum, charNum, token, nameStr);
<a name="l03315"></a>03315         }
<a name="l03316"></a>03316     row[charNum] = mapper.<a class="code" href="classNxsDiscreteDatatypeMapper_a0e253cf7f7452d69062071932644df4a.html#a0e253cf7f7452d69062071932644df4a" title="Returns the state code of a (possible new state set) `sset`.">StateCodeForStateSet</a>(sset, (<span class="keyword">const</span> <span class="keywordtype">bool</span>)(polymorphism != 0), <span class="keyword">true</span>, <span class="charliteral">&#39;\0&#39;</span>);
<a name="l03317"></a>03317     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03318"></a>03318     }
<a name="l03319"></a>03319 
<a name="l03320"></a>03320 NxsDiscreteStateCell NxsCharactersBlock::HandleTokenState(
<a name="l03321"></a>03321   <a class="code" href="classNxsToken.html">NxsToken</a> &amp;token,  <span class="comment">/* the token used to read from `in&#39; */</span>
<a name="l03322"></a>03322   <span class="keywordtype">unsigned</span> taxNum,
<a name="l03323"></a>03323   <span class="keywordtype">unsigned</span> charNum,
<a name="l03324"></a>03324   <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> &amp;,
<a name="l03325"></a>03325   <span class="keyword">const</span> NxsDiscreteStateRow * ,
<a name="l03326"></a>03326   <span class="keyword">const</span> <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> &amp; nameStr)
<a name="l03327"></a>03327     {
<a name="l03328"></a>03328     <span class="comment">// Token may be one of the character states listed for character charNum in charStates</span>
<a name="l03329"></a>03329     <span class="keyword">const</span> std::string t = token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>(respectingCase);
<a name="l03330"></a>03330     NxsStringVectorMap::const_iterator bagIter  = charStates.find(charNum);
<a name="l03331"></a>03331     <span class="comment">/*</span>
<a name="l03332"></a>03332 <span class="comment">     if (bagIter == charStates.end())</span>
<a name="l03333"></a>03333 <span class="comment">        return mapper.EncodeNexusStateString(t, token, taxNum, charNum, firstTaxonRow);</span>
<a name="l03334"></a>03334 <span class="comment">    */</span>
<a name="l03335"></a>03335     NxsStringVector::const_iterator ci_begin    = bagIter-&gt;second.begin();
<a name="l03336"></a>03336     NxsStringVector::const_iterator ci_end      = bagIter-&gt;second.end();
<a name="l03337"></a>03337     NxsStringVector::const_iterator cit;
<a name="l03338"></a>03338     NxsDiscreteStateCell k = 0;
<a name="l03339"></a>03339     <span class="keywordflow">for</span> (; ci_begin != ci_end; ++ci_begin, ++k)
<a name="l03340"></a>03340         {
<a name="l03341"></a>03341         <span class="keywordflow">if</span> (respectingCase)
<a name="l03342"></a>03342             {
<a name="l03343"></a>03343             <span class="keywordflow">if</span> (*ci_begin == t)
<a name="l03344"></a>03344                 <span class="keywordflow">return</span> k;
<a name="l03345"></a>03345             }
<a name="l03346"></a>03346         <span class="keywordflow">else</span>
<a name="l03347"></a>03347             {
<a name="l03348"></a>03348             <span class="keywordflow">if</span> (NxsString::case_insensitive_equals(t.c_str(), ci_begin-&gt;c_str()))
<a name="l03349"></a>03349                 <span class="keywordflow">return</span> k;
<a name="l03350"></a>03350             }
<a name="l03351"></a>03351         }
<a name="l03352"></a>03352     <span class="comment">//return mapper.EncodeNexusStateString(t, token, taxNum, charNum, firstTaxonRow);</span>
<a name="l03353"></a>03353     errormsg = <span class="stringliteral">&quot;Unrecognized state &quot;</span>;
<a name="l03354"></a>03354     errormsg &lt;&lt; t &lt;&lt; <span class="stringliteral">&quot; found while reading character &quot;</span> &lt;&lt; charNum + 1 &lt;&lt; <span class="stringliteral">&quot; of taxon number &quot;</span> &lt;&lt; taxNum + 1;
<a name="l03355"></a>03355     <span class="keywordflow">if</span> (!nameStr.empty())
<a name="l03356"></a>03356         errormsg &lt;&lt; <span class="stringliteral">&quot;(name \&quot;&quot;</span> &lt;&lt; nameStr &lt;&lt; <span class="stringliteral">&quot;\&quot;)&quot;</span>;
<a name="l03357"></a>03357     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l03358"></a>03358     }
<a name="l03359"></a>03359 
<a name="l03360"></a>03360 
<a name="l03361"></a>03361 <span class="keywordtype">unsigned</span> NxsCharactersBlock::GetMaxIndex()<span class="keyword"> const</span>
<a name="l03362"></a>03362 <span class="keyword">    </span>{
<a name="l03363"></a>03363     <span class="keywordtype">unsigned</span> nct = <a class="code" href="classNxsCharactersBlock_a5f984e07256fa1055b04210484301046.html#a5f984e07256fa1055b04210484301046">GetNCharTotal</a>();
<a name="l03364"></a>03364     <span class="keywordflow">if</span> (nct == 0)
<a name="l03365"></a>03365         <span class="keywordflow">return</span> UINT_MAX;
<a name="l03366"></a>03366     <span class="keywordflow">return</span> nct - 1;
<a name="l03367"></a>03367     }
<a name="l03368"></a>03368 
<a name="l03373"></a><a class="code" href="classNxsCharactersBlock_a874a66c4722e35753160bf611e7b4b5c.html#a874a66c4722e35753160bf611e7b4b5c">03373</a> <span class="keywordtype">unsigned</span> <a class="code" href="classNxsCharactersBlock_a874a66c4722e35753160bf611e7b4b5c.html#a874a66c4722e35753160bf611e7b4b5c" title="Returns the number of indices that correspond to the label (and the number of items...">NxsCharactersBlock::GetIndicesForLabel</a>(<span class="keyword">const</span> std::string &amp;label, NxsUnsignedSet *inds)<span class="keyword"> const</span>
<a name="l03374"></a>03374 <span class="keyword">    </span>{
<a name="l03375"></a>03375     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> emsg;
<a name="l03376"></a>03376     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> numb = <a class="code" href="classNxsCharactersBlock_a592250370757ced9e56b6f78969d3f9d.html#a592250370757ced9e56b6f78969d3f9d" title="This base class version simply returns 0 but a derived class should override this...">CharLabelToNumber</a>(label);
<a name="l03377"></a>03377     <span class="keywordflow">if</span> (numb != 0)
<a name="l03378"></a>03378         {
<a name="l03379"></a>03379         <span class="keywordflow">if</span> (inds)
<a name="l03380"></a>03380             inds-&gt;insert(numb - 1);
<a name="l03381"></a>03381         <span class="keywordflow">return</span> 1;
<a name="l03382"></a>03382         }
<a name="l03383"></a>03383     <span class="keywordflow">if</span> (!defCodonPosPartitionName.empty())
<a name="l03384"></a>03384         {
<a name="l03385"></a>03385         std::string t(label);
<a name="l03386"></a>03386         <a class="code" href="classNxsString_afa27910900e7e9f3bdc8d1b9753479a9.html#afa27910900e7e9f3bdc8d1b9753479a9" title="Capitalizes every character in s.">NxsString::to_upper</a>(t);
<a name="l03387"></a>03387         std::string n;
<a name="l03388"></a>03388         <span class="keywordflow">if</span> (t == <span class="stringliteral">&quot;POS1&quot;</span>)
<a name="l03389"></a>03389             n.assign(<span class="stringliteral">&quot;1&quot;</span>);
<a name="l03390"></a>03390         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t == <span class="stringliteral">&quot;POS2&quot;</span>)
<a name="l03391"></a>03391             n.assign(<span class="stringliteral">&quot;2&quot;</span>);
<a name="l03392"></a>03392         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t == <span class="stringliteral">&quot;POS3&quot;</span>)
<a name="l03393"></a>03393             n.assign(<span class="stringliteral">&quot;3&quot;</span>);
<a name="l03394"></a>03394         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t == <span class="stringliteral">&quot;NONCODING&quot;</span>)
<a name="l03395"></a>03395             n.assign(<span class="stringliteral">&quot;N&quot;</span>);
<a name="l03396"></a>03396         <span class="keywordflow">if</span> (!n.empty())
<a name="l03397"></a>03397             {
<a name="l03398"></a>03398             NxsPartitionsByName::const_iterator pit = codonPosPartitions.find(defCodonPosPartitionName);
<a name="l03399"></a>03399             <span class="keywordflow">if</span> (pit != codonPosPartitions.end())
<a name="l03400"></a>03400                 {
<a name="l03401"></a>03401                 <span class="keyword">const</span> NxsPartition &amp; p = pit-&gt;second;
<a name="l03402"></a>03402                 <span class="keywordflow">for</span> (NxsPartition::const_iterator s = p.begin(); s != p.end(); ++s)
<a name="l03403"></a>03403                     {
<a name="l03404"></a>03404                     <span class="keywordflow">if</span> (NxsString::case_insensitive_equals(n.c_str(), s-&gt;first.c_str()))
<a name="l03405"></a>03405                         {
<a name="l03406"></a>03406                         <span class="keywordtype">unsigned</span> nel = (unsigned)s-&gt;second.size();
<a name="l03407"></a>03407                         <span class="keywordflow">if</span> (inds)
<a name="l03408"></a>03408                             inds-&gt;insert(s-&gt;second.begin(), s-&gt;second.end());
<a name="l03409"></a>03409                         <span class="keywordflow">return</span> nel;
<a name="l03410"></a>03410                         }
<a name="l03411"></a>03411                     }
<a name="l03412"></a>03412                 }
<a name="l03413"></a>03413             }
<a name="l03414"></a>03414         }
<a name="l03415"></a>03415     <span class="keywordflow">if</span> (NxsString::case_insensitive_equals(label.c_str(), <span class="stringliteral">&quot;CONSTANT&quot;</span>))
<a name="l03416"></a>03416         {
<a name="l03417"></a>03417         NxsUnsignedSet c;
<a name="l03418"></a>03418         FindConstantCharacters(c);
<a name="l03419"></a>03419         <span class="keywordflow">if</span> (inds)
<a name="l03420"></a>03420             inds-&gt;insert(c.begin(), c.end());
<a name="l03421"></a>03421         <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span>)c.size();
<a name="l03422"></a>03422         }
<a name="l03423"></a>03423     <span class="keywordflow">if</span> (NxsString::case_insensitive_equals(label.c_str(), <span class="stringliteral">&quot;GAPPED&quot;</span>))
<a name="l03424"></a>03424         {
<a name="l03425"></a>03425         NxsUnsignedSet c;
<a name="l03426"></a>03426         FindGappedCharacters(c);
<a name="l03427"></a>03427         <span class="keywordflow">if</span> (inds)
<a name="l03428"></a>03428             inds-&gt;insert(c.begin(), c.end());
<a name="l03429"></a>03429         <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span>)c.size();
<a name="l03430"></a>03430         }
<a name="l03431"></a>03431     <span class="keywordflow">return</span> <a class="code" href="classNxsLabelToIndicesMapper_a763bbc1aff831343ad563bc9be76a733.html#a763bbc1aff831343ad563bc9be76a733" title="returns the number of indices added (will generate an NxsException if the name is...">GetIndicesFromSetOrAsNumber</a>(label, inds, charSets, GetMaxIndex(), <span class="stringliteral">&quot;character&quot;</span>);
<a name="l03432"></a>03432     }
<a name="l03433"></a>03433 
<a name="l03437"></a><a class="code" href="classNxsCharactersBlock_a719c9c3f1358ec8829da535fa1dadb7b.html#a719c9c3f1358ec8829da535fa1dadb7b">03437</a> <span class="keywordtype">bool</span> <a class="code" href="classNxsCharactersBlock_a719c9c3f1358ec8829da535fa1dadb7b.html#a719c9c3f1358ec8829da535fa1dadb7b" title="Returns true if this set replaces an older definition.">NxsCharactersBlock::AddNewIndexSet</a>(<span class="keyword">const</span> std::string &amp;label, <span class="keyword">const</span> NxsUnsignedSet &amp; inds)
<a name="l03438"></a>03438     {
<a name="l03439"></a>03439     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> ls(label.c_str());
<a name="l03440"></a>03440     <span class="keywordtype">bool</span> replaced = charSets.count(ls) &gt; 0;
<a name="l03441"></a>03441     charSets[ls] = inds;
<a name="l03442"></a>03442     <span class="keywordflow">return</span> replaced;
<a name="l03443"></a>03443     }
<a name="l03444"></a>03444 
<a name="l03448"></a><a class="code" href="classNxsCharactersBlock_a1eca953b037939973f2dd6ea7b7faab4.html#a1eca953b037939973f2dd6ea7b7faab4">03448</a> <span class="keywordtype">bool</span> <a class="code" href="classNxsCharactersBlock_a1eca953b037939973f2dd6ea7b7faab4.html#a1eca953b037939973f2dd6ea7b7faab4" title="Returns true if this set replaces an older definition.">NxsCharactersBlock::AddNewPartition</a>(<span class="keyword">const</span> std::string &amp;label, <span class="keyword">const</span> NxsPartition &amp; inds)
<a name="l03449"></a>03449     {
<a name="l03450"></a>03450     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> ls(label.c_str());
<a name="l03451"></a>03451     ls.ToUpper();
<a name="l03452"></a>03452     <span class="keywordtype">bool</span> replaced = charPartitions.count(ls) &gt; 0;
<a name="l03453"></a>03453     charPartitions[ls] = inds;
<a name="l03454"></a>03454     <span class="keywordflow">return</span> replaced;
<a name="l03455"></a>03455     }
<a name="l03456"></a>03456 
<a name="l03460"></a><a class="code" href="classNxsCharactersBlock_a7d8eef90a653e17163238b9e870c0f7f.html#a7d8eef90a653e17163238b9e870c0f7f">03460</a> <span class="keywordtype">bool</span> <a class="code" href="classNxsCharactersBlock_a7d8eef90a653e17163238b9e870c0f7f.html#a7d8eef90a653e17163238b9e870c0f7f" title="Returns true if this set replaces an older definition.">NxsCharactersBlock::AddNewCodonPosPartition</a>(<span class="keyword">const</span> std::string &amp;label, <span class="keyword">const</span> NxsPartition &amp; inds, <span class="keywordtype">bool</span> isDef)
<a name="l03461"></a>03461     {
<a name="l03462"></a>03462     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> ls(label.c_str());
<a name="l03463"></a>03463     ls.ToUpper();
<a name="l03464"></a>03464     <span class="keywordtype">bool</span> replaced = codonPosPartitions.count(ls) &gt; 0;
<a name="l03465"></a>03465     codonPosPartitions[ls] = inds;
<a name="l03466"></a>03466     <span class="keywordflow">if</span> (isDef)
<a name="l03467"></a>03467         defCodonPosPartitionName = ls;
<a name="l03468"></a>03468     <span class="keywordflow">return</span> replaced;
<a name="l03469"></a>03469     }
<a name="l03470"></a>03470 
<a name="l03474"></a><a class="code" href="classNxsCharactersBlock_a757bd5a089bbb3c0bd7807c01e35c007.html#a757bd5a089bbb3c0bd7807c01e35c007">03474</a> <span class="keywordtype">bool</span> <a class="code" href="classNxsCharactersBlock_a757bd5a089bbb3c0bd7807c01e35c007.html#a757bd5a089bbb3c0bd7807c01e35c007" title="Returns true if this set replaces an older definition.">NxsCharactersBlock::AddNewExSet</a>(<span class="keyword">const</span> std::string &amp;label, <span class="keyword">const</span> NxsUnsignedSet &amp; inds)
<a name="l03475"></a>03475     {
<a name="l03476"></a>03476     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> ls(label.c_str());
<a name="l03477"></a>03477     <span class="keywordtype">bool</span> replaced = exSets.count(ls) &gt; 0;
<a name="l03478"></a>03478     exSets[ls] = inds;
<a name="l03479"></a>03479     <span class="keywordflow">return</span> replaced;
<a name="l03480"></a>03480     }
<a name="l03481"></a>03481 
<a name="l03485"></a><a class="code" href="classNxsCharactersBlock_aecbd5a9f87d5966c8a63acd77a507b67.html#aecbd5a9f87d5966c8a63acd77a507b67">03485</a> <a class="code" href="classNxsCharactersBlock_aecbd5a9f87d5966c8a63acd77a507b67.html#aecbd5a9f87d5966c8a63acd77a507b67" title="In v2.1 of the API, the NxsTaxaBlockAPI and NxsAssumptionsBlockAPI pointers are usually...">NxsCharactersBlock::NxsCharactersBlock</a>(
<a name="l03486"></a>03486   <a class="code" href="classNxsTaxaBlockAPI.html" title="This abstract class describes the interface that every block that wants to serve...">NxsTaxaBlockAPI</a> *tb,          <span class="comment">/* the taxa block object to consult for taxon labels (can be 0L)*/</span>
<a name="l03487"></a>03487   NxsAssumptionsBlockAPI *ab)   <span class="comment">/* the assumptions block object to consult for exclusion sets (can be 0L) */</span>
<a name="l03488"></a>03488     :<a class="code" href="classNxsTaxaBlockSurrogate.html" title="This class is the base class for blocks that can (in a pinch) serve as a TAXA block...">NxsTaxaBlockSurrogate</a>(tb, NULL)
<a name="l03489"></a>03489     {
<a name="l03490"></a>03490     assumptionsBlock = ab;
<a name="l03491"></a>03491     <span class="keywordtype">id</span> = <span class="stringliteral">&quot;CHARACTERS&quot;</span>;
<a name="l03492"></a>03492     supportMixedDatatype = <span class="keyword">false</span>;
<a name="l03493"></a>03493     convertAugmentedToMixed = <span class="keyword">false</span>;
<a name="l03494"></a>03494     allowAugmentingOfSequenceSymbols = <span class="keyword">false</span>;
<a name="l03495"></a>03495     writeInterleaveLen = -1;
<a name="l03496"></a>03496     <a class="code" href="classNxsCharactersBlock_a2e479f3c7a744057e5ee3e653f9061e9.html#a2e479f3c7a744057e5ee3e653f9061e9" title="Returns NxsCharactersBlock object to the state it was in when first created.">Reset</a>();
<a name="l03497"></a>03497     }
<a name="l03501"></a><a class="code" href="classNxsCharactersBlock_ae724d86e3ec64f4ee56962e69eabdb0b.html#ae724d86e3ec64f4ee56962e69eabdb0b">03501</a> <span class="keywordtype">unsigned</span> <a class="code" href="classNxsCharactersBlock_ae724d86e3ec64f4ee56962e69eabdb0b.html#ae724d86e3ec64f4ee56962e69eabdb0b" title="excludes all of the indices in exset.">NxsCharactersBlock::ApplyExset</a>(
<a name="l03502"></a>03502   NxsUnsignedSet &amp;exset)    <span class="comment">/* set of character indices to exclude in range [0..`nChar&#39;) */</span>
<a name="l03503"></a>03503     {
<a name="l03504"></a>03504     excluded.clear();
<a name="l03505"></a>03505     set_union(eliminated.begin(), eliminated.end(), exset.begin(), exset.end(), inserter(excluded, excluded.begin()));
<a name="l03506"></a>03506     <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span>) excluded.size();
<a name="l03507"></a>03507     }
<a name="l03508"></a>03508 
<a name="l03512"></a><a class="code" href="classNxsCharactersBlock_a39d83d6ddebf1b5abeda386812577d04.html#a39d83d6ddebf1b5abeda386812577d04">03512</a> <span class="keywordtype">unsigned</span> <a class="code" href="classNxsCharactersBlock_a39d83d6ddebf1b5abeda386812577d04.html#a39d83d6ddebf1b5abeda386812577d04" title="includes all of the indices in exset.">NxsCharactersBlock::ApplyIncludeset</a>(
<a name="l03513"></a>03513   NxsUnsignedSet &amp;inset)    <span class="comment">/* set of character indices to include in range [0..`nChar&#39;) */</span>
<a name="l03514"></a>03514     {
<a name="l03515"></a>03515     NxsUnsignedSet inc(inset);
<a name="l03516"></a>03516     inc.erase(eliminated.begin(), eliminated.end());
<a name="l03517"></a>03517     excluded.erase(inc.begin(), inc.end());
<a name="l03518"></a>03518     <span class="keywordflow">return</span> nChar - (unsigned) excluded.size();
<a name="l03519"></a>03519     }
<a name="l03520"></a>03520 
<a name="l03525"></a><a class="code" href="classNxsCharactersBlock_a90b9686783921d168235a39fddfe7ce1.html#a90b9686783921d168235a39fddfe7ce1">03525</a> <span class="keywordtype">unsigned</span> <a class="code" href="classNxsCharactersBlock_a592250370757ced9e56b6f78969d3f9d.html#a592250370757ced9e56b6f78969d3f9d" title="This base class version simply returns 0 but a derived class should override this...">NxsCharactersBlock::CharLabelToNumber</a>(
<a name="l03526"></a>03526   <span class="keyword">const</span> std::string &amp;inp) <span class="keyword">const</span> <span class="comment">/* the character label to convert */</span>
<a name="l03527"></a>03527     {
<a name="l03528"></a>03528     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> s(inp.c_str());
<a name="l03529"></a>03529     s.ToUpper();
<a name="l03530"></a>03530     std::map&lt;std::string, unsigned&gt;::const_iterator ltindIt = ucCharLabelToIndex.find(s);
<a name="l03531"></a>03531     <span class="keywordflow">if</span> (ltindIt == ucCharLabelToIndex.end())
<a name="l03532"></a>03532         <span class="keywordflow">return</span> 0;
<a name="l03533"></a>03533     <span class="keywordflow">return</span> 1 + ltindIt-&gt;second;
<a name="l03534"></a>03534     }
<a name="l03535"></a>03535 
<a name="l03543"></a><a class="code" href="classNxsCharactersBlock_a95c89bcff05d6d3718c39a74e859369f.html#a95c89bcff05d6d3718c39a74e859369f">03543</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_a95c89bcff05d6d3718c39a74e859369f.html#a95c89bcff05d6d3718c39a74e859369f" title="Transfers all data from `other&amp;#39; to this object, leaving `other&amp;#39; completely...">NxsCharactersBlock::Consume</a>(
<a name="l03544"></a>03544   <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> &amp;other)    <span class="comment">/* NxsCharactersBlock object from which to copy */</span>
<a name="l03545"></a>03545     {
<a name="l03546"></a>03546     <span class="keywordflow">if</span> (assumptionsBlock)
<a name="l03547"></a>03547         assumptionsBlock-&gt;SetCallback(NULL);
<a name="l03548"></a>03548     assumptionsBlock = other.assumptionsBlock;
<a name="l03549"></a>03549     other.assumptionsBlock = NULL;
<a name="l03550"></a>03550     <span class="keywordflow">if</span> (assumptionsBlock)
<a name="l03551"></a>03551         assumptionsBlock-&gt;SetCallback(<span class="keyword">this</span>);
<a name="l03552"></a>03552 
<a name="l03553"></a>03553     nChar = other.nChar;
<a name="l03554"></a>03554     nTaxWithData = other.nTaxWithData;
<a name="l03555"></a>03555     matchchar = other.matchchar;
<a name="l03556"></a>03556     respectingCase = other.respectingCase;
<a name="l03557"></a>03557     transposing = other.transposing;
<a name="l03558"></a>03558     interleaving = other.interleaving;
<a name="l03559"></a>03559     tokens = other.tokens;
<a name="l03560"></a>03560     labels = other.labels;
<a name="l03561"></a>03561     missing = other.missing;
<a name="l03562"></a>03562     gap = other.gap;
<a name="l03563"></a>03563     gapMode = other.gapMode;
<a name="l03564"></a>03564     symbols = other.symbols;
<a name="l03565"></a>03565     userEquates = other.userEquates;
<a name="l03566"></a>03566     defaultEquates = other.defaultEquates;
<a name="l03567"></a>03567     discreteMatrix = other.discreteMatrix;
<a name="l03568"></a>03568     continuousMatrix = other.continuousMatrix;
<a name="l03569"></a>03569     eliminated = other.eliminated;
<a name="l03570"></a>03570     excluded = other.excluded;
<a name="l03571"></a>03571     ucCharLabelToIndex = other.ucCharLabelToIndex;
<a name="l03572"></a>03572     indToCharLabel = other.indToCharLabel;
<a name="l03573"></a>03573     charStates = other.charStates;
<a name="l03574"></a>03574     globalStateLabels = other.globalStateLabels;
<a name="l03575"></a>03575     items = other.items;
<a name="l03576"></a>03576     charSets = other.charSets;
<a name="l03577"></a>03577     charPartitions = other.charPartitions;
<a name="l03578"></a>03578     exSets = other.exSets;
<a name="l03579"></a>03579     datatype = other.datatype;
<a name="l03580"></a>03580     originalDatatype = other.originalDatatype;
<a name="l03581"></a>03581     datatypeReadFromFormat = other.datatypeReadFromFormat;
<a name="l03582"></a>03582     statesFormat = other.statesFormat;
<a name="l03583"></a>03583     datatypeMapperVec = other.datatypeMapperVec;
<a name="l03584"></a>03584     isEmpty = <span class="keyword">false</span>;
<a name="l03585"></a>03585     isUserSupplied = other.isUserSupplied;
<a name="l03586"></a>03586     supportMixedDatatype = other.supportMixedDatatype;
<a name="l03587"></a>03587     convertAugmentedToMixed = other.convertAugmentedToMixed;
<a name="l03588"></a>03588     allowAugmentingOfSequenceSymbols = other.allowAugmentingOfSequenceSymbols;
<a name="l03589"></a>03589     writeInterleaveLen = other.writeInterleaveLen;
<a name="l03590"></a>03590     other.<a class="code" href="classNxsCharactersBlock_a2e479f3c7a744057e5ee3e653f9061e9.html#a2e479f3c7a744057e5ee3e653f9061e9" title="Returns NxsCharactersBlock object to the state it was in when first created.">Reset</a>();
<a name="l03591"></a>03591     transfMgr.Reset();
<a name="l03592"></a>03592     }
<a name="l03593"></a>03593 
<a name="l03594"></a>03594 
<a name="l03595"></a>03595 <span class="keywordtype">void</span> NxsCharactersBlock::WriteStatesForTaxonAsNexus(
<a name="l03596"></a>03596   std::ostream &amp;out,            <span class="comment">/* output stream on which to print matrix */</span>
<a name="l03597"></a>03597   <span class="keywordtype">unsigned</span> taxNum,
<a name="l03598"></a>03598   <span class="keywordtype">unsigned</span> beginCharInd,
<a name="l03599"></a>03599   <span class="keywordtype">unsigned</span> endCharInd)<span class="keyword"> const    </span>{
<a name="l03600"></a>03600     NCL_ASSERT(endCharInd &lt;= this-&gt;nChar);
<a name="l03601"></a>03601 
<a name="l03602"></a>03602     <span class="keywordflow">if</span> (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">continuous</a>)
<a name="l03603"></a>03603         {
<a name="l03604"></a>03604         <span class="keyword">const</span> ContinuousCharRow &amp; row = GetContinuousMatrixRow(taxNum);
<a name="l03605"></a>03605         <span class="keywordflow">if</span> (!row.empty())
<a name="l03606"></a>03606             {
<a name="l03607"></a>03607             NCL_ASSERT(endCharInd &lt;= row.size());
<a name="l03608"></a>03608             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> charInd = beginCharInd; charInd &lt; endCharInd; ++charInd)
<a name="l03609"></a>03609                 {
<a name="l03610"></a>03610                 out &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l03611"></a>03611                 <a class="code" href="classNxsCharactersBlock_a5579db52d7a55f7f32d7716f93f7913d.html#a5579db52d7a55f7f32d7716f93f7913d" title="Looks up the state(s) at row `i&amp;#39;, column `charNum&amp;#39; of matrix and writes it...">ShowStateLabels</a>(out, taxNum, charInd, UINT_MAX);
<a name="l03612"></a>03612                 }
<a name="l03613"></a>03613             }
<a name="l03614"></a>03614         }
<a name="l03615"></a>03615     <span class="keywordflow">else</span>
<a name="l03616"></a>03616         {
<a name="l03617"></a>03617         <span class="keyword">const</span> NxsDiscreteStateRow &amp; row = <a class="code" href="classNxsCharactersBlock_a2840b32dd8053a925a9c777911f6b659.html#a2840b32dd8053a925a9c777911f6b659">GetDiscreteMatrixRow</a>(taxNum);
<a name="l03618"></a>03618         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> rs = (<span class="keyword">const</span> unsigned)row.size();
<a name="l03619"></a>03619         NCL_ASSERT(endCharInd &lt;= rs);
<a name="l03620"></a>03620         <span class="keywordflow">if</span> (rs &gt; 0)
<a name="l03621"></a>03621             {
<a name="l03622"></a>03622             <span class="keywordflow">if</span> (this-&gt;datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa11d7fb339c6f83517338e0e6faac722" title="indicates `matrix&amp;#39; holds amino acid sequences">NxsCharactersBlock::codon</a>)
<a name="l03623"></a>03623                 {
<a name="l03624"></a>03624                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> charInd = beginCharInd; charInd &lt; endCharInd; ++charInd)
<a name="l03625"></a>03625                     {
<a name="l03626"></a>03626                     NxsDiscreteStateCell sc = row[charInd];
<a name="l03627"></a>03627                     <span class="keywordflow">if</span> (sc == NXS_GAP_STATE_CODE)
<a name="l03628"></a>03628                         out &lt;&lt; gap &lt;&lt; gap &lt;&lt; gap;
<a name="l03629"></a>03629                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sc &gt;= 0 &amp;&amp; sc &lt; (NxsDiscreteStateCell) globalStateLabels.size())
<a name="l03630"></a>03630                         out &lt;&lt; globalStateLabels[sc];
<a name="l03631"></a>03631                     <span class="keywordflow">else</span>
<a name="l03632"></a>03632                         out &lt;&lt; missing &lt;&lt; missing &lt;&lt; missing;
<a name="l03633"></a>03633                     }
<a name="l03634"></a>03634                 }
<a name="l03635"></a>03635             <span class="keywordflow">else</span>
<a name="l03636"></a>03636                 {
<a name="l03637"></a>03637                 <span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * dm = GetDatatypeMapperForChar(0);
<a name="l03638"></a>03638                 <span class="keywordflow">if</span> (dm == NULL)
<a name="l03639"></a>03639                     <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(<span class="stringliteral">&quot;No DatatypeMapper in WriteStatesForTaxonAsNexus&quot;</span>);
<a name="l03640"></a>03640                 <span class="keywordflow">if</span> (IsMixedType())
<a name="l03641"></a>03641                     {
<a name="l03642"></a>03642 
<a name="l03643"></a>03643                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> charInd = beginCharInd; charInd &lt; endCharInd; ++charInd)
<a name="l03644"></a>03644                         {
<a name="l03645"></a>03645                         dm = GetDatatypeMapperForChar(charInd);
<a name="l03646"></a>03646                         <span class="keywordflow">if</span> (dm == NULL)
<a name="l03647"></a>03647                             {
<a name="l03648"></a>03648                             errormsg = <span class="stringliteral">&quot;No DatatypeMapper for character &quot;</span>;
<a name="l03649"></a>03649                             errormsg &lt;&lt; charInd + 1 &lt;&lt; <span class="stringliteral">&quot; in WriteStatesForTaxonAsNexus&quot;</span>;
<a name="l03650"></a>03650                             <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(errormsg);
<a name="l03651"></a>03651                             }
<a name="l03652"></a>03652                         <span class="keyword">const</span> NxsDiscreteStateCell c = row.at(charInd);
<a name="l03653"></a>03653                         dm-&gt;<a class="code" href="classNxsDiscreteDatatypeMapper_a60f67a89207c16b0f5e297c6d43a313a.html#a60f67a89207c16b0f5e297c6d43a313a" title="Returns the NEXUS reperesenation of the state code `scode` which may be a multiple...">WriteStateCodeAsNexusString</a>(out, c);
<a name="l03654"></a>03654                         }
<a name="l03655"></a>03655                     }
<a name="l03656"></a>03656                 <span class="keywordflow">else</span>
<a name="l03657"></a>03657                     {
<a name="l03658"></a>03658                     <span class="keywordflow">if</span> (tokens)
<a name="l03659"></a>03659                         {
<a name="l03660"></a>03660                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> charInd = beginCharInd; charInd &lt; endCharInd; ++charInd)
<a name="l03661"></a>03661                             {
<a name="l03662"></a>03662                             NxsDiscreteStateCell sc = row[charInd];
<a name="l03663"></a>03663                             out &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l03664"></a>03664                             <span class="keywordflow">if</span> (sc == NXS_GAP_STATE_CODE)
<a name="l03665"></a>03665                                 out &lt;&lt; gap;
<a name="l03666"></a>03666                             <span class="keywordflow">else</span>
<a name="l03667"></a>03667                                 {
<a name="l03668"></a>03668                                 <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> sl = <a class="code" href="classNxsCharactersBlock_ab489ab6dc2335d94a0cf66f36c062a23.html#ab489ab6dc2335d94a0cf66f36c062a23">GetStateLabel</a>(charInd, sc); <span class="comment">/*v2.1to2.2 4 */</span>
<a name="l03669"></a>03669                                 <span class="keywordflow">if</span> (sl == <span class="stringliteral">&quot; &quot;</span>)
<a name="l03670"></a>03670                                     {
<a name="l03671"></a>03671                                     errormsg = <span class="stringliteral">&quot;Writing character state &quot;</span>;
<a name="l03672"></a>03672                                     errormsg &lt;&lt; 1 + sc &lt;&lt; <span class="stringliteral">&quot; for character &quot;</span> &lt;&lt; 1+charInd &lt;&lt; <span class="stringliteral">&quot;, but no appropriate chararcter label or symbol was found.&quot;</span>;
<a name="l03673"></a>03673                                     <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(errormsg);
<a name="l03674"></a>03674                                     }
<a name="l03675"></a>03675                                 <span class="keywordflow">else</span>
<a name="l03676"></a>03676                                     out  &lt;&lt; NxsString::GetEscaped(sl);
<a name="l03677"></a>03677                                 }
<a name="l03678"></a>03678                             }
<a name="l03679"></a>03679                         }
<a name="l03680"></a>03680                     <span class="keywordflow">else</span>
<a name="l03681"></a>03681                         {
<a name="l03682"></a>03682                         std::vector&lt;NxsDiscreteStateCell&gt;::const_iterator endIt = row.begin() + beginCharInd;
<a name="l03683"></a>03683                         std::vector&lt;NxsDiscreteStateCell&gt;::const_iterator begIt = endIt;
<a name="l03684"></a>03684                         <span class="keywordflow">if</span> (endCharInd == row.size())
<a name="l03685"></a>03685                             endIt = row.end();
<a name="l03686"></a>03686                         <span class="keywordflow">else</span>
<a name="l03687"></a>03687                             endIt += endCharInd - beginCharInd;
<a name="l03688"></a>03688                         dm-&gt;WriteStateCodeRowAsNexus(out, begIt, endIt);
<a name="l03689"></a>03689                         }
<a name="l03690"></a>03690                     }
<a name="l03691"></a>03691                 }
<a name="l03692"></a>03692             }
<a name="l03693"></a>03693         }
<a name="l03694"></a>03694     }
<a name="l03695"></a>03695 
<a name="l03696"></a>03696 
<a name="l03702"></a><a class="code" href="classNxsCharactersBlock_aa27c2274c404a2a8da3c0734f6cf71b6.html#aa27c2274c404a2a8da3c0734f6cf71b6">03702</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_aa27c2274c404a2a8da3c0734f6cf71b6.html#aa27c2274c404a2a8da3c0734f6cf71b6" title="Provides a dump of the contents of the `matrix&amp;#39; variable.">NxsCharactersBlock::DebugShowMatrix</a>(
<a name="l03703"></a>03703   std::ostream &amp;out,            <span class="comment">/* output stream on which to print matrix */</span>
<a name="l03704"></a>03704   <span class="keywordtype">bool</span> ,    <span class="comment">/* deprecated, matchchar no longer used for output */</span>
<a name="l03705"></a>03705   <span class="keyword">const</span> <span class="keywordtype">char</span> *marginText) <span class="keyword">const</span> <span class="comment">/* for printing first on each line */</span>
<a name="l03706"></a>03706     {
<a name="l03707"></a>03707     <span class="keywordflow">if</span> (!taxa)
<a name="l03708"></a>03708         <span class="keywordflow">return</span>;
<a name="l03709"></a>03709     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> width = taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_a50ef9fdb2944f553fc3a4d4dd94cd1ef.html#a50ef9fdb2944f553fc3a4d4dd94cd1ef">GetMaxTaxonLabelLength</a>();
<a name="l03710"></a>03710     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ntt = GetNTaxTotal();
<a name="l03711"></a>03711     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; ntt; i++)
<a name="l03712"></a>03712         {
<a name="l03713"></a>03713         <span class="keywordtype">bool</span> skip = <span class="keyword">true</span>;
<a name="l03714"></a>03714         <span class="keywordflow">if</span> (datatype == continuous)
<a name="l03715"></a>03715             {
<a name="l03716"></a>03716             <span class="keyword">const</span> ContinuousCharRow &amp; row = GetContinuousMatrixRow(i);
<a name="l03717"></a>03717             skip = row.empty();
<a name="l03718"></a>03718             }
<a name="l03719"></a>03719         <span class="keywordflow">else</span>
<a name="l03720"></a>03720             {
<a name="l03721"></a>03721             <span class="keyword">const</span> NxsDiscreteStateRow &amp; row = GetDiscreteMatrixRow(i);
<a name="l03722"></a>03722             skip = row.empty();
<a name="l03723"></a>03723             }
<a name="l03724"></a>03724         <span class="keywordflow">if</span> (!skip)
<a name="l03725"></a>03725             {
<a name="l03726"></a>03726             <span class="keywordflow">if</span> (marginText != NULL)
<a name="l03727"></a>03727                 out &lt;&lt; marginText;
<a name="l03728"></a>03728             <span class="keyword">const</span> <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> currTaxonLabel = taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_ae172f21958353f1be42371f0cad7061d.html#ae172f21958353f1be42371f0cad7061d">GetTaxonLabel</a>(i); <span class="comment">/*v2.1to2.2 4 */</span>
<a name="l03729"></a>03729             out &lt;&lt; currTaxonLabel;
<a name="l03730"></a>03730             <span class="keywordtype">unsigned</span> currTaxonLabelLen = (unsigned)currTaxonLabel.size();
<a name="l03731"></a>03731             <span class="keywordtype">unsigned</span> diff = width - currTaxonLabelLen;
<a name="l03732"></a>03732             std::string spacer(diff+5, <span class="charliteral">&#39; &#39;</span>);
<a name="l03733"></a>03733             out &lt;&lt; spacer;
<a name="l03734"></a>03734             WriteStatesForTaxonAsNexus(out, i, 0, nChar);
<a name="l03735"></a>03735             out &lt;&lt; endl;
<a name="l03736"></a>03736             }
<a name="l03737"></a>03737         }
<a name="l03738"></a>03738     }
<a name="l03739"></a>03739 
<a name="l03740"></a><a class="code" href="classNxsCharactersBlock_a9d835899411ab9797584887b0e061169.html#a9d835899411ab9797584887b0e061169">03740</a> <span class="keywordtype">unsigned</span> <a class="code" href="classNxsCharactersBlock_a9d835899411ab9797584887b0e061169.html#a9d835899411ab9797584887b0e061169">NxsCharactersBlock::GetMaxObsNumStates</a>(<span class="keywordtype">bool</span> countMissingStates, <span class="keywordtype">bool</span> onlyActiveChars) NCL_COULD_BE_CONST <span class="comment">/*v2.1to2.2 1 */</span>
<a name="l03741"></a>03741     {
<a name="l03742"></a>03742     <span class="keywordtype">unsigned</span> maxN = 1;
<a name="l03743"></a>03743     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; nChar; j++)
<a name="l03744"></a>03744         {
<a name="l03745"></a>03745         <span class="keywordflow">if</span> (!onlyActiveChars || IsActiveChar(j))
<a name="l03746"></a>03746             maxN = std::max(maxN, GetObsNumStates(j, countMissingStates));
<a name="l03747"></a>03747         }
<a name="l03748"></a>03748     <span class="keywordflow">return</span> maxN;
<a name="l03749"></a>03749     }
<a name="l03750"></a>03750 
<a name="l03754"></a><a class="code" href="classNxsCharactersBlock_a70ac339754cea27d384d18a3835c446d.html#a70ac339754cea27d384d18a3835c446d">03754</a> <span class="keywordtype">unsigned</span> <a class="code" href="classNxsCharactersBlock_a70ac339754cea27d384d18a3835c446d.html#a70ac339754cea27d384d18a3835c446d" title="Returns the number of characters that have not been exclude (via exset or eliminate...">NxsCharactersBlock::GetNumActiveChar</a>() NCL_COULD_BE_CONST <span class="comment">/*v2.1to2.2 1 */</span>
<a name="l03755"></a>03755     {
<a name="l03756"></a>03756     <span class="keywordtype">unsigned</span> num_active_char = 0;
<a name="l03757"></a>03757     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; nChar; i++)
<a name="l03758"></a>03758         {
<a name="l03759"></a>03759         <span class="keywordflow">if</span> (<a class="code" href="classNxsCharactersBlock_a1a2ac1c77126d46dab11200bc1869258.html#a1a2ac1c77126d46dab11200bc1869258">IsActiveChar</a>(i))
<a name="l03760"></a>03760             num_active_char++;
<a name="l03761"></a>03761         }
<a name="l03762"></a>03762     <span class="keywordflow">return</span> num_active_char;
<a name="l03763"></a>03763     }
<a name="l03764"></a>03764 
<a name="l03765"></a>03765 
<a name="l03766"></a>03766 
<a name="l03767"></a>03767 <span class="comment">/* Returns label for character state `j&#39; at character `i&#39;, if a label has been specified. If no label was specified,</span>
<a name="l03768"></a>03768 <span class="comment">    returns string containing a single blank (i.e., &quot; &quot;).</span>
<a name="l03769"></a>03769 <span class="comment">*/</span>
<a name="l03770"></a>03770 <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> NxsCharactersBlock::GetStateLabelImpl( <span class="comment">/*v2.1to2.2 4 */</span>
<a name="l03771"></a>03771   <span class="keywordtype">unsigned</span> i,   <span class="comment">/* the locus in range [0..`nChar&#39;) */</span>
<a name="l03772"></a>03772   <span class="keywordtype">unsigned</span> j) <span class="keyword">const</span> <span class="comment">/* the 0-offset index of the state of interest */</span>
<a name="l03773"></a>03773     {
<a name="l03774"></a>03774     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> s = <span class="stringliteral">&quot; &quot;</span>;
<a name="l03775"></a>03775     NxsStringVectorMap::const_iterator cib = charStates.find(i);
<a name="l03776"></a>03776     <span class="keywordflow">if</span> (cib != charStates.end() &amp;&amp; j &lt; static_cast&lt;unsigned&gt;(cib-&gt;second.size()))
<a name="l03777"></a>03777         <span class="keywordflow">return</span> cib-&gt;second[j];
<a name="l03778"></a>03778     <span class="keywordflow">if</span> (!globalStateLabels.empty() &amp;&amp; (j &lt; globalStateLabels.size()))
<a name="l03779"></a>03779         <span class="keywordflow">return</span> globalStateLabels[j];
<a name="l03780"></a>03780     <span class="keywordflow">return</span> s;
<a name="l03781"></a>03781     }
<a name="l03782"></a>03782 
<a name="l03783"></a>03783 
<a name="l03788"></a><a class="code" href="classNxsCharactersBlock_a2d652b95a2fe2d09fff6e8df0d64c7c4.html#a2d652b95a2fe2d09fff6e8df0d64c7c4">03788</a> <span class="keywordtype">bool</span> <a class="code" href="classNxsCharactersBlock_a2d652b95a2fe2d09fff6e8df0d64c7c4.html#a2d652b95a2fe2d09fff6e8df0d64c7c4" title="Returns true if `ch&amp;#39; can be found in the `symbols&amp;#39; array.">NxsCharactersBlock::IsInSymbols</a>(
<a name="l03789"></a>03789   <span class="keywordtype">char</span> ch) NCL_COULD_BE_CONST <span class="comment">/* the symbol character to search for */</span> <span class="comment">/*v2.1to2.2 1 */</span>
<a name="l03790"></a>03790     {
<a name="l03791"></a>03791     <span class="keywordtype">char</span> char_in_question = (respectingCase ? ch : (char)toupper(ch));
<a name="l03792"></a>03792     <span class="keywordflow">for</span> (std::string::const_iterator sIt = symbols.begin(); sIt != symbols.end(); ++sIt)
<a name="l03793"></a>03793         {
<a name="l03794"></a>03794         <span class="keyword">const</span> <span class="keywordtype">char</span> char_in_symbols = (respectingCase ? *sIt : (char)toupper(*sIt));
<a name="l03795"></a>03795         <span class="keywordflow">if</span> (char_in_symbols == char_in_question)
<a name="l03796"></a>03796             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03797"></a>03797         }
<a name="l03798"></a>03798     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03799"></a>03799     }
<a name="l03800"></a>03800 
<a name="l03806"></a><a class="code" href="classNxsCharactersBlock_a687f6d028e959d04e8662251b1946514.html#a687f6d028e959d04e8662251b1946514">03806</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_a687f6d028e959d04e8662251b1946514.html#a687f6d028e959d04e8662251b1946514" title="Called when CHARLABELS command needs to be parsed from within the DIMENSIONS block...">NxsCharactersBlock::HandleCharlabels</a>(
<a name="l03807"></a>03807   <a class="code" href="classNxsToken.html">NxsToken</a> &amp;token)  <span class="comment">/* the token used to read from `in&#39; */</span>
<a name="l03808"></a>03808     {
<a name="l03809"></a>03809     ucCharLabelToIndex.clear();
<a name="l03810"></a>03810     indToCharLabel.clear();
<a name="l03811"></a>03811     <span class="keywordtype">unsigned</span> ind = 0;
<a name="l03812"></a>03812     <span class="keywordflow">for</span> (;;)
<a name="l03813"></a>03813         {
<a name="l03814"></a>03814         token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l03815"></a>03815         <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;;&quot;</span>))
<a name="l03816"></a>03816             <span class="keywordflow">break</span>;
<a name="l03817"></a>03817         <span class="keywordflow">else</span>
<a name="l03818"></a>03818             {
<a name="l03819"></a>03819             <span class="keywordflow">if</span> (ind &gt;= nChar)
<a name="l03820"></a>03820                 <a class="code" href="classNxsBlock_a9106779865a661477259f3d84edb36a5.html#a9106779865a661477259f3d84edb36a5" title="throws a NxsException with the token info for `token` `expected` should fill in the...">GenerateNxsException</a>(token, <span class="stringliteral">&quot;Number of character labels exceeds NCHAR specified in DIMENSIONS command&quot;</span>);
<a name="l03821"></a>03821             <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> t = token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>();
<a name="l03822"></a>03822             <span class="keywordflow">if</span> (t != <span class="stringliteral">&quot; &quot;</span>)
<a name="l03823"></a>03823                 {
<a name="l03824"></a>03824                 indToCharLabel[ind] = t;
<a name="l03825"></a>03825                 t.ToUpper();
<a name="l03826"></a>03826                 ucCharLabelToIndex[t] = ind;
<a name="l03827"></a>03827                 }
<a name="l03828"></a>03828             ind++;
<a name="l03829"></a>03829             }
<a name="l03830"></a>03830         }
<a name="l03831"></a>03831     }
<a name="l03832"></a>03832 
<a name="l03840"></a><a class="code" href="classNxsCharactersBlock_a28830ac9b39ade49fefafb2e7ba33a16.html#a28830ac9b39ade49fefafb2e7ba33a16">03840</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_a28830ac9b39ade49fefafb2e7ba33a16.html#a28830ac9b39ade49fefafb2e7ba33a16" title="Called when CHARSTATELABELS command needs to be parsed from within the CHARACTERS...">NxsCharactersBlock::HandleCharstatelabels</a>(
<a name="l03841"></a>03841   <a class="code" href="classNxsToken.html">NxsToken</a> &amp;token)  <span class="comment">/* the token used to read from `in&#39; */</span>
<a name="l03842"></a>03842     {
<a name="l03843"></a>03843     <span class="keywordtype">unsigned</span> currChar = 0;
<a name="l03844"></a>03844     <span class="keywordtype">bool</span> semicolonFoundInInnerLoop = <span class="keyword">false</span>;
<a name="l03845"></a>03845     <span class="keywordtype">bool</span> tokenAlreadyRead = <span class="keyword">false</span>;
<a name="l03846"></a>03846     <span class="keywordtype">bool</span> save = <span class="keyword">true</span>;
<a name="l03847"></a>03847 
<a name="l03848"></a>03848     charStates.clear();
<a name="l03849"></a>03849     ucCharLabelToIndex.clear();
<a name="l03850"></a>03850     indToCharLabel.clear();
<a name="l03851"></a>03851 
<a name="l03852"></a>03852     <span class="keywordflow">for</span> (;;)
<a name="l03853"></a>03853         {
<a name="l03854"></a>03854         save = <span class="keyword">true</span>;
<a name="l03855"></a>03855 
<a name="l03856"></a>03856         <span class="keywordflow">if</span> (semicolonFoundInInnerLoop)
<a name="l03857"></a>03857             <span class="keywordflow">break</span>;
<a name="l03858"></a>03858 
<a name="l03859"></a>03859         <span class="keywordflow">if</span> (tokenAlreadyRead)
<a name="l03860"></a>03860             tokenAlreadyRead = <span class="keyword">false</span>;
<a name="l03861"></a>03861         <span class="keywordflow">else</span>
<a name="l03862"></a>03862             token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l03863"></a>03863 
<a name="l03864"></a>03864         <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;;&quot;</span>))
<a name="l03865"></a>03865             <span class="keywordflow">break</span>;
<a name="l03866"></a>03866 
<a name="l03867"></a>03867         <span class="comment">// Token should be the character number; create a new association</span>
<a name="l03868"></a>03868         <span class="comment">//</span>
<a name="l03869"></a>03869         <span class="keywordtype">int</span> sn = atoi(token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>().c_str());
<a name="l03870"></a>03870         <span class="keywordtype">unsigned</span> n = (unsigned)sn;
<a name="l03871"></a>03871         <span class="keywordflow">if</span> (sn &lt; 1 || n &gt; nChar || n &lt;= currChar)
<a name="l03872"></a>03872             {
<a name="l03873"></a>03873             errormsg = <span class="stringliteral">&quot;Invalid character number (&quot;</span>;
<a name="l03874"></a>03874             errormsg += token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>();
<a name="l03875"></a>03875             errormsg += <span class="stringliteral">&quot;) found in CHARSTATELABELS command (either out of range or not interpretable as an integer)&quot;</span>;
<a name="l03876"></a>03876             <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token.<a class="code" href="classNxsToken_a17e5caf91acc756c23159f76f8b2d0fd.html#a17e5caf91acc756c23159f76f8b2d0fd" title="Returns value stored in filepos, which keeps track of the current position in the...">GetFilePosition</a>(), token.<a class="code" href="classNxsToken_ae0fb11bf350d907295447864afa714ec.html#ae0fb11bf350d907295447864afa714ec" title="Returns value stored in `fileline&amp;#39;, which keeps track of the current line in...">GetFileLine</a>(), token.<a class="code" href="classNxsToken_a7272fd1469fa6424086a95ec4f92eab0.html#a7272fd1469fa6424086a95ec4f92eab0" title="Returns value stored in `filecol&amp;#39;, which keeps track of the current column in...">GetFileColumn</a>());
<a name="l03877"></a>03877             }
<a name="l03878"></a>03878 
<a name="l03879"></a>03879         currChar = n;
<a name="l03880"></a>03880 
<a name="l03881"></a>03881         token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l03882"></a>03882 
<a name="l03883"></a>03883         <span class="comment">// Token should be the character label or / if there is no label</span>
<a name="l03884"></a>03884         <span class="comment">//  &#39; &#39; is a placeholder for no label.</span>
<a name="l03885"></a>03885         <span class="comment">//</span>
<a name="l03886"></a>03886         <span class="keywordflow">if</span> (save)
<a name="l03887"></a>03887             {
<a name="l03888"></a>03888             <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> t = token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>();
<a name="l03889"></a>03889             <span class="keywordflow">if</span> (t != <span class="stringliteral">&quot; &quot;</span> &amp;&amp; !token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;/&quot;</span>))
<a name="l03890"></a>03890                 {
<a name="l03891"></a>03891                 indToCharLabel[currChar - 1] = t;
<a name="l03892"></a>03892                 t.ToUpper();
<a name="l03893"></a>03893                 ucCharLabelToIndex[t] = currChar - 1;
<a name="l03894"></a>03894                 }
<a name="l03895"></a>03895             }
<a name="l03896"></a>03896         <span class="keywordflow">if</span> (!token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;/&quot;</span>))
<a name="l03897"></a>03897             token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l03898"></a>03898 
<a name="l03899"></a>03899         <span class="comment">// Token should be a slash character if state labels were provided for this character; otherwise,</span>
<a name="l03900"></a>03900         <span class="comment">// token should be one of the following:</span>
<a name="l03901"></a>03901         <span class="comment">// 1) the comma separating information for different characters, in which case we read in the</span>
<a name="l03902"></a>03902         <span class="comment">//    next token (which should be the next character number)</span>
<a name="l03903"></a>03903         <span class="comment">// 2) the semicolon indicating the end of the command</span>
<a name="l03904"></a>03904         <span class="comment">//</span>
<a name="l03905"></a>03905         <span class="keywordflow">if</span> (!token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;/&quot;</span>))
<a name="l03906"></a>03906             {
<a name="l03907"></a>03907             <span class="keywordflow">if</span> (!token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;,&quot;</span>) &amp;&amp; !token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;;&quot;</span>))
<a name="l03908"></a>03908                 {
<a name="l03909"></a>03909                 errormsg = <span class="stringliteral">&quot;Expecting a comma or semicolon here, but found \&quot;&quot;</span>;
<a name="l03910"></a>03910                 errormsg += token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>();
<a name="l03911"></a>03911                 errormsg += <span class="stringliteral">&quot;\&quot; instead&quot;</span>;
<a name="l03912"></a>03912                 <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token.<a class="code" href="classNxsToken_a17e5caf91acc756c23159f76f8b2d0fd.html#a17e5caf91acc756c23159f76f8b2d0fd" title="Returns value stored in filepos, which keeps track of the current position in the...">GetFilePosition</a>(), token.<a class="code" href="classNxsToken_ae0fb11bf350d907295447864afa714ec.html#ae0fb11bf350d907295447864afa714ec" title="Returns value stored in `fileline&amp;#39;, which keeps track of the current line in...">GetFileLine</a>(), token.<a class="code" href="classNxsToken_a7272fd1469fa6424086a95ec4f92eab0.html#a7272fd1469fa6424086a95ec4f92eab0" title="Returns value stored in `filecol&amp;#39;, which keeps track of the current column in...">GetFileColumn</a>());
<a name="l03913"></a>03913                 }
<a name="l03914"></a>03914             <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;,&quot;</span>))
<a name="l03915"></a>03915                 token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l03916"></a>03916             tokenAlreadyRead = <span class="keyword">true</span>;
<a name="l03917"></a>03917             <span class="keywordflow">continue</span>;
<a name="l03918"></a>03918             }
<a name="l03919"></a>03919 
<a name="l03920"></a>03920         <span class="comment">// Now create a new association for the character states list</span>
<a name="l03921"></a>03921 
<a name="l03922"></a>03922         <span class="keywordflow">for</span> (;;)
<a name="l03923"></a>03923             {
<a name="l03924"></a>03924             token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l03925"></a>03925 
<a name="l03926"></a>03926             <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;;&quot;</span>))
<a name="l03927"></a>03927                 {
<a name="l03928"></a>03928                 semicolonFoundInInnerLoop = <span class="keyword">true</span>;
<a name="l03929"></a>03929                 <span class="keywordflow">break</span>;
<a name="l03930"></a>03930                 }
<a name="l03931"></a>03931 
<a name="l03932"></a>03932             <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;,&quot;</span>))
<a name="l03933"></a>03933                 <span class="keywordflow">break</span>;
<a name="l03934"></a>03934 
<a name="l03935"></a>03935             <span class="keywordflow">if</span> (save)
<a name="l03936"></a>03936                 {
<a name="l03937"></a>03937                 <span class="keywordflow">if</span> (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">continuous</a>)
<a name="l03938"></a>03938                     <a class="code" href="classNxsBlock_a9106779865a661477259f3d84edb36a5.html#a9106779865a661477259f3d84edb36a5" title="throws a NxsException with the token info for `token` `expected` should fill in the...">GenerateNxsException</a>(token, <span class="stringliteral">&quot;State Labels cannot be specified when the datatype is continuous&quot;</span>);
<a name="l03939"></a>03939 
<a name="l03940"></a>03940                 <span class="comment">// Token should be a character state label; add it to the list</span>
<a name="l03941"></a>03941                 <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> cslabel = token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>();
<a name="l03942"></a>03942                 charStates[n - 1].push_back(cslabel);
<a name="l03943"></a>03943                 }
<a name="l03944"></a>03944 
<a name="l03945"></a>03945             } <span class="comment">// inner for (;;) loop (grabbing state labels for character n)</span>
<a name="l03946"></a>03946         } <span class="comment">// outer for (;;) loop</span>
<a name="l03947"></a>03947     }
<a name="l03948"></a>03948 
<a name="l03956"></a><a class="code" href="classNxsCharactersBlock_a2403d3b7e8c91566a2bb39dc7807e33e.html#a2403d3b7e8c91566a2bb39dc7807e33e">03956</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_a2403d3b7e8c91566a2bb39dc7807e33e.html#a2403d3b7e8c91566a2bb39dc7807e33e" title="Called when DIMENSIONS command needs to be parsed from within the CHARACTERS block...">NxsCharactersBlock::HandleDimensions</a>(
<a name="l03957"></a>03957   <a class="code" href="classNxsToken.html">NxsToken</a> &amp;token,          <span class="comment">/* the token used to read from `in&#39; */</span>
<a name="l03958"></a>03958   <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> newtaxaLabel,   <span class="comment">/* the label used in data file for `newtaxa&#39; */</span>
<a name="l03959"></a>03959   <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> ntaxLabel,      <span class="comment">/* the label used in data file for `ntax&#39; */</span>
<a name="l03960"></a>03960   <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> ncharLabel)     <span class="comment">/* the label used in data file for `nChar&#39; */</span>
<a name="l03961"></a>03961     {
<a name="l03962"></a>03962     nChar = 0;
<a name="l03963"></a>03963     <span class="keywordtype">unsigned</span> ntaxRead = 0;
<a name="l03964"></a>03964     <span class="keywordflow">for</span> (;;)
<a name="l03965"></a>03965         {
<a name="l03966"></a>03966         token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l03967"></a>03967         <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(newtaxaLabel))
<a name="l03968"></a>03968             newtaxa = <span class="keyword">true</span>;
<a name="l03969"></a>03969         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(ntaxLabel))
<a name="l03970"></a>03970             {
<a name="l03971"></a>03971             <a class="code" href="classNxsBlock_aee6771bdd0c70f375d925c4e0b6d1095.html#aee6771bdd0c70f375d925c4e0b6d1095" title="Advances the token, and raise an exception if it is not an equals sign.">DemandEquals</a>(token, <span class="stringliteral">&quot;after NTAX in DIMENSIONS command&quot;</span>);
<a name="l03972"></a>03972             ntaxRead = <a class="code" href="classNxsBlock_a67feaaa54959cb9faa9cbfaaa67b7ce2.html#a67feaaa54959cb9faa9cbfaaa67b7ce2" title="Advances the token, and returns the unsigned int that the token represents.">DemandPositiveInt</a>(token, ntaxLabel.c_str());
<a name="l03973"></a>03973             }
<a name="l03974"></a>03974         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(ncharLabel))
<a name="l03975"></a>03975             {
<a name="l03976"></a>03976             <a class="code" href="classNxsBlock_aee6771bdd0c70f375d925c4e0b6d1095.html#aee6771bdd0c70f375d925c4e0b6d1095" title="Advances the token, and raise an exception if it is not an equals sign.">DemandEquals</a>(token, <span class="stringliteral">&quot;in DIMENSIONS command&quot;</span>);
<a name="l03977"></a>03977             nChar = <a class="code" href="classNxsBlock_a67feaaa54959cb9faa9cbfaaa67b7ce2.html#a67feaaa54959cb9faa9cbfaaa67b7ce2" title="Advances the token, and returns the unsigned int that the token represents.">DemandPositiveInt</a>(token, ncharLabel.c_str());
<a name="l03978"></a>03978             }
<a name="l03979"></a>03979         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;;&quot;</span>))
<a name="l03980"></a>03980             <span class="keywordflow">break</span>;
<a name="l03981"></a>03981         }
<a name="l03982"></a>03982 
<a name="l03983"></a>03983     <span class="keywordflow">if</span> (nChar == 0)
<a name="l03984"></a>03984         {
<a name="l03985"></a>03985         errormsg = <span class="stringliteral">&quot;DIMENSIONS command must have an NCHAR subcommand .&quot;</span>;
<a name="l03986"></a>03986         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l03987"></a>03987         }
<a name="l03988"></a>03988     <span class="keywordflow">if</span> (newtaxa)
<a name="l03989"></a>03989         {
<a name="l03990"></a>03990         <span class="keywordflow">if</span> (ntaxRead == 0)
<a name="l03991"></a>03991             {
<a name="l03992"></a>03992             errormsg = <span class="stringliteral">&quot;DIMENSIONS command must have an NTAX subcommand when the NEWTAXA option is in effect.&quot;</span>;
<a name="l03993"></a>03993             <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l03994"></a>03994             }
<a name="l03995"></a>03995         AssureTaxaBlock(createImpliedBlock, token, <span class="stringliteral">&quot;Dimensions&quot;</span>);
<a name="l03996"></a>03996         <span class="keywordflow">if</span> (!createImpliedBlock)
<a name="l03997"></a>03997             {
<a name="l03998"></a>03998             taxa-&gt;<a class="code" href="classNxsBlock_a3642d732dd82298ef2f35a7b83b97719.html#a3642d732dd82298ef2f35a7b83b97719" title="This virtual function should be overridden for each derived class to completely reset...">Reset</a>();
<a name="l03999"></a>03999             <span class="keywordflow">if</span> (nexusReader)
<a name="l04000"></a>04000                 nexusReader-&gt;<a class="code" href="classNxsReader_ad05c38b8d256b9acca8be01f645d9f9e.html#ad05c38b8d256b9acca8be01f645d9f9e" title="Removes a block from the NxsReader&amp;#39;s records.">RemoveBlockFromUsedBlockList</a>(taxa);
<a name="l04001"></a>04001             }
<a name="l04002"></a>04002         taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_a83f32ad078abc3afc501ede2780cc655.html#a83f32ad078abc3afc501ede2780cc655" title="Sets the number of taxa to be included in the block.">SetNtax</a>(ntaxRead);
<a name="l04003"></a>04003         nTaxWithData = ntaxRead;
<a name="l04004"></a>04004         }
<a name="l04005"></a>04005     <span class="keywordflow">else</span>
<a name="l04006"></a>04006         {
<a name="l04007"></a>04007         AssureTaxaBlock(<span class="keyword">false</span>, token, <span class="stringliteral">&quot;Dimensions&quot;</span>);
<a name="l04008"></a>04008         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ntaxinblock = taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_a3e9b998d97ad05914bda0d616069c26f.html#a3e9b998d97ad05914bda0d616069c26f">GetNTax</a>();
<a name="l04009"></a>04009         <span class="keywordflow">if</span> (ntaxinblock == 0)
<a name="l04010"></a>04010             {
<a name="l04011"></a>04011             errormsg = <span class="stringliteral">&quot;A TAXA block must be read before character data, or the DIMENSIONS command must use the NEWTAXA.&quot;</span>;
<a name="l04012"></a>04012             <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l04013"></a>04013             }
<a name="l04014"></a>04014 
<a name="l04015"></a>04015         <span class="keywordflow">if</span> (ntaxinblock &lt; ntaxRead)
<a name="l04016"></a>04016             {
<a name="l04017"></a>04017             errormsg = ntaxLabel;
<a name="l04018"></a>04018             errormsg += <span class="stringliteral">&quot; in &quot;</span>;
<a name="l04019"></a>04019             errormsg += id;
<a name="l04020"></a>04020             errormsg += <span class="stringliteral">&quot; block must be less than or equal to NTAX in TAXA block\nNote: one circumstance that can cause this error is \nforgetting to specify &quot;</span>;
<a name="l04021"></a>04021             errormsg += ntaxLabel;
<a name="l04022"></a>04022             errormsg += <span class="stringliteral">&quot; in DIMENSIONS command when \na TAXA block has not been provided&quot;</span>;
<a name="l04023"></a>04023             <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token.<a class="code" href="classNxsToken_a17e5caf91acc756c23159f76f8b2d0fd.html#a17e5caf91acc756c23159f76f8b2d0fd" title="Returns value stored in filepos, which keeps track of the current position in the...">GetFilePosition</a>(), token.<a class="code" href="classNxsToken_ae0fb11bf350d907295447864afa714ec.html#ae0fb11bf350d907295447864afa714ec" title="Returns value stored in `fileline&amp;#39;, which keeps track of the current line in...">GetFileLine</a>(), token.<a class="code" href="classNxsToken_a7272fd1469fa6424086a95ec4f92eab0.html#a7272fd1469fa6424086a95ec4f92eab0" title="Returns value stored in `filecol&amp;#39;, which keeps track of the current column in...">GetFileColumn</a>());
<a name="l04024"></a>04024             }
<a name="l04025"></a>04025         nTaxWithData = (ntaxRead == 0 ? ntaxinblock : ntaxRead);
<a name="l04026"></a>04026         }
<a name="l04027"></a>04027     }
<a name="l04028"></a>04028 
<a name="l04039"></a><a class="code" href="classNxsCharactersBlock_a051b9cfd99599fd8894c067274952d30.html#a051b9cfd99599fd8894c067274952d30">04039</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_a051b9cfd99599fd8894c067274952d30.html#a051b9cfd99599fd8894c067274952d30" title="Called when ELIMINATE command needs to be parsed from within the CHARACTERS block...">NxsCharactersBlock::HandleEliminate</a>(
<a name="l04040"></a>04040   <a class="code" href="classNxsToken.html">NxsToken</a> &amp;token)  <span class="comment">/* the token used to read from `in&#39; */</span>
<a name="l04041"></a>04041     {
<a name="l04042"></a>04042     <span class="keywordflow">if</span> (!eliminated.empty() &amp;&amp; nexusReader)
<a name="l04043"></a>04043         nexusReader-&gt;<a class="code" href="classNxsReader_aa81b33d57a4c5ddac0d5ccbf81df9c5b.html#aa81b33d57a4c5ddac0d5ccbf81df9c5b" title="Used internally as a more convenient way of calling NexusWarn.">NexusWarnToken</a>(<span class="stringliteral">&quot;Only one ELIMINATE command should be used in a CHARACTERS or DATA block (it must appear before the MATRIX command).\n   New character eliminations will be added to the previous eliminated characters (the previously eliminated characters will continue to be excluded).&quot;</span>, <a class="code" href="classNxsReader_a409e01dc0baecef7ed471879c0692978.html#a409e01dc0baecef7ed471879c0692978a169bf0d8bc84d8d34258db0ec7fe1c4a">NxsReader::UNCOMMON_SYNTAX_WARNING</a>, token);
<a name="l04044"></a>04044     token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l04045"></a>04045     <a class="code" href="classNxsSetReader_ac6f29f1443b854aacc64be03c1b96f02.html#ac6f29f1443b854aacc64be03c1b96f02">NxsSetReader::ReadSetDefinition</a>(token, *<span class="keyword">this</span>, <span class="stringliteral">&quot;Character&quot;</span>, <span class="stringliteral">&quot;Eliminate&quot;</span>, &amp;eliminated);
<a name="l04046"></a>04046     NCL_ASSERT(eliminated.size() &lt;= nChar);
<a name="l04047"></a>04047     <span class="keywordflow">for</span> (NxsUnsignedSet::const_iterator elIt = eliminated.begin(); elIt != eliminated.end(); ++elIt)
<a name="l04048"></a>04048         excluded.insert(*elIt);
<a name="l04049"></a>04049     }
<a name="l04050"></a>04050 
<a name="l04051"></a>04051 
<a name="l04052"></a>04052 
<a name="l04057"></a><a class="code" href="classNxsCharactersBlock_afa4e2954e61ccdfaafda0609d294d729.html#afa4e2954e61ccdfaafda0609d294d729">04057</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_afa4e2954e61ccdfaafda0609d294d729.html#afa4e2954e61ccdfaafda0609d294d729" title="Called from HandleMatrix function to read in a standard (i.e., non-transposed) matrix...">NxsCharactersBlock::HandleStdMatrix</a>(
<a name="l04058"></a>04058   <a class="code" href="classNxsToken.html">NxsToken</a> &amp;token)  <span class="comment">/* the token used to read from `in&#39; */</span>
<a name="l04059"></a>04059     {
<a name="l04060"></a>04060     NCL_ASSERT(taxa != NULL);
<a name="l04061"></a>04061     <span class="keywordtype">unsigned</span> indOfTaxInCommand;
<a name="l04062"></a>04062     <span class="keywordtype">unsigned</span> indOfTaxInMemory;
<a name="l04063"></a>04063     <span class="keywordtype">unsigned</span> currChar = 0;
<a name="l04064"></a>04064     <span class="keywordtype">unsigned</span> firstChar = 0;
<a name="l04065"></a>04065     <span class="keywordtype">unsigned</span> lastChar = nChar;
<a name="l04066"></a>04066     <span class="keywordtype">unsigned</span> nextFirst = 0;
<a name="l04067"></a>04067     <span class="keywordtype">unsigned</span> page = 0;
<a name="l04068"></a>04068     <span class="keyword">const</span> <span class="keywordtype">bool</span> continuousData =  (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>);
<a name="l04069"></a>04069     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ntlabels = taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_ad875bc0358bc242d998a1e84f5cefccb.html#ad875bc0358bc242d998a1e84f5cefccb">GetNumTaxonLabels</a>();
<a name="l04070"></a>04070     errormsg.<a class="code" href="classNxsString_abbf904c772d9776139dcae602c9fd06b.html#abbf904c772d9776139dcae602c9fd06b" title="Most containers in the standard template library can be completely erased using the...">clear</a>();
<a name="l04071"></a>04071     <span class="keywordtype">bool</span> taxaBlockNeedsLabels = (ntlabels == 0);
<a name="l04072"></a>04072     <span class="keywordflow">if</span> (!taxaBlockNeedsLabels &amp;&amp; ntlabels &lt; nTaxWithData)
<a name="l04073"></a>04073         {
<a name="l04074"></a>04074         errormsg &lt;&lt; <span class="stringliteral">&quot;Not enough taxlabels are known to read characters for &quot;</span> &lt;&lt; nTaxWithData &lt;&lt; <span class="stringliteral">&quot; taxa in the Matrix command.&quot;</span>;
<a name="l04075"></a>04075         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l04076"></a>04076         }
<a name="l04077"></a>04077     ContinuousCharRow emptyContRow;
<a name="l04078"></a>04078     NxsDiscreteStateRow emptyDiscRow;
<a name="l04079"></a>04079     ContinuousCharRow *contRowPtr = NULL;
<a name="l04080"></a>04080     NxsDiscreteStateRow *discRowPtr = NULL;
<a name="l04081"></a>04081     ContinuousCharRow *ftContRowPtr = NULL;
<a name="l04082"></a>04082     NxsDiscreteStateRow *ftDiscRowPtr = NULL;
<a name="l04083"></a>04083     <span class="keyword">const</span> <span class="keywordtype">bool</span> isContinuous = (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>);
<a name="l04084"></a>04084     <span class="keywordflow">if</span> (isContinuous)
<a name="l04085"></a>04085         emptyContRow.resize(nChar);
<a name="l04086"></a>04086     <span class="keywordflow">else</span>
<a name="l04087"></a>04087         emptyDiscRow.assign(nChar, NXS_INVALID_STATE_CODE);
<a name="l04088"></a>04088     std::vector&lt;unsigned&gt; toInMem(nTaxWithData, UINT_MAX);
<a name="l04089"></a>04089     std::vector&lt;unsigned&gt; nCharsRead(nTaxWithData, 0);
<a name="l04090"></a>04090 
<a name="l04091"></a>04091     <span class="keywordtype">unsigned</span> numSigInts = <a class="code" href="classNxsReader_a35e901783be459c60ced0e39e25a3ed5.html#a35e901783be459c60ced0e39e25a3ed5" title="Usually used internally when signal catching is enabled.">NxsReader::getNumSignalIntsCaught</a>();
<a name="l04092"></a>04092     <span class="keyword">const</span> <span class="keywordtype">bool</span> checkingSignals = <a class="code" href="classNxsReader_aa088a8f8a22743b2658f8a9768c6a31f.html#aa088a8f8a22743b2658f8a9768c6a31f">NxsReader::getNCLCatchesSignals</a>();
<a name="l04093"></a>04093     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> MAX_NUM_CHARS_BETWEEN_SIGNAL_CHECKS = 1000;
<a name="l04094"></a>04094     <span class="keywordflow">for</span> (; currChar &lt; nChar; page++)
<a name="l04095"></a>04095         {
<a name="l04096"></a>04096         <span class="keywordflow">for</span> (indOfTaxInCommand = 0; indOfTaxInCommand &lt; nTaxWithData ; indOfTaxInCommand++)
<a name="l04097"></a>04097             {
<a name="l04098"></a>04098             <span class="keywordtype">unsigned</span> numCharsSinceLastSignalCheck = 0;
<a name="l04099"></a>04099             <span class="keywordflow">if</span> (checkingSignals &amp;&amp; <a class="code" href="classNxsReader_a35e901783be459c60ced0e39e25a3ed5.html#a35e901783be459c60ced0e39e25a3ed5" title="Usually used internally when signal catching is enabled.">NxsReader::getNumSignalIntsCaught</a>() != numSigInts)
<a name="l04100"></a>04100                 {
<a name="l04101"></a>04101                 <span class="keywordflow">if</span> (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>)
<a name="l04102"></a>04102                     continuousMatrix.clear();
<a name="l04103"></a>04103                 <span class="keywordflow">else</span>
<a name="l04104"></a>04104                     discreteMatrix.clear();
<a name="l04105"></a>04105                 <span class="keywordflow">throw</span> NxsSignalCanceledParseException(<span class="stringliteral">&quot;Reading Characters Block&quot;</span>);
<a name="l04106"></a>04106                 }
<a name="l04107"></a>04107             <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> nameStr;
<a name="l04108"></a>04108             <span class="keywordflow">if</span> (labels)
<a name="l04109"></a>04109                 {
<a name="l04110"></a>04110                 token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l04111"></a>04111                 nameStr = token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>();
<a name="l04112"></a>04112                 <span class="keywordflow">if</span> (taxaBlockNeedsLabels)
<a name="l04113"></a>04113                     {
<a name="l04114"></a>04114                     <span class="keywordflow">if</span> (taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_a82efb07d79a05062e57b98de6f33cbba.html#a82efb07d79a05062e57b98de6f33cbba">IsAlreadyDefined</a>(nameStr))
<a name="l04115"></a>04115                         {
<a name="l04116"></a>04116                         errormsg &lt;&lt; <span class="stringliteral">&quot;Data for this taxon (&quot;</span> &lt;&lt; nameStr &lt;&lt; <span class="stringliteral">&quot;) has already been saved&quot;</span>;
<a name="l04117"></a>04117                         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l04118"></a>04118                         }
<a name="l04119"></a>04119                     indOfTaxInMemory = taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_adb06043c2f1668102b6f0b725c7612b8.html#adb06043c2f1668102b6f0b725c7612b8" title="Adds taxon label &amp;#39;s&amp;#39; to end of list of taxon labels and increments dimNTax...">AddTaxonLabel</a>(nameStr);
<a name="l04120"></a>04120                     }
<a name="l04121"></a>04121                 <span class="keywordflow">else</span>
<a name="l04122"></a>04122                     {
<a name="l04123"></a>04123                     <span class="keywordtype">unsigned</span> numOfTaxInMemory = taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_a708b8b703ca7b354ae00b720dbb150a8.html#a708b8b703ca7b354ae00b720dbb150a8">TaxLabelToNumber</a>(nameStr);
<a name="l04124"></a>04124                     <span class="keywordflow">if</span> (numOfTaxInMemory == 0)
<a name="l04125"></a>04125                         {
<a name="l04126"></a>04126                         <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;;&quot;</span>))
<a name="l04127"></a>04127                             {
<a name="l04128"></a>04128                             <span class="keywordflow">if</span> (currChar != nChar)
<a name="l04129"></a>04129                                 errormsg &lt;&lt; <span class="stringliteral">&quot;Unexpected ; (after only &quot;</span> &lt;&lt; currChar &lt;&lt; <span class="stringliteral">&quot; characters were read)&quot;</span>;
<a name="l04130"></a>04130                             <span class="keywordflow">else</span>
<a name="l04131"></a>04131                                 errormsg &lt;&lt; <span class="stringliteral">&quot;Unexpected ; (after characters were read for only &quot;</span> &lt;&lt; indOfTaxInCommand &lt;&lt; <span class="stringliteral">&quot;out of &quot;</span> &lt;&lt; nTaxWithData &lt;&lt; <span class="stringliteral">&quot; taxa)&quot;</span>;
<a name="l04132"></a>04132                             }
<a name="l04133"></a>04133                         <span class="keywordflow">else</span>
<a name="l04134"></a>04134                             errormsg &lt;&lt; <span class="stringliteral">&quot;Could not find taxon named \&quot;&quot;</span> &lt;&lt; nameStr &lt;&lt; <span class="stringliteral">&quot;\&quot; among stored taxon labels&quot;</span>;
<a name="l04135"></a>04135                         <span class="keywordflow">if</span> (currChar &gt; 0)
<a name="l04136"></a>04136                             errormsg &lt;&lt; <span class="stringliteral">&quot;\n   Expecting data for taxon \&quot;&quot;</span> &lt;&lt; taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_ae172f21958353f1be42371f0cad7061d.html#ae172f21958353f1be42371f0cad7061d">GetTaxonLabel</a>(toInMem[indOfTaxInCommand]) &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;
<a name="l04137"></a>04137                         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token.<a class="code" href="classNxsToken_a17e5caf91acc756c23159f76f8b2d0fd.html#a17e5caf91acc756c23159f76f8b2d0fd" title="Returns value stored in filepos, which keeps track of the current position in the...">GetFilePosition</a>(), token.<a class="code" href="classNxsToken_ae0fb11bf350d907295447864afa714ec.html#ae0fb11bf350d907295447864afa714ec" title="Returns value stored in `fileline&amp;#39;, which keeps track of the current line in...">GetFileLine</a>(), token.<a class="code" href="classNxsToken_a7272fd1469fa6424086a95ec4f92eab0.html#a7272fd1469fa6424086a95ec4f92eab0" title="Returns value stored in `filecol&amp;#39;, which keeps track of the current column in...">GetFileColumn</a>());
<a name="l04138"></a>04138                         }
<a name="l04139"></a>04139                     indOfTaxInMemory = numOfTaxInMemory - 1;
<a name="l04140"></a>04140                     }
<a name="l04141"></a>04141                 }
<a name="l04142"></a>04142             <span class="keywordflow">else</span>
<a name="l04143"></a>04143                 {
<a name="l04144"></a>04144                 indOfTaxInMemory = indOfTaxInCommand;
<a name="l04145"></a>04145                 nameStr &lt;&lt; (indOfTaxInMemory + 1);
<a name="l04146"></a>04146                 }
<a name="l04147"></a>04147             <span class="keywordflow">if</span> (page == 0)
<a name="l04148"></a>04148                 {
<a name="l04149"></a>04149                 <span class="keywordflow">if</span> (isContinuous)
<a name="l04150"></a>04150                     {
<a name="l04151"></a>04151                     NCL_ASSERT(indOfTaxInMemory &lt; continuousMatrix.size());
<a name="l04152"></a>04152                     continuousMatrix[indOfTaxInMemory] = emptyContRow;
<a name="l04153"></a>04153                     }
<a name="l04154"></a>04154                 <span class="keywordflow">else</span>
<a name="l04155"></a>04155                     {
<a name="l04156"></a>04156                     NCL_ASSERT(indOfTaxInMemory &lt; discreteMatrix.size());
<a name="l04157"></a>04157                     discreteMatrix[indOfTaxInMemory] = emptyDiscRow;
<a name="l04158"></a>04158                     }
<a name="l04159"></a>04159                 <span class="keywordflow">if</span> (toInMem[indOfTaxInCommand] != UINT_MAX)
<a name="l04160"></a>04160                     {
<a name="l04161"></a>04161                     errormsg &lt;&lt; <span class="stringliteral">&quot;Characters for taxon \&quot;&quot;</span> &lt;&lt; nameStr &lt;&lt; <span class="stringliteral">&quot;\&quot; (number &quot;</span> &lt;&lt; indOfTaxInMemory + 1 &lt;&lt; <span class="stringliteral">&quot;and \&quot;&quot;</span> &lt;&lt; taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_ae172f21958353f1be42371f0cad7061d.html#ae172f21958353f1be42371f0cad7061d">GetTaxonLabel</a>(indOfTaxInMemory) &lt;&lt; <span class="stringliteral">&quot;\&quot; according to the taxa block) have already been stored&quot;</span>;
<a name="l04162"></a>04162                     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l04163"></a>04163                     }
<a name="l04164"></a>04164                 toInMem[indOfTaxInCommand] = indOfTaxInMemory;
<a name="l04165"></a>04165                 }
<a name="l04166"></a>04166             <span class="keywordflow">else</span>
<a name="l04167"></a>04167                 {
<a name="l04168"></a>04168                 <span class="keywordflow">if</span> (toInMem[indOfTaxInCommand] != indOfTaxInMemory)
<a name="l04169"></a>04169                     {
<a name="l04170"></a>04170                     errormsg &lt;&lt; <span class="stringliteral">&quot;Ordering of taxa must be identical to that in first interleave page. Taxon \&quot;&quot;</span> &lt;&lt; nameStr &lt;&lt; <span class="stringliteral">&quot;\&quot; was not expected.&quot;</span>;
<a name="l04171"></a>04171                     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l04172"></a>04172                     }
<a name="l04173"></a>04173                 }
<a name="l04174"></a>04174 
<a name="l04175"></a>04175             <span class="keywordflow">if</span> (firstChar &gt; 0 &amp;&amp; nCharsRead[indOfTaxInCommand] &gt;= firstChar)
<a name="l04176"></a>04176                 {
<a name="l04177"></a>04177                 errormsg &lt;&lt; <span class="stringliteral">&quot;Data for this taxon (&quot;</span> &lt;&lt; nameStr &lt;&lt; <span class="stringliteral">&quot;) have already been saved&quot;</span>;
<a name="l04178"></a>04178                 <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l04179"></a>04179                 }
<a name="l04180"></a>04180             <span class="keywordflow">if</span> (isContinuous)
<a name="l04181"></a>04181                 {
<a name="l04182"></a>04182                 contRowPtr = &amp;continuousMatrix[indOfTaxInMemory];
<a name="l04183"></a>04183                 <span class="keywordflow">if</span> (ftDiscRowPtr == NULL)
<a name="l04184"></a>04184                     ftContRowPtr = contRowPtr;
<a name="l04185"></a>04185                 }
<a name="l04186"></a>04186             <span class="keywordflow">else</span>
<a name="l04187"></a>04187                 {
<a name="l04188"></a>04188                 discRowPtr = &amp;discreteMatrix[indOfTaxInMemory];
<a name="l04189"></a>04189                 <span class="keywordflow">if</span> (ftDiscRowPtr == NULL)
<a name="l04190"></a>04190                     ftDiscRowPtr = discRowPtr;
<a name="l04191"></a>04191                 }
<a name="l04192"></a>04192 
<a name="l04193"></a>04193             <span class="comment">//******************************************************</span>
<a name="l04194"></a>04194             <span class="comment">//******** Beginning of loop through characters ********</span>
<a name="l04195"></a>04195             <span class="comment">//******************************************************</span>
<a name="l04196"></a>04196             <span class="keywordtype">bool</span> atEOL = <span class="keyword">false</span>;
<a name="l04197"></a>04197             <span class="keywordflow">for</span> (currChar = firstChar; currChar &lt; lastChar; currChar++)
<a name="l04198"></a>04198                 {
<a name="l04199"></a>04199                 <span class="keywordflow">if</span> (checkingSignals)
<a name="l04200"></a>04200                     {
<a name="l04201"></a>04201                     <span class="keywordflow">if</span> (numCharsSinceLastSignalCheck &gt;= MAX_NUM_CHARS_BETWEEN_SIGNAL_CHECKS)
<a name="l04202"></a>04202                         {
<a name="l04203"></a>04203                         <span class="keywordflow">if</span> (<a class="code" href="classNxsReader_a35e901783be459c60ced0e39e25a3ed5.html#a35e901783be459c60ced0e39e25a3ed5" title="Usually used internally when signal catching is enabled.">NxsReader::getNumSignalIntsCaught</a>() != numSigInts)
<a name="l04204"></a>04204                             {
<a name="l04205"></a>04205                             <span class="keywordflow">if</span> (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>)
<a name="l04206"></a>04206                                 continuousMatrix.clear();
<a name="l04207"></a>04207                             <span class="keywordflow">else</span>
<a name="l04208"></a>04208                                 discreteMatrix.clear();
<a name="l04209"></a>04209                             <span class="keywordflow">throw</span> NxsSignalCanceledParseException(<span class="stringliteral">&quot;Reading Characters Block&quot;</span>);
<a name="l04210"></a>04210                             }
<a name="l04211"></a>04211                         numCharsSinceLastSignalCheck = 0;
<a name="l04212"></a>04212                         }
<a name="l04213"></a>04213                     <span class="keywordflow">else</span>
<a name="l04214"></a>04214                         numCharsSinceLastSignalCheck++;
<a name="l04215"></a>04215                     }
<a name="l04216"></a>04216 
<a name="l04217"></a>04217                 <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * currMapper =  GetMutableDatatypeMapperForChar(currChar);
<a name="l04218"></a>04218                 <span class="comment">// atEOL will be false only if a newline character is encountered before character j processed</span>
<a name="l04219"></a>04219                 <span class="keywordflow">if</span> (continuousData)
<a name="l04220"></a>04220                     atEOL = HandleNextContinuousState(token, indOfTaxInMemory, currChar, *contRowPtr, nameStr);
<a name="l04221"></a>04221                 <span class="keywordflow">else</span>
<a name="l04222"></a>04222                     {
<a name="l04223"></a>04223                     NCL_ASSERT(currMapper);
<a name="l04224"></a>04224                     <span class="keywordflow">if</span> (tokens)
<a name="l04225"></a>04225                         atEOL = <a class="code" href="classNxsCharactersBlock_abf0d355d3a40d6ce27d91b6a8c1ca88f.html#abf0d355d3a40d6ce27d91b6a8c1ca88f" title="Called from HandleNextState to read in the next state when TOKENS was specified.">HandleNextTokenState</a>(token, indOfTaxInMemory, currChar, *discRowPtr, *currMapper, ftDiscRowPtr, nameStr);
<a name="l04226"></a>04226                     <span class="keywordflow">else</span>
<a name="l04227"></a>04227                         atEOL = HandleNextDiscreteState(token, indOfTaxInMemory, currChar, *discRowPtr, *currMapper, ftDiscRowPtr, nameStr);
<a name="l04228"></a>04228                     }
<a name="l04229"></a>04229                 <span class="keywordflow">if</span> (interleaving &amp;&amp; !atEOL)
<a name="l04230"></a>04230                     {
<a name="l04231"></a>04231                     <span class="keywordflow">if</span> (lastChar &lt; nChar &amp;&amp; currChar != lastChar)
<a name="l04232"></a>04232                         {
<a name="l04233"></a>04233                         errormsg &lt;&lt; <span class="stringliteral">&quot;Each line within an interleave page must comprise the same number of characters.  Error reading taxon \&quot;&quot;</span> &lt;&lt; nameStr &lt;&lt; <span class="charliteral">&#39;\&quot;&#39;</span>;
<a name="l04234"></a>04234                         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l04235"></a>04235                         }
<a name="l04236"></a>04236 
<a name="l04237"></a>04237                     <span class="comment">// currChar should be firstChar in next go around</span>
<a name="l04238"></a>04238                     nextFirst = currChar;
<a name="l04239"></a>04239 
<a name="l04240"></a>04240                     <span class="comment">// Set lastChar to currChar so that we can check to make sure the remaining lines</span>
<a name="l04241"></a>04241                     <span class="comment">// in this interleave page end at the same place</span>
<a name="l04242"></a>04242                     lastChar = currChar;
<a name="l04243"></a>04243                     }
<a name="l04244"></a>04244                 }
<a name="l04245"></a>04245             <span class="keywordflow">if</span> (lastChar &gt; 0)
<a name="l04246"></a>04246                 nCharsRead[indOfTaxInCommand] = lastChar - 1;
<a name="l04247"></a>04247             <span class="keywordflow">if</span> (lastChar &lt; nChar &amp;&amp; indOfTaxInCommand &gt; 0)
<a name="l04248"></a>04248                 {
<a name="l04249"></a>04249                 token.<a class="code" href="classNxsToken_afa5232738ca19e069173e8befe75e730.html#afa5232738ca19e069173e8befe75e730" title="Sets the bit specified in the variable `labileFlags&amp;#39;.">SetLabileFlagBit</a>(NxsToken::newlineIsToken);
<a name="l04250"></a>04250                 token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l04251"></a>04251                 <span class="keywordflow">if</span> (!token.<a class="code" href="classNxsToken_ad2671eb776f8f76ac946fd5b76e93c0a.html#ad2671eb776f8f76ac946fd5b76e93c0a" title="Returns true if and only if last call to GetNextToken encountered the newline character...">AtEOL</a>())
<a name="l04252"></a>04252                     {
<a name="l04253"></a>04253                     errormsg &lt;&lt; <span class="stringliteral">&quot;Each line within an interleave page must comprise the same number of characters\n. Expecting the end of a line, but found &quot;</span> &lt;&lt; token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>() &lt;&lt; <span class="stringliteral">&quot; when reading data for taxon \&quot;&quot;</span> &lt;&lt; nameStr &lt;&lt; <span class="charliteral">&#39;\&quot;&#39;</span>;
<a name="l04254"></a>04254                     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l04255"></a>04255                     }
<a name="l04256"></a>04256                 }
<a name="l04257"></a>04257             <span class="keywordflow">else</span>
<a name="l04258"></a>04258                 {
<a name="l04259"></a>04259                 <span class="keyword">const</span> <span class="keywordtype">char</span> nextch = token.PeekAtNextChar();
<a name="l04260"></a>04260                 <span class="keywordflow">if</span> (indOfTaxInCommand &gt; 0 &amp;&amp; (!atEOL) &amp;&amp; (strchr(<span class="stringliteral">&quot;;[\n\r \t&quot;</span>, nextch) == NULL) &amp;&amp; nexusReader)
<a name="l04261"></a>04261                     {
<a name="l04262"></a>04262                     errormsg &lt;&lt; <span class="stringliteral">&quot;Expecting a whitespace character at the end of the characters for taxon \&quot;&quot;</span>&lt;&lt; nameStr &lt;&lt; <span class="stringliteral">&quot;\&quot; but found &quot;</span> &lt;&lt; nextch;
<a name="l04263"></a>04263                     nexusReader-&gt;<a class="code" href="classNxsReader_aa81b33d57a4c5ddac0d5ccbf81df9c5b.html#aa81b33d57a4c5ddac0d5ccbf81df9c5b" title="Used internally as a more convenient way of calling NexusWarn.">NexusWarnToken</a>(errormsg, <a class="code" href="classNxsReader_a409e01dc0baecef7ed471879c0692978.html#a409e01dc0baecef7ed471879c0692978a169bf0d8bc84d8d34258db0ec7fe1c4a">NxsReader::UNCOMMON_SYNTAX_WARNING</a>, token);
<a name="l04264"></a>04264                     errormsg.<a class="code" href="classNxsString_abbf904c772d9776139dcae602c9fd06b.html#abbf904c772d9776139dcae602c9fd06b" title="Most containers in the standard template library can be completely erased using the...">clear</a>();
<a name="l04265"></a>04265                     }
<a name="l04266"></a>04266                 }
<a name="l04267"></a>04267             }
<a name="l04268"></a>04268         firstChar = nextFirst;
<a name="l04269"></a>04269         lastChar = nChar;
<a name="l04270"></a>04270         taxaBlockNeedsLabels = <span class="keyword">false</span>; <span class="comment">/* taxaBlockNeedsLabels can only be true on the first page */</span>
<a name="l04271"></a>04271         }
<a name="l04272"></a>04272     }
<a name="l04273"></a>04273 
<a name="l04277"></a><a class="code" href="classNxsCharactersBlock_ad1e6cab805c606e17d5d57b2e5e36b50.html#ad1e6cab805c606e17d5d57b2e5e36b50">04277</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_ad1e6cab805c606e17d5d57b2e5e36b50.html#ad1e6cab805c606e17d5d57b2e5e36b50" title="Called from HandleMatrix function to read in a transposed matrix.">NxsCharactersBlock::HandleTransposedMatrix</a>(
<a name="l04278"></a>04278   <a class="code" href="classNxsToken.html">NxsToken</a> &amp;token)  <span class="comment">/* the token used to read from in */</span>
<a name="l04279"></a>04279     {
<a name="l04280"></a>04280     NCL_ASSERT(taxa);
<a name="l04281"></a>04281     <span class="keywordtype">unsigned</span> currTaxon = 0;
<a name="l04282"></a>04282     <span class="keywordtype">unsigned</span> firstTaxon = 0;
<a name="l04283"></a>04283     <span class="keywordtype">unsigned</span> lastTaxon = nTaxWithData;
<a name="l04284"></a>04284     <span class="keywordtype">unsigned</span> nextFirst = 0;
<a name="l04285"></a>04285     <span class="keywordtype">unsigned</span> page = 0;
<a name="l04286"></a>04286     <span class="keyword">const</span> <span class="keywordtype">bool</span> continuousData =  (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>);
<a name="l04287"></a>04287     <span class="keywordtype">unsigned</span> indOfCharInCommand, indOfCharInMemory;
<a name="l04288"></a>04288     <span class="keyword">const</span> <span class="keywordtype">bool</span> isContinuous = (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>);
<a name="l04289"></a>04289 
<a name="l04290"></a>04290     <span class="keywordflow">if</span> (isContinuous)
<a name="l04291"></a>04291         {
<a name="l04292"></a>04292         ContinuousCharRow emptyContRow(nChar);
<a name="l04293"></a>04293         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; nTaxWithData; ++ i)
<a name="l04294"></a>04294             continuousMatrix[i] = emptyContRow;
<a name="l04295"></a>04295         }
<a name="l04296"></a>04296     <span class="keywordflow">else</span>
<a name="l04297"></a>04297         {
<a name="l04298"></a>04298         NxsDiscreteStateRow emptyDiscRow(nChar, NXS_INVALID_STATE_CODE);
<a name="l04299"></a>04299         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; nTaxWithData; ++ i)
<a name="l04300"></a>04300             discreteMatrix[i] = emptyDiscRow;
<a name="l04301"></a>04301         }
<a name="l04302"></a>04302     vector&lt;unsigned&gt; toInMem(nChar, UINT_MAX);
<a name="l04303"></a>04303     vector&lt;unsigned&gt; nTaxRead(nChar, 0);
<a name="l04304"></a>04304     <span class="keywordtype">bool</span> needsCharLabels = indToCharLabel.empty();
<a name="l04305"></a>04305     <span class="keywordflow">for</span> (;; page++)
<a name="l04306"></a>04306         {
<a name="l04307"></a>04307         <span class="keywordflow">for</span> (indOfCharInCommand = 0; indOfCharInCommand &lt; nChar; indOfCharInCommand++)
<a name="l04308"></a>04308             {
<a name="l04309"></a>04309             <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> rawToken;
<a name="l04310"></a>04310             <span class="keywordflow">if</span> (labels)
<a name="l04311"></a>04311                 {
<a name="l04312"></a>04312                 token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l04313"></a>04313                 <span class="keywordflow">if</span> (needsCharLabels)
<a name="l04314"></a>04314                     {
<a name="l04315"></a>04315                     rawToken = token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>();
<a name="l04316"></a>04316                     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> s = rawToken;
<a name="l04317"></a>04317                     s.ToUpper();
<a name="l04318"></a>04318                     <span class="keywordflow">if</span> (ucCharLabelToIndex.count(s) &gt; 0)
<a name="l04319"></a>04319                         {
<a name="l04320"></a>04320                         errormsg &lt;&lt; <span class="stringliteral">&quot;Data for this character (&quot;</span> &lt;&lt; token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>() &lt;&lt; <span class="stringliteral">&quot;) has already been saved&quot;</span>;
<a name="l04321"></a>04321                         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token.<a class="code" href="classNxsToken_a17e5caf91acc756c23159f76f8b2d0fd.html#a17e5caf91acc756c23159f76f8b2d0fd" title="Returns value stored in filepos, which keeps track of the current position in the...">GetFilePosition</a>(), token.<a class="code" href="classNxsToken_ae0fb11bf350d907295447864afa714ec.html#ae0fb11bf350d907295447864afa714ec" title="Returns value stored in `fileline&amp;#39;, which keeps track of the current line in...">GetFileLine</a>(), token.<a class="code" href="classNxsToken_a7272fd1469fa6424086a95ec4f92eab0.html#a7272fd1469fa6424086a95ec4f92eab0" title="Returns value stored in `filecol&amp;#39;, which keeps track of the current column in...">GetFileColumn</a>());
<a name="l04322"></a>04322                         }
<a name="l04323"></a>04323                     ucCharLabelToIndex[s] = indOfCharInCommand;
<a name="l04324"></a>04324                     indToCharLabel[indOfCharInCommand] = rawToken;
<a name="l04325"></a>04325                     indOfCharInMemory = indOfCharInCommand;
<a name="l04326"></a>04326                     }
<a name="l04327"></a>04327                 <span class="keywordflow">else</span> <span class="comment">// either not first interleaved page or character labels not previously defined</span>
<a name="l04328"></a>04328                     {
<a name="l04329"></a>04329                     rawToken = token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>();
<a name="l04330"></a>04330                     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> s = rawToken;
<a name="l04331"></a>04331                     s.ToUpper();
<a name="l04332"></a>04332                     LabelToIndexMap::const_iterator iter = ucCharLabelToIndex.find(s);
<a name="l04333"></a>04333                     <span class="keywordflow">if</span> (iter == ucCharLabelToIndex.end())
<a name="l04334"></a>04334                         {
<a name="l04335"></a>04335                         errormsg &lt;&lt; <span class="stringliteral">&quot;Could not find character named &quot;</span> &lt;&lt; token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>() &lt;&lt;  <span class="stringliteral">&quot; among stored character labels&quot;</span>;
<a name="l04336"></a>04336                         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token.<a class="code" href="classNxsToken_a17e5caf91acc756c23159f76f8b2d0fd.html#a17e5caf91acc756c23159f76f8b2d0fd" title="Returns value stored in filepos, which keeps track of the current position in the...">GetFilePosition</a>(), token.<a class="code" href="classNxsToken_ae0fb11bf350d907295447864afa714ec.html#ae0fb11bf350d907295447864afa714ec" title="Returns value stored in `fileline&amp;#39;, which keeps track of the current line in...">GetFileLine</a>(), token.<a class="code" href="classNxsToken_a7272fd1469fa6424086a95ec4f92eab0.html#a7272fd1469fa6424086a95ec4f92eab0" title="Returns value stored in `filecol&amp;#39;, which keeps track of the current column in...">GetFileColumn</a>());
<a name="l04337"></a>04337                         }
<a name="l04338"></a>04338                     indOfCharInMemory = iter-&gt;second;
<a name="l04339"></a>04339                     }
<a name="l04340"></a>04340                 }
<a name="l04341"></a>04341             <span class="keywordflow">else</span>
<a name="l04342"></a>04342                 indOfCharInMemory = indOfCharInCommand;
<a name="l04343"></a>04343 
<a name="l04344"></a>04344             <span class="keywordflow">if</span> (page == 0)
<a name="l04345"></a>04345                 {
<a name="l04346"></a>04346                 <span class="keywordflow">if</span> (toInMem[indOfCharInCommand] != UINT_MAX)
<a name="l04347"></a>04347                     {
<a name="l04348"></a>04348                     errormsg &lt;&lt; <span class="stringliteral">&quot;States for character &quot;</span> &lt;&lt; indOfCharInCommand;
<a name="l04349"></a>04349                     <span class="keywordflow">if</span> (!rawToken.empty())
<a name="l04350"></a>04350                         errormsg &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; rawToken &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>;
<a name="l04351"></a>04351                     errormsg &lt;&lt; <span class="stringliteral">&quot;have already been stored&quot;</span>;
<a name="l04352"></a>04352                     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l04353"></a>04353                     }
<a name="l04354"></a>04354                 toInMem[indOfCharInCommand] = indOfCharInMemory;
<a name="l04355"></a>04355                 }
<a name="l04356"></a>04356             <span class="keywordflow">else</span>
<a name="l04357"></a>04357                 {
<a name="l04358"></a>04358                 <span class="keywordflow">if</span> (toInMem[indOfCharInCommand] != indOfCharInMemory)
<a name="l04359"></a>04359                     {
<a name="l04360"></a>04360                     errormsg &lt;&lt; <span class="stringliteral">&quot;The order of characters must be in the same order in each page of the interleaved matrix. Character &quot;</span> &lt;&lt; rawToken &lt;&lt; <span class="stringliteral">&quot; was unexpected.&quot;</span>;
<a name="l04361"></a>04361                     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l04362"></a>04362                     }
<a name="l04363"></a>04363                 }
<a name="l04364"></a>04364             <span class="keywordflow">if</span> (firstTaxon &gt; 0 &amp;&amp; nTaxRead[indOfCharInCommand] &gt;= firstTaxon)
<a name="l04365"></a>04365                 {
<a name="l04366"></a>04366                 errormsg &lt;&lt; <span class="stringliteral">&quot;Data for this character &quot;</span>;
<a name="l04367"></a>04367                 <span class="keywordflow">if</span> (!rawToken.empty())
<a name="l04368"></a>04368                     errormsg &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; rawToken &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>;
<a name="l04369"></a>04369                 errormsg &lt;&lt; <span class="stringliteral">&quot;has already been saved&quot;</span>;
<a name="l04370"></a>04370                 <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l04371"></a>04371                 }
<a name="l04372"></a>04372 
<a name="l04373"></a>04373             <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * currMapper =  GetMutableDatatypeMapperForChar(indOfCharInMemory);
<a name="l04374"></a>04374 
<a name="l04375"></a>04375             <span class="keywordflow">for</span> (currTaxon = firstTaxon; currTaxon &lt; lastTaxon; currTaxon++)
<a name="l04376"></a>04376                 {
<a name="l04377"></a>04377                 <span class="keywordtype">bool</span> atEOL = <span class="keyword">false</span>;
<a name="l04378"></a>04378                 <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> nameStr;
<a name="l04379"></a>04379                 nameStr &lt;&lt; 1+currTaxon;
<a name="l04380"></a>04380                 <span class="keywordflow">if</span> (continuousData)
<a name="l04381"></a>04381                     {
<a name="l04382"></a>04382                     ContinuousCharRow *contRowPtr = &amp;continuousMatrix[currTaxon];
<a name="l04383"></a>04383                     atEOL = HandleNextContinuousState(token, currTaxon, indOfCharInMemory, *contRowPtr, nameStr);
<a name="l04384"></a>04384                     }
<a name="l04385"></a>04385                 <span class="keywordflow">else</span>
<a name="l04386"></a>04386                     {
<a name="l04387"></a>04387                     NxsDiscreteStateRow *discRowPtr = &amp;discreteMatrix[currTaxon];
<a name="l04388"></a>04388                     <span class="keywordflow">if</span> (tokens)
<a name="l04389"></a>04389                         atEOL = <a class="code" href="classNxsCharactersBlock_abf0d355d3a40d6ce27d91b6a8c1ca88f.html#abf0d355d3a40d6ce27d91b6a8c1ca88f" title="Called from HandleNextState to read in the next state when TOKENS was specified.">HandleNextTokenState</a>(token,  currTaxon, indOfCharInMemory, *discRowPtr, *currMapper, NULL, nameStr);
<a name="l04390"></a>04390                     <span class="keywordflow">else</span>
<a name="l04391"></a>04391                         atEOL = HandleNextDiscreteState(token, currTaxon, indOfCharInMemory, *discRowPtr, *currMapper, NULL, nameStr);
<a name="l04392"></a>04392                     }
<a name="l04393"></a>04393                 <span class="keywordflow">if</span> (interleaving &amp;&amp; !atEOL)
<a name="l04394"></a>04394                     {
<a name="l04395"></a>04395                     <span class="keywordflow">if</span> (lastTaxon &lt; nTaxWithData &amp;&amp; currTaxon != lastTaxon)
<a name="l04396"></a>04396                         <a class="code" href="classNxsBlock_a9106779865a661477259f3d84edb36a5.html#a9106779865a661477259f3d84edb36a5" title="throws a NxsException with the token info for `token` `expected` should fill in the...">GenerateNxsException</a>(token, <span class="stringliteral">&quot;Each line within an interleave page must comprise the same number of taxa&quot;</span>);
<a name="l04397"></a>04397 
<a name="l04398"></a>04398                     <span class="comment">// currTaxon should be firstChar in next go around</span>
<a name="l04399"></a>04399                     nextFirst = currTaxon;
<a name="l04400"></a>04400 
<a name="l04401"></a>04401                     <span class="comment">// Set lastTaxon to currTaxon so that we can check to make sure the</span>
<a name="l04402"></a>04402                     <span class="comment">// remaining lines in this interleave page end at the same place</span>
<a name="l04403"></a>04403                     lastTaxon = currTaxon;
<a name="l04404"></a>04404                     }
<a name="l04405"></a>04405                 }
<a name="l04406"></a>04406             <span class="keywordflow">if</span> (currTaxon &gt; 0)
<a name="l04407"></a>04407                 nTaxRead[indOfCharInCommand] = currTaxon - 1;
<a name="l04408"></a>04408             <span class="keywordflow">if</span> (lastTaxon &lt; nTaxWithData &amp;&amp; indOfCharInCommand &gt; 0)
<a name="l04409"></a>04409                 {
<a name="l04410"></a>04410                 token.<a class="code" href="classNxsToken_afa5232738ca19e069173e8befe75e730.html#afa5232738ca19e069173e8befe75e730" title="Sets the bit specified in the variable `labileFlags&amp;#39;.">SetLabileFlagBit</a>(NxsToken::newlineIsToken);
<a name="l04411"></a>04411                 token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l04412"></a>04412                 <span class="keywordflow">if</span> (!token.<a class="code" href="classNxsToken_ad2671eb776f8f76ac946fd5b76e93c0a.html#ad2671eb776f8f76ac946fd5b76e93c0a" title="Returns true if and only if last call to GetNextToken encountered the newline character...">AtEOL</a>())
<a name="l04413"></a>04413                     {
<a name="l04414"></a>04414                     errormsg = <span class="stringliteral">&quot;Each line within an interleave page must comprise the same number of taxa\n.&quot;</span>;
<a name="l04415"></a>04415                     errormsg &lt;&lt; <span class="stringliteral">&quot;Expecting the end of a line, but found &quot;</span> &lt;&lt; token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>();
<a name="l04416"></a>04416                     <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l04417"></a>04417                     }
<a name="l04418"></a>04418                 }
<a name="l04419"></a>04419             }
<a name="l04420"></a>04420         firstTaxon = nextFirst;
<a name="l04421"></a>04421         lastTaxon = nTaxWithData;
<a name="l04422"></a>04422         <span class="keywordflow">if</span> (currTaxon == nTaxWithData)
<a name="l04423"></a>04423             <span class="keywordflow">break</span>;
<a name="l04424"></a>04424         needsCharLabels = <span class="keyword">false</span>;
<a name="l04425"></a>04425         }
<a name="l04426"></a>04426     }
<a name="l04427"></a>04427 
<a name="l04432"></a><a class="code" href="classNxsCharactersBlock_ac3182cda60e8ecb7bf6fbef6abe187ee.html#ac3182cda60e8ecb7bf6fbef6abe187ee">04432</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_ac3182cda60e8ecb7bf6fbef6abe187ee.html#ac3182cda60e8ecb7bf6fbef6abe187ee" title="Called when MATRIX command needs to be parsed from within the CHARACTERS block.">NxsCharactersBlock::HandleMatrix</a>(
<a name="l04433"></a>04433   <a class="code" href="classNxsToken.html">NxsToken</a> &amp;token)  <span class="comment">/* the token used to read from `in&#39; */</span>
<a name="l04434"></a>04434     {
<a name="l04435"></a>04435     <span class="keyword">const</span> NxsPartition dtParts;
<a name="l04436"></a>04436     <span class="keyword">const</span> std::vector&lt;DataTypesEnum&gt; dtv;
<a name="l04437"></a>04437     <span class="keywordflow">if</span> (datatypeMapperVec.empty())
<a name="l04438"></a>04438         CreateDatatypeMapperObjects(dtParts, dtv);
<a name="l04439"></a>04439     <span class="keywordflow">if</span> (taxa == NULL)
<a name="l04440"></a>04440         AssureTaxaBlock(<span class="keyword">false</span>, token, <span class="stringliteral">&quot;Matrix&quot;</span>);
<a name="l04441"></a>04441 
<a name="l04442"></a>04442     <span class="keywordflow">if</span> (tokens &amp;&amp; <a class="code" href="classNxsCharactersBlock_a53ea45949d5536c5068d98ca2e586235.html#a53ea45949d5536c5068d98ca2e586235" title="Returns value of `datatype&amp;#39; from the datatype mapper.">GetDataType</a>() == standard)
<a name="l04443"></a>04443         {
<a name="l04444"></a>04444         <span class="comment">/* we can run into trouble here because the number of states can be larger than the</span>
<a name="l04445"></a>04445 <span class="comment">        symbols list in the NxsDiscreteDatatypeMapper object (because CharState labels can be</span>
<a name="l04446"></a>04446 <span class="comment">        used in a matrix, and symbols don&#39;t have to be introduced for each character).</span>
<a name="l04447"></a>04447 <span class="comment"></span>
<a name="l04448"></a>04448 <span class="comment">        We deal with that here, by introducing \0 symbols</span>
<a name="l04449"></a>04449 <span class="comment">        */</span>
<a name="l04450"></a>04450         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nStatesWSymbols = (<span class="keyword">const</span> unsigned)symbols.length();
<a name="l04451"></a>04451         <span class="keywordtype">unsigned</span> nStatesTotal = nStatesWSymbols;
<a name="l04452"></a>04452         <span class="keywordflow">for</span> (NxsStringVectorMap::const_iterator cib = this-&gt;charStates.begin(); cib != this-&gt;charStates.end(); ++cib)
<a name="l04453"></a>04453             {
<a name="l04454"></a>04454             <span class="keyword">const</span> NxsStringVector &amp; stateLabelsVec = cib-&gt;second;
<a name="l04455"></a>04455             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ns = (unsigned)stateLabelsVec.size();
<a name="l04456"></a>04456             <span class="keywordflow">if</span> (ns &gt; nStatesTotal)
<a name="l04457"></a>04457                 nStatesTotal = ns;
<a name="l04458"></a>04458             }
<a name="l04459"></a>04459         <span class="keywordflow">if</span> (nStatesTotal &gt; nStatesWSymbols)
<a name="l04460"></a>04460             {
<a name="l04461"></a>04461             symbols.append(nStatesTotal-nStatesWSymbols, <span class="charliteral">&#39;\0&#39;</span>);
<a name="l04462"></a>04462             CreateDatatypeMapperObjects(dtParts, dtv);
<a name="l04463"></a>04463             }
<a name="l04464"></a>04464         }
<a name="l04465"></a>04465     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ntax = taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_a3e9b998d97ad05914bda0d616069c26f.html#a3e9b998d97ad05914bda0d616069c26f">GetNTax</a>();
<a name="l04466"></a>04466     <span class="keywordflow">if</span> (ntax == 0)
<a name="l04467"></a>04467         {
<a name="l04468"></a>04468         errormsg = <span class="stringliteral">&quot;Must precede &quot;</span>;
<a name="l04469"></a>04469         errormsg &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot; block with a TAXA block or specify NEWTAXA and NTAX in the DIMENSIONS command&quot;</span>;
<a name="l04470"></a>04470         <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token.<a class="code" href="classNxsToken_a17e5caf91acc756c23159f76f8b2d0fd.html#a17e5caf91acc756c23159f76f8b2d0fd" title="Returns value stored in filepos, which keeps track of the current position in the...">GetFilePosition</a>(), token.<a class="code" href="classNxsToken_ae0fb11bf350d907295447864afa714ec.html#ae0fb11bf350d907295447864afa714ec" title="Returns value stored in `fileline&amp;#39;, which keeps track of the current line in...">GetFileLine</a>(), token.<a class="code" href="classNxsToken_a7272fd1469fa6424086a95ec4f92eab0.html#a7272fd1469fa6424086a95ec4f92eab0" title="Returns value stored in `filecol&amp;#39;, which keeps track of the current column in...">GetFileColumn</a>());
<a name="l04471"></a>04471         }
<a name="l04472"></a>04472 
<a name="l04473"></a>04473     discreteMatrix.clear();
<a name="l04474"></a>04474     continuousMatrix.clear();
<a name="l04475"></a>04475 
<a name="l04476"></a>04476     <span class="keywordflow">if</span> (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>)
<a name="l04477"></a>04477         {
<a name="l04478"></a>04478         continuousMatrix.clear();
<a name="l04479"></a>04479         continuousMatrix.resize(ntax);
<a name="l04480"></a>04480         }
<a name="l04481"></a>04481     <span class="keywordflow">else</span>
<a name="l04482"></a>04482         {
<a name="l04483"></a>04483         discreteMatrix.clear();
<a name="l04484"></a>04484         discreteMatrix.resize(ntax);
<a name="l04485"></a>04485         }
<a name="l04486"></a>04486     <span class="keywordflow">if</span> (IsMixedType())
<a name="l04487"></a>04487         {
<a name="l04488"></a>04488         <span class="keywordflow">if</span> (transposing)
<a name="l04489"></a>04489             <span class="keywordflow">throw</span> <a class="code" href="classNxsUnimplementedException.html" title="Thrown when an unimplemented method is called.">NxsUnimplementedException</a>(<span class="stringliteral">&quot;Reading of transposed, mixed datatype matrices will probably never be supported by NCL&quot;</span>);
<a name="l04490"></a>04490         <span class="comment">/*  HandleMixedDatatypeMatrix(token); */</span>
<a name="l04491"></a>04491         }
<a name="l04492"></a>04492     <span class="keywordflow">if</span> (transposing)
<a name="l04493"></a>04493         <a class="code" href="classNxsCharactersBlock_ad1e6cab805c606e17d5d57b2e5e36b50.html#ad1e6cab805c606e17d5d57b2e5e36b50" title="Called from HandleMatrix function to read in a transposed matrix.">HandleTransposedMatrix</a>(token);
<a name="l04494"></a>04494     <span class="keywordflow">else</span>
<a name="l04495"></a>04495         <a class="code" href="classNxsCharactersBlock_afa4e2954e61ccdfaafda0609d294d729.html#afa4e2954e61ccdfaafda0609d294d729" title="Called from HandleMatrix function to read in a standard (i.e., non-transposed) matrix...">HandleStdMatrix</a>(token);
<a name="l04496"></a>04496     DemandEndSemicolon(token, <span class="stringliteral">&quot;MATRIX&quot;</span>);
<a name="l04497"></a>04497     <span class="keywordflow">if</span> (assumptionsBlock)
<a name="l04498"></a>04498         assumptionsBlock-&gt;SetCallback(<span class="keyword">this</span>);
<a name="l04499"></a>04499     <span class="keywordflow">if</span> (convertAugmentedToMixed)
<a name="l04500"></a>04500         <a class="code" href="classNxsCharactersBlock_a93339ad34ae1c95b7fc91b9a02ab9d5a.html#a93339ad34ae1c95b7fc91b9a02ab9d5a" title="If you say FORMAT DATATYPE=DNA SYMBOLS=&amp;quot;01&amp;quot; ; then the valid symbols become...">AugmentedSymbolsToMixed</a>();
<a name="l04501"></a>04501     }
<a name="l04502"></a>04502 
<a name="l04509"></a><a class="code" href="classNxsCharactersBlock_ae52c5cc8b8e1a8473be02c9a1ec63dfc.html#ae52c5cc8b8e1a8473be02c9a1ec63dfc">04509</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_ae52c5cc8b8e1a8473be02c9a1ec63dfc.html#ae52c5cc8b8e1a8473be02c9a1ec63dfc" title="Called when STATELABELS command needs to be parsed from within the DIMENSIONS block...">NxsCharactersBlock::HandleStatelabels</a>(
<a name="l04510"></a>04510   <a class="code" href="classNxsToken.html">NxsToken</a> &amp;token)  <span class="comment">/* the token used to read from `in&#39; */</span>
<a name="l04511"></a>04511     {
<a name="l04512"></a>04512     <span class="keywordflow">if</span> (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">continuous</a>)
<a name="l04513"></a>04513         <a class="code" href="classNxsBlock_a9106779865a661477259f3d84edb36a5.html#a9106779865a661477259f3d84edb36a5" title="throws a NxsException with the token info for `token` `expected` should fill in the...">GenerateNxsException</a>(token, <span class="stringliteral">&quot;STATELABELS cannot be specified when the datatype is continuous&quot;</span>);
<a name="l04514"></a>04514     charStates.clear();
<a name="l04515"></a>04515     <span class="keywordflow">for</span> (;;)
<a name="l04516"></a>04516         {
<a name="l04517"></a>04517         token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l04518"></a>04518         <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;;&quot;</span>))
<a name="l04519"></a>04519             <span class="keywordflow">break</span>;
<a name="l04520"></a>04520 
<a name="l04521"></a>04521         <span class="keywordtype">int</span> n = atoi(token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>().c_str());
<a name="l04522"></a>04522         <span class="keywordflow">if</span> (n &lt; 1 || n &gt; (<span class="keywordtype">int</span>)nChar)
<a name="l04523"></a>04523             {
<a name="l04524"></a>04524             errormsg = <span class="stringliteral">&quot;Invalid character number (&quot;</span>;
<a name="l04525"></a>04525             errormsg &lt;&lt; token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>() &lt;&lt; <span class="stringliteral">&quot;) found in STATELABELS command (either out of range or not interpretable as an integer)&quot;</span>;
<a name="l04526"></a>04526             <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token.<a class="code" href="classNxsToken_a17e5caf91acc756c23159f76f8b2d0fd.html#a17e5caf91acc756c23159f76f8b2d0fd" title="Returns value stored in filepos, which keeps track of the current position in the...">GetFilePosition</a>(), token.<a class="code" href="classNxsToken_ae0fb11bf350d907295447864afa714ec.html#ae0fb11bf350d907295447864afa714ec" title="Returns value stored in `fileline&amp;#39;, which keeps track of the current line in...">GetFileLine</a>(), token.<a class="code" href="classNxsToken_a7272fd1469fa6424086a95ec4f92eab0.html#a7272fd1469fa6424086a95ec4f92eab0" title="Returns value stored in `filecol&amp;#39;, which keeps track of the current column in...">GetFileColumn</a>());
<a name="l04527"></a>04527             }
<a name="l04528"></a>04528         NxsStringVector &amp; v = charStates[n - 1];
<a name="l04529"></a>04529         <span class="keywordflow">for</span> (;;)
<a name="l04530"></a>04530             {
<a name="l04531"></a>04531             token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l04532"></a>04532             <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;;&quot;</span>) || token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;,&quot;</span>))
<a name="l04533"></a>04533                 <span class="keywordflow">break</span>;
<a name="l04534"></a>04534             v.push_back(token.<a class="code" href="classNxsToken_a83d7b2a9a2307a0aee8476b904c8145f.html#a83d7b2a9a2307a0aee8476b904c8145f" title="Returns the data member `token&amp;#39;.">GetToken</a>());
<a name="l04535"></a>04535             }
<a name="l04536"></a>04536         }
<a name="l04537"></a>04537     }
<a name="l04538"></a>04538 
<a name="l04544"></a><a class="code" href="classNxsCharactersBlock_af13ecbcad48d15bcade4eb44875644dd.html#af13ecbcad48d15bcade4eb44875644dd">04544</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_af13ecbcad48d15bcade4eb44875644dd.html#af13ecbcad48d15bcade4eb44875644dd" title="This function provides the ability to read everything following the block name (which...">NxsCharactersBlock::Read</a>(
<a name="l04545"></a>04545   <a class="code" href="classNxsToken.html">NxsToken</a> &amp;token)  <span class="comment">/* the token used to read from `in&#39; */</span>
<a name="l04546"></a>04546     {
<a name="l04547"></a>04547     isEmpty = <span class="keyword">false</span>;
<a name="l04548"></a>04548     isUserSupplied = <span class="keyword">true</span>;
<a name="l04549"></a>04549 
<a name="l04550"></a>04550     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> s;
<a name="l04551"></a>04551     s = <span class="stringliteral">&quot;BEGIN &quot;</span>;
<a name="l04552"></a>04552     s += id;
<a name="l04553"></a>04553     DemandEndSemicolon(token, s.c_str());
<a name="l04554"></a>04554     nTaxWithData = 0;
<a name="l04555"></a>04555 
<a name="l04556"></a>04556     <span class="keywordflow">for</span> (;;)
<a name="l04557"></a>04557         {
<a name="l04558"></a>04558         token.<a class="code" href="classNxsToken_a3346e398b3f6b5e8c7c3cebc49ae1c4b.html#a3346e398b3f6b5e8c7c3cebc49ae1c4b" title="Reads characters from in until a complete token has been read and stored in token...">GetNextToken</a>();
<a name="l04559"></a>04559         NxsBlock::NxsCommandResult res = <a class="code" href="classNxsBlock_af9c3fcff6324f4b220a1dd9ebcb1017a.html#af9c3fcff6324f4b220a1dd9ebcb1017a" title="Hook to consolidate the handling of COMMANDS that are common to all blocks (TITLE...">HandleBasicBlockCommands</a>(token);
<a name="l04560"></a>04560         <span class="keywordflow">if</span> (res == NxsBlock::NxsCommandResult(STOP_PARSING_BLOCK))
<a name="l04561"></a>04561             {
<a name="l04562"></a>04562             <span class="keywordflow">if</span> (discreteMatrix.empty() &amp;&amp; continuousMatrix.empty())
<a name="l04563"></a>04563                 {
<a name="l04564"></a>04564                 errormsg.<a class="code" href="classNxsString_abbf904c772d9776139dcae602c9fd06b.html#abbf904c772d9776139dcae602c9fd06b" title="Most containers in the standard template library can be completely erased using the...">clear</a>();
<a name="l04565"></a>04565                 errormsg &lt;&lt; <span class="stringliteral">&quot;\nA &quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot; block must contain a Matrix command&quot;</span>;
<a name="l04566"></a>04566                 <span class="keywordflow">throw</span> <a class="code" href="classNxsException.html" title="Exception class that conveys a message specific to the problem encountered.">NxsException</a>(errormsg, token);
<a name="l04567"></a>04567                 }
<a name="l04568"></a>04568             <span class="keywordflow">return</span>;
<a name="l04569"></a>04569             }
<a name="l04570"></a>04570         <span class="keywordflow">if</span> (res != NxsBlock::NxsCommandResult(HANDLED_COMMAND))
<a name="l04571"></a>04571             {
<a name="l04572"></a>04572             <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;DIMENSIONS&quot;</span>))
<a name="l04573"></a>04573                 <a class="code" href="classNxsCharactersBlock_a2403d3b7e8c91566a2bb39dc7807e33e.html#a2403d3b7e8c91566a2bb39dc7807e33e" title="Called when DIMENSIONS command needs to be parsed from within the CHARACTERS block...">HandleDimensions</a>(token, <span class="stringliteral">&quot;NEWTAXA&quot;</span>, <span class="stringliteral">&quot;NTAX&quot;</span>, <span class="stringliteral">&quot;NCHAR&quot;</span>);
<a name="l04574"></a>04574             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;FORMAT&quot;</span>))
<a name="l04575"></a>04575                 <a class="code" href="classNxsCharactersBlock_a8fc039e274e43180293b6f0741f5486f.html#a8fc039e274e43180293b6f0741f5486f" title="Called when FORMAT command needs to be parsed from within the DIMENSIONS block.">HandleFormat</a>(token);
<a name="l04576"></a>04576             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;ELIMINATE&quot;</span>))
<a name="l04577"></a>04577                 <a class="code" href="classNxsCharactersBlock_a051b9cfd99599fd8894c067274952d30.html#a051b9cfd99599fd8894c067274952d30" title="Called when ELIMINATE command needs to be parsed from within the CHARACTERS block...">HandleEliminate</a>(token);
<a name="l04578"></a>04578             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;TAXLABELS&quot;</span>))
<a name="l04579"></a>04579                 <a class="code" href="classNxsTaxaBlockSurrogate_ad899bacf59e0e049f7fdf9b9142f6bc2.html#ad899bacf59e0e049f7fdf9b9142f6bc2" title="Called when TAXLABELS command needs to be parsed from within the UNALIGNED block...">HandleTaxLabels</a>(token);
<a name="l04580"></a>04580             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;CHARSTATELABELS&quot;</span>))
<a name="l04581"></a>04581                 <a class="code" href="classNxsCharactersBlock_a28830ac9b39ade49fefafb2e7ba33a16.html#a28830ac9b39ade49fefafb2e7ba33a16" title="Called when CHARSTATELABELS command needs to be parsed from within the CHARACTERS...">HandleCharstatelabels</a>(token);
<a name="l04582"></a>04582             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;CHARLABELS&quot;</span>))
<a name="l04583"></a>04583                 <a class="code" href="classNxsCharactersBlock_a687f6d028e959d04e8662251b1946514.html#a687f6d028e959d04e8662251b1946514" title="Called when CHARLABELS command needs to be parsed from within the DIMENSIONS block...">HandleCharlabels</a>(token);
<a name="l04584"></a>04584             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;STATELABELS&quot;</span>))
<a name="l04585"></a>04585                 <a class="code" href="classNxsCharactersBlock_ae52c5cc8b8e1a8473be02c9a1ec63dfc.html#ae52c5cc8b8e1a8473be02c9a1ec63dfc" title="Called when STATELABELS command needs to be parsed from within the DIMENSIONS block...">HandleStatelabels</a>(token);
<a name="l04586"></a>04586             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token.<a class="code" href="classNxsToken_a3fd38838e685bffa670dbbaa5b047966.html#a3fd38838e685bffa670dbbaa5b047966" title="Returns true if token NxsString exactly equals `s&amp;#39;.">Equals</a>(<span class="stringliteral">&quot;MATRIX&quot;</span>))
<a name="l04587"></a>04587                 <a class="code" href="classNxsCharactersBlock_ac3182cda60e8ecb7bf6fbef6abe187ee.html#ac3182cda60e8ecb7bf6fbef6abe187ee" title="Called when MATRIX command needs to be parsed from within the CHARACTERS block.">HandleMatrix</a>(token);
<a name="l04588"></a>04588             <span class="keywordflow">else</span>
<a name="l04589"></a>04589                 SkipCommand(token);
<a name="l04590"></a>04590             }
<a name="l04591"></a>04591         }
<a name="l04592"></a>04592     }
<a name="l04593"></a>04593 
<a name="l04598"></a><a class="code" href="classNxsCharactersBlock_a245f48bc601c2f7c03b73f1f296bc3b2.html#a245f48bc601c2f7c03b73f1f296bc3b2">04598</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_a245f48bc601c2f7c03b73f1f296bc3b2.html#a245f48bc601c2f7c03b73f1f296bc3b2" title="This function outputs a brief report of the contents of this CHARACTERS block.">NxsCharactersBlock::Report</a>(
<a name="l04599"></a>04599   std::ostream &amp;out) NCL_COULD_BE_CONST  <span class="comment">/* the output stream to which to write the report */</span> <span class="comment">/*v2.1to2.2 1 */</span>
<a name="l04600"></a>04600     {
<a name="l04601"></a>04601     out &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot; block contains &quot;</span>;
<a name="l04602"></a>04602     <span class="keywordflow">if</span> (nTaxWithData == 0)
<a name="l04603"></a>04603         out &lt;&lt; <span class="stringliteral">&quot;no taxa&quot;</span>;
<a name="l04604"></a>04604     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nTaxWithData == 1)
<a name="l04605"></a>04605         out &lt;&lt; <span class="stringliteral">&quot;one taxon&quot;</span>;
<a name="l04606"></a>04606     <span class="keywordflow">else</span>
<a name="l04607"></a>04607         out &lt;&lt; nTaxWithData &lt;&lt; <span class="stringliteral">&quot; taxa&quot;</span>;
<a name="l04608"></a>04608     out &lt;&lt; <span class="stringliteral">&quot; and &quot;</span>;
<a name="l04609"></a>04609     <span class="keywordflow">if</span> (nChar == 0)
<a name="l04610"></a>04610         out &lt;&lt; <span class="stringliteral">&quot;no characters&quot;</span>;
<a name="l04611"></a>04611     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nChar == 1)
<a name="l04612"></a>04612         out &lt;&lt; <span class="stringliteral">&quot;one character&quot;</span>;
<a name="l04613"></a>04613     <span class="keywordflow">else</span>
<a name="l04614"></a>04614         out &lt;&lt; nChar &lt;&lt; <span class="stringliteral">&quot; characters&quot;</span>;
<a name="l04615"></a>04615     out &lt;&lt; endl;
<a name="l04616"></a>04616 
<a name="l04617"></a>04617     out &lt;&lt; <span class="stringliteral">&quot;  Data type is \&quot;&quot;</span> &lt;&lt; this-&gt;GetDatatypeName() &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span> &lt;&lt; endl;
<a name="l04618"></a>04618 
<a name="l04619"></a>04619     <span class="keywordflow">if</span> (respectingCase)
<a name="l04620"></a>04620         out &lt;&lt; <span class="stringliteral">&quot;  Respecting case&quot;</span> &lt;&lt; endl;
<a name="l04621"></a>04621     <span class="keywordflow">else</span>
<a name="l04622"></a>04622         out &lt;&lt; <span class="stringliteral">&quot;  Ignoring case&quot;</span> &lt;&lt; endl;
<a name="l04623"></a>04623 
<a name="l04624"></a>04624     <span class="keywordflow">if</span> (tokens)
<a name="l04625"></a>04625         out &lt;&lt; <span class="stringliteral">&quot;  Multicharacter tokens allowed in data matrix&quot;</span> &lt;&lt; endl;
<a name="l04626"></a>04626     <span class="keywordflow">else</span>
<a name="l04627"></a>04627         out &lt;&lt; <span class="stringliteral">&quot;  Data matrix entries are expected to be single symbols&quot;</span> &lt;&lt; endl;
<a name="l04628"></a>04628 
<a name="l04629"></a>04629     <span class="keywordflow">if</span> (labels &amp;&amp; transposing)
<a name="l04630"></a>04630         out &lt;&lt; <span class="stringliteral">&quot;  Character labels are expected on left side of matrix&quot;</span> &lt;&lt; endl;
<a name="l04631"></a>04631     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (labels &amp;&amp; !transposing)
<a name="l04632"></a>04632         out &lt;&lt; <span class="stringliteral">&quot;  Taxon labels are expected on left side of matrix&quot;</span> &lt;&lt; endl;
<a name="l04633"></a>04633     <span class="keywordflow">else</span>
<a name="l04634"></a>04634         out &lt;&lt; <span class="stringliteral">&quot;  No labels are expected on left side of matrix&quot;</span> &lt;&lt; endl;
<a name="l04635"></a>04635 
<a name="l04636"></a>04636     <span class="keywordflow">if</span> (!indToCharLabel.empty())
<a name="l04637"></a>04637         {
<a name="l04638"></a>04638         out &lt;&lt; <span class="stringliteral">&quot;  Character and character state labels:&quot;</span> &lt;&lt; endl;
<a name="l04639"></a>04639         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 0; k &lt; nChar; k++)
<a name="l04640"></a>04640             {
<a name="l04641"></a>04641             <span class="keyword">const</span> std::map&lt;unsigned, std::string&gt;::const_iterator toLit = indToCharLabel.find(k);
<a name="l04642"></a>04642             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> kNum = 1 + k;
<a name="l04643"></a>04643             <span class="keywordflow">if</span> (toLit == indToCharLabel.end())
<a name="l04644"></a>04644                 out &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; kNum &lt;&lt; <span class="stringliteral">&quot;    (no label provided for this character)&quot;</span> &lt;&lt; endl;
<a name="l04645"></a>04645             <span class="keywordflow">else</span>
<a name="l04646"></a>04646                 out &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; kNum &lt;&lt; <span class="stringliteral">&quot;    &quot;</span> &lt;&lt; toLit-&gt;second &lt;&lt; endl;
<a name="l04647"></a>04647 
<a name="l04648"></a>04648             <span class="comment">// Output state labels if any are defined for this character</span>
<a name="l04649"></a>04649             <span class="comment">//</span>
<a name="l04650"></a>04650             NxsStringVectorMap::const_iterator cib = charStates.find(k);
<a name="l04651"></a>04651             <span class="keywordflow">if</span> (cib != charStates.end())
<a name="l04652"></a>04652                 {
<a name="l04653"></a>04653                 <span class="keywordtype">int</span> ns = (int)cib-&gt;second.size();
<a name="l04654"></a>04654                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m = 0; m &lt; ns; m++)
<a name="l04655"></a>04655                     out &lt;&lt; <span class="stringliteral">&quot;        &quot;</span> &lt;&lt; cib-&gt;second[m] &lt;&lt; endl;
<a name="l04656"></a>04656                 }
<a name="l04657"></a>04657             }
<a name="l04658"></a>04658         }
<a name="l04659"></a>04659 
<a name="l04660"></a>04660     <span class="keywordflow">if</span> (transposing &amp;&amp; interleaving)
<a name="l04661"></a>04661         out &lt;&lt; <span class="stringliteral">&quot;  Matrix transposed and interleaved&quot;</span> &lt;&lt; endl;
<a name="l04662"></a>04662     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (transposing &amp;&amp; !interleaving)
<a name="l04663"></a>04663         out &lt;&lt; <span class="stringliteral">&quot;  Matrix transposed but not interleaved&quot;</span> &lt;&lt; endl;
<a name="l04664"></a>04664     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!transposing &amp;&amp; interleaving)
<a name="l04665"></a>04665         out &lt;&lt; <span class="stringliteral">&quot;  Matrix interleaved but not transposed&quot;</span> &lt;&lt; endl;
<a name="l04666"></a>04666     <span class="keywordflow">else</span>
<a name="l04667"></a>04667         out &lt;&lt; <span class="stringliteral">&quot;  Matrix neither transposed nor interleaved&quot;</span> &lt;&lt; endl;
<a name="l04668"></a>04668 
<a name="l04669"></a>04669     out &lt;&lt; <span class="stringliteral">&quot;  Missing data symbol is &#39;&quot;</span> &lt;&lt; missing &lt;&lt; <span class="charliteral">&#39;\&#39;&#39;</span> &lt;&lt; endl;
<a name="l04670"></a>04670 
<a name="l04671"></a>04671     <span class="keywordflow">if</span> (matchchar != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l04672"></a>04672         out &lt;&lt; <span class="stringliteral">&quot;  Match character is &#39;&quot;</span> &lt;&lt; matchchar &lt;&lt; <span class="charliteral">&#39;\&#39;&#39;</span> &lt;&lt; endl;
<a name="l04673"></a>04673     <span class="keywordflow">else</span>
<a name="l04674"></a>04674         out &lt;&lt; <span class="stringliteral">&quot;  No match character specified&quot;</span> &lt;&lt; endl;
<a name="l04675"></a>04675 
<a name="l04676"></a>04676     <span class="keywordflow">if</span> (gap != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l04677"></a>04677         out &lt;&lt; <span class="stringliteral">&quot;  Gap character specified is &#39;&quot;</span> &lt;&lt; gap &lt;&lt; <span class="charliteral">&#39;\&#39;&#39;</span> &lt;&lt; endl;
<a name="l04678"></a>04678     <span class="keywordflow">else</span>
<a name="l04679"></a>04679         out &lt;&lt; <span class="stringliteral">&quot;  No gap character specified&quot;</span> &lt;&lt; endl;
<a name="l04680"></a>04680 
<a name="l04681"></a>04681     out &lt;&lt; <span class="stringliteral">&quot;  Valid symbols are: &quot;</span> &lt;&lt; symbols &lt;&lt; endl;
<a name="l04682"></a>04682 
<a name="l04683"></a>04683     <span class="keywordtype">int</span> numEquateMacros = (int)(userEquates.size() + defaultEquates.size());
<a name="l04684"></a>04684     <span class="keywordflow">if</span> (numEquateMacros &gt; 0)
<a name="l04685"></a>04685         {
<a name="l04686"></a>04686         out &lt;&lt; <span class="stringliteral">&quot;  Equate macros in effect:&quot;</span> &lt;&lt; endl;
<a name="l04687"></a>04687         std::map&lt;char, NxsString&gt;::const_iterator i = defaultEquates.begin();
<a name="l04688"></a>04688         <span class="keywordflow">for</span> (; i != defaultEquates.end(); ++i)
<a name="l04689"></a>04689             {
<a name="l04690"></a>04690             out &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; (*i).first &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; i-&gt;second &lt;&lt; endl;
<a name="l04691"></a>04691             }
<a name="l04692"></a>04692         i = userEquates.begin();
<a name="l04693"></a>04693         <span class="keywordflow">for</span> (; i != userEquates.end(); ++i)
<a name="l04694"></a>04694             {
<a name="l04695"></a>04695             out &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; (*i).first &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; i-&gt;second &lt;&lt; endl;
<a name="l04696"></a>04696             }
<a name="l04697"></a>04697         }
<a name="l04698"></a>04698     <span class="keywordflow">else</span>
<a name="l04699"></a>04699         out &lt;&lt; <span class="stringliteral">&quot;  No equate macros have been defined&quot;</span> &lt;&lt; endl;
<a name="l04700"></a>04700 
<a name="l04701"></a>04701     <span class="keywordflow">if</span> (eliminated.empty())
<a name="l04702"></a>04702         out &lt;&lt; <span class="stringliteral">&quot;  No characters were eliminated&quot;</span> &lt;&lt; endl;
<a name="l04703"></a>04703     <span class="keywordflow">else</span>
<a name="l04704"></a>04704         {
<a name="l04705"></a>04705         out &lt;&lt; <span class="stringliteral">&quot;  The following characters were eliminated:&quot;</span> &lt;&lt; endl;
<a name="l04706"></a>04706         NxsUnsignedSet::const_iterator k;
<a name="l04707"></a>04707         <span class="keywordflow">for</span> (k = eliminated.begin(); k != eliminated.end(); k++)
<a name="l04708"></a>04708             {
<a name="l04709"></a>04709             out &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; ((*k)+1) &lt;&lt; endl;
<a name="l04710"></a>04710             }
<a name="l04711"></a>04711         }
<a name="l04712"></a>04712 
<a name="l04713"></a>04713 
<a name="l04714"></a>04714     <span class="keywordflow">if</span> (excluded.empty())
<a name="l04715"></a>04715         out &lt;&lt; <span class="stringliteral">&quot;  no characters excluded&quot;</span> &lt;&lt; endl;
<a name="l04716"></a>04716     <span class="keywordflow">else</span>
<a name="l04717"></a>04717         {
<a name="l04718"></a>04718         out &lt;&lt; <span class="stringliteral">&quot;  The following characters have been excluded:\n&quot;</span>;
<a name="l04719"></a>04719         <span class="keywordflow">for</span> (NxsUnsignedSet::const_iterator eIt = excluded.begin(); eIt != excluded.end(); ++eIt)
<a name="l04720"></a>04720             out &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; (*eIt+1) &lt;&lt; endl;
<a name="l04721"></a>04721         }
<a name="l04722"></a>04722     out &lt;&lt; <span class="stringliteral">&quot;  Data matrix:&quot;</span> &lt;&lt; endl;
<a name="l04723"></a>04723     DebugShowMatrix(out, <span class="keyword">false</span>, <span class="stringliteral">&quot;    &quot;</span>);
<a name="l04724"></a>04724     }
<a name="l04725"></a>04725 
<a name="l04726"></a><a class="code" href="classNxsCharactersBlock_a1ca5f1afdce9cbca9369013fead33976.html#a1ca5f1afdce9cbca9369013fead33976">04726</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_a1ca5f1afdce9cbca9369013fead33976.html#a1ca5f1afdce9cbca9369013fead33976" title="Should serialize the content of the block as NEXUS.">NxsCharactersBlock::WriteAsNexus</a>(std::ostream &amp;out)<span class="keyword"> const</span>
<a name="l04727"></a>04727 <span class="keyword">    </span>{
<a name="l04728"></a>04728     out &lt;&lt; <span class="stringliteral">&quot;BEGIN CHARACTERS;\n&quot;</span>;
<a name="l04729"></a>04729     WriteBasicBlockCommands(out);
<a name="l04730"></a>04730     out &lt;&lt; <span class="stringliteral">&quot;    DIMENSIONS&quot;</span>;
<a name="l04731"></a>04731     <span class="keywordflow">if</span> (this-&gt;taxa)
<a name="l04732"></a>04732         {
<a name="l04733"></a>04733         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> wod = GetNTaxWithData();
<a name="l04734"></a>04734         <span class="keywordflow">if</span> (wod &gt; 0)
<a name="l04735"></a>04735             {
<a name="l04736"></a>04736             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> tnt = taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_a3e9b998d97ad05914bda0d616069c26f.html#a3e9b998d97ad05914bda0d616069c26f">GetNTax</a>();
<a name="l04737"></a>04737             <span class="keywordflow">if</span> (wod != tnt)
<a name="l04738"></a>04738                 out &lt;&lt; <span class="stringliteral">&quot; NTax=&quot;</span> &lt;&lt; wod;
<a name="l04739"></a>04739             }
<a name="l04740"></a>04740         }
<a name="l04741"></a>04741     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> multiplier = (this-&gt;datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa11d7fb339c6f83517338e0e6faac722" title="indicates `matrix&amp;#39; holds amino acid sequences">NxsCharactersBlock::codon</a> ? 3 : 1);
<a name="l04742"></a>04742     out &lt;&lt; <span class="stringliteral">&quot; NChar=&quot;</span> &lt;&lt; multiplier*(this-&gt;nChar) &lt;&lt; <span class="stringliteral">&quot;;\n&quot;</span>;
<a name="l04743"></a>04743     this-&gt;WriteEliminateCommand(out);
<a name="l04744"></a>04744     this-&gt;WriteFormatCommand(out);
<a name="l04745"></a>04745     this-&gt;WriteCharStateLabelsCommand(out);
<a name="l04746"></a>04746     this-&gt;WriteMatrixCommand(out);
<a name="l04747"></a>04747     WriteSkippedCommands(out);
<a name="l04748"></a>04748     out &lt;&lt; <span class="stringliteral">&quot;END;\n&quot;</span>;
<a name="l04749"></a>04749     }
<a name="l04750"></a>04750 
<a name="l04751"></a>04751 
<a name="l04752"></a>04752 <span class="keywordtype">void</span> NxsCharactersBlock::WriteEliminateCommand(
<a name="l04753"></a>04753   std::ostream &amp;out) <span class="keyword">const</span> <span class="comment">/* output stream on which to print matrix */</span>
<a name="l04754"></a>04754     {
<a name="l04755"></a>04755     <span class="keywordflow">if</span> (eliminated.empty())
<a name="l04756"></a>04756         <span class="keywordflow">return</span>;
<a name="l04757"></a>04757     out &lt;&lt; <span class="stringliteral">&quot;    ELIMINATE&quot;</span>;
<a name="l04758"></a>04758     <span class="keywordflow">for</span> (NxsUnsignedSet::const_iterator u = this-&gt;eliminated.begin(); u != this-&gt;eliminated.end(); ++u)
<a name="l04759"></a>04759         out &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; (1 + *u);
<a name="l04760"></a>04760     out &lt;&lt; <span class="stringliteral">&quot;;\n&quot;</span>;
<a name="l04761"></a>04761     }
<a name="l04762"></a>04762 
<a name="l04763"></a>04763 
<a name="l04764"></a>04764 <span class="keywordtype">void</span> NxsCharactersBlock::WriteMatrixCommand(
<a name="l04765"></a>04765   std::ostream &amp;out) <span class="keyword">const</span> <span class="comment">/* output stream on which to print matrix */</span>
<a name="l04766"></a>04766     {
<a name="l04767"></a>04767     <span class="keywordflow">if</span> (taxa == NULL)
<a name="l04768"></a>04768         <span class="keywordflow">return</span>;
<a name="l04769"></a>04769     <span class="keywordtype">unsigned</span> width = taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_a50ef9fdb2944f553fc3a4d4dd94cd1ef.html#a50ef9fdb2944f553fc3a4d4dd94cd1ef">GetMaxTaxonLabelLength</a>();
<a name="l04770"></a>04770     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> ntaxTotal = taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_a3e9b998d97ad05914bda0d616069c26f.html#a3e9b998d97ad05914bda0d616069c26f">GetNTax</a>();
<a name="l04771"></a>04771     out &lt;&lt; <span class="stringliteral">&quot;Matrix\n&quot;</span>;
<a name="l04772"></a>04772     <span class="keywordtype">int</span> prec = 6;
<a name="l04773"></a>04773     <span class="keywordflow">if</span> (datatype == continuous)
<a name="l04774"></a>04774         prec = out.precision(10);
<a name="l04775"></a>04775     <span class="keywordtype">unsigned</span> stride = (this-&gt;writeInterleaveLen &lt; 1 ? this-&gt;nChar : this-&gt;writeInterleaveLen);
<a name="l04776"></a>04776     <span class="keywordtype">unsigned</span> begChar = 0;
<a name="l04777"></a>04777     <span class="keywordflow">while</span> (begChar &lt; this-&gt;nChar)
<a name="l04778"></a>04778         {
<a name="l04779"></a>04779         <span class="keywordflow">if</span> (begChar &gt; 0)
<a name="l04780"></a>04780             out &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l04781"></a>04781         <span class="keywordtype">unsigned</span> endChar  = std::min(begChar + stride, this-&gt;nChar);
<a name="l04782"></a>04782         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; ntaxTotal; i++)
<a name="l04783"></a>04783             {
<a name="l04784"></a>04784             <span class="keywordflow">if</span> (this-&gt;TaxonIndHasData(i))
<a name="l04785"></a>04785                 {
<a name="l04786"></a>04786                 <span class="keyword">const</span> std::string currTaxonLabel = NxsString::GetEscaped(taxa-&gt;<a class="code" href="classNxsTaxaBlockAPI_ae172f21958353f1be42371f0cad7061d.html#ae172f21958353f1be42371f0cad7061d">GetTaxonLabel</a>(i));
<a name="l04787"></a>04787                 out &lt;&lt; currTaxonLabel;
<a name="l04788"></a>04788                 <span class="keywordtype">unsigned</span> currTaxonLabelLen = (unsigned)currTaxonLabel.size();
<a name="l04789"></a>04789                 <span class="keywordtype">unsigned</span> diff = width - currTaxonLabelLen;
<a name="l04790"></a>04790                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 0; k &lt; diff+5; k++)
<a name="l04791"></a>04791                     out &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l04792"></a>04792 
<a name="l04793"></a>04793                 WriteStatesForMatrixRow(out, i, UINT_MAX, begChar, endChar);
<a name="l04794"></a>04794                 out &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
<a name="l04795"></a>04795                 }
<a name="l04796"></a>04796             }
<a name="l04797"></a>04797         begChar = endChar;
<a name="l04798"></a>04798         }
<a name="l04799"></a>04799     out &lt;&lt; <span class="stringliteral">&quot;;\n&quot;</span>;
<a name="l04800"></a>04800     <span class="keywordflow">if</span> (datatype == continuous)
<a name="l04801"></a>04801         out.precision(prec);
<a name="l04802"></a>04802     }
<a name="l04803"></a>04803 
<a name="l04804"></a>04804 std::string NxsCharactersBlock::GetMatrixRowAsStr(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> rowIndex) <span class="keyword">const</span> <span class="comment">/* output stream on which to print matrix */</span>
<a name="l04805"></a>04805     {
<a name="l04806"></a>04806     <span class="keywordflow">if</span> (!this-&gt;TaxonIndHasData(rowIndex))
<a name="l04807"></a>04807         <span class="keywordflow">return</span> std::string();
<a name="l04808"></a>04808     std::ostringstream o;
<a name="l04809"></a>04809     WriteStatesForMatrixRow(o, rowIndex, UINT_MAX, 0, this-&gt;nChar);
<a name="l04810"></a>04810     <span class="keywordflow">return</span> o.str();
<a name="l04811"></a>04811     }
<a name="l04812"></a>04812 
<a name="l04813"></a>04813 <span class="keywordtype">void</span> NxsCharactersBlock::WriteStatesForMatrixRow(
<a name="l04814"></a>04814   std::ostream &amp;out,                <span class="comment">/* the output stream on which to write */</span>
<a name="l04815"></a>04815   <span class="keywordtype">unsigned</span> currTaxonIndex,  <span class="comment">/* the taxon, in range [0..`ntax&#39;) */</span>
<a name="l04816"></a>04816   <span class="keywordtype">unsigned</span> ,
<a name="l04817"></a>04817   <span class="keywordtype">unsigned</span> beginChar,
<a name="l04818"></a>04818   <span class="keywordtype">unsigned</span> endChar) <span class="keyword">const</span>       <span class="comment">/* the index of the first taxon (if UINT_MAX, don&#39;t use matchchar) */</span>
<a name="l04819"></a>04819     {
<a name="l04820"></a>04820     WriteStatesForTaxonAsNexus(out, currTaxonIndex, beginChar, endChar);
<a name="l04821"></a>04821     }
<a name="l04822"></a>04822 
<a name="l04823"></a>04823 
<a name="l04824"></a>04824 <span class="keywordtype">void</span> NxsCharactersBlock::WriteCharLabelsCommand(std::ostream &amp;out)<span class="keyword"> const</span>
<a name="l04825"></a>04825 <span class="keyword">    </span>{
<a name="l04826"></a>04826     <span class="keywordflow">if</span> (indToCharLabel.empty())
<a name="l04827"></a>04827         <span class="keywordflow">return</span>;
<a name="l04828"></a>04828     out &lt;&lt; <span class="stringliteral">&quot;    CHARLABELS&quot;</span>;
<a name="l04829"></a>04829     std::map&lt;unsigned, std::string&gt;::const_iterator resultSearchIt;
<a name="l04830"></a>04830     <span class="keyword">const</span> std::map&lt;unsigned, std::string&gt;::const_iterator endIt = indToCharLabel.end();
<a name="l04831"></a>04831     <span class="keywordtype">unsigned</span> emptyLabelsToWrite = 0;
<a name="l04832"></a>04832     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> oit = 0; oit &lt; nChar; ++oit)
<a name="l04833"></a>04833         {
<a name="l04834"></a>04834         resultSearchIt = indToCharLabel.find(oit);
<a name="l04835"></a>04835         <span class="keywordflow">if</span> (resultSearchIt == endIt)
<a name="l04836"></a>04836             emptyLabelsToWrite++;
<a name="l04837"></a>04837         <span class="keywordflow">else</span>
<a name="l04838"></a>04838             {
<a name="l04839"></a>04839             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; emptyLabelsToWrite; ++j)
<a name="l04840"></a>04840                 out &lt;&lt; <span class="stringliteral">&quot; _&quot;</span>;
<a name="l04841"></a>04841             emptyLabelsToWrite = 0;
<a name="l04842"></a>04842             out &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; NxsString::GetEscaped(resultSearchIt-&gt;second);
<a name="l04843"></a>04843             }
<a name="l04844"></a>04844         }
<a name="l04845"></a>04845     out &lt;&lt; <span class="stringliteral">&quot;;\n&quot;</span>;
<a name="l04846"></a>04846     }
<a name="l04847"></a>04847 
<a name="l04848"></a>04848 <span class="keywordtype">void</span> NxsCharactersBlock::WriteCharStateLabelsCommand(std::ostream &amp;out)<span class="keyword"> const</span>
<a name="l04849"></a>04849 <span class="keyword">    </span>{
<a name="l04850"></a>04850     <span class="keywordflow">if</span> (charStates.empty())
<a name="l04851"></a>04851         {
<a name="l04852"></a>04852         this-&gt;WriteCharLabelsCommand(out);
<a name="l04853"></a>04853         <span class="keywordflow">return</span>;
<a name="l04854"></a>04854         }
<a name="l04855"></a>04855     <span class="keyword">const</span> <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> mtString;
<a name="l04856"></a>04856     <span class="keywordtype">bool</span> isFirst = <span class="keyword">true</span>;
<a name="l04857"></a>04857     std::map&lt;unsigned, std::string&gt;::const_iterator resultSearchIt;
<a name="l04858"></a>04858     <span class="keyword">const</span> std::map&lt;unsigned, std::string&gt;::const_iterator endIt = indToCharLabel.end();
<a name="l04859"></a>04859     <span class="keyword">const</span> NxsStringVectorMap::const_iterator endCSIt = this-&gt;charStates.end();
<a name="l04860"></a>04860     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> oit = 0; oit &lt; nChar; ++oit)
<a name="l04861"></a>04861         {
<a name="l04862"></a>04862         resultSearchIt = indToCharLabel.find(oit);
<a name="l04863"></a>04863         <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> escapedCLabel;
<a name="l04864"></a>04864         <span class="keywordflow">if</span> (resultSearchIt != endIt)
<a name="l04865"></a>04865             escapedCLabel = NxsString::GetEscaped(resultSearchIt-&gt;second).c_str();
<a name="l04866"></a>04866         <span class="keyword">const</span> NxsStringVectorMap::const_iterator cib = this-&gt;charStates.find(oit);
<a name="l04867"></a>04867         <span class="keywordflow">if</span> (isFirst)
<a name="l04868"></a>04868             {
<a name="l04869"></a>04869             out &lt;&lt; <span class="stringliteral">&quot;    CharStateLabels \n      &quot;</span>;
<a name="l04870"></a>04870             isFirst = <span class="keyword">false</span>;
<a name="l04871"></a>04871             }
<a name="l04872"></a>04872         <span class="keywordflow">else</span>
<a name="l04873"></a>04873             out &lt;&lt; <span class="stringliteral">&quot;,\n      &quot;</span>;
<a name="l04874"></a>04874         out &lt;&lt; 1 + oit &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l04875"></a>04875         <span class="keywordflow">if</span> (cib != endCSIt)
<a name="l04876"></a>04876             {
<a name="l04877"></a>04877             <span class="keyword">const</span> NxsStringVector &amp; stateLabelsVec = cib-&gt;second;
<a name="l04878"></a>04878             <span class="keywordtype">unsigned</span> ns = (unsigned)stateLabelsVec.size();
<a name="l04879"></a>04879             <span class="keywordflow">if</span> (!escapedCLabel.empty())
<a name="l04880"></a>04880                 out &lt;&lt; escapedCLabel;
<a name="l04881"></a>04881             out &lt;&lt; <span class="stringliteral">&quot; / &quot;</span>;
<a name="l04882"></a>04882             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> m = 0; m &lt; ns; m++)
<a name="l04883"></a>04883                 out &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; NxsString::GetEscaped(stateLabelsVec[m]);
<a name="l04884"></a>04884             }
<a name="l04885"></a>04885         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!escapedCLabel.empty())
<a name="l04886"></a>04886             out &lt;&lt; escapedCLabel;
<a name="l04887"></a>04887         <span class="keywordflow">else</span> out &lt;&lt; <span class="charliteral">&#39;/&#39;</span>;
<a name="l04888"></a>04888         }
<a name="l04889"></a>04889     out &lt;&lt; <span class="stringliteral">&quot;;\n&quot;</span>;
<a name="l04890"></a>04890     }
<a name="l04891"></a>04891 
<a name="l04892"></a>04892 <span class="keywordtype">void</span> NxsCharactersBlock::WriteFormatCommand(std::ostream &amp;out)<span class="keyword"> const</span>
<a name="l04893"></a>04893 <span class="keyword">    </span>{
<a name="l04894"></a>04894     <span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * mapper =  GetDatatypeMapperForChar(0);
<a name="l04895"></a>04895     <span class="keywordflow">if</span> (IsMixedType())
<a name="l04896"></a>04896         {
<a name="l04897"></a>04897         out &lt;&lt; <span class="stringliteral">&quot;    FORMAT Datatype=MIXED(&quot;</span>;
<a name="l04898"></a>04898         <span class="keywordtype">bool</span> first = <span class="keyword">true</span>;
<a name="l04899"></a>04899         <span class="keywordflow">for</span> (std::vector&lt;DatatypeMapperAndIndexSet&gt;::const_iterator mIt = datatypeMapperVec.begin(); mIt != datatypeMapperVec.end(); ++mIt)
<a name="l04900"></a>04900             {
<a name="l04901"></a>04901             <span class="keywordflow">if</span> (first)
<a name="l04902"></a>04902                 first = <span class="keyword">false</span>;
<a name="l04903"></a>04903             <span class="keywordflow">else</span>
<a name="l04904"></a>04904                 out &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
<a name="l04905"></a>04905             out &lt;&lt; GetNameOfDatatype(mIt-&gt;first.GetDatatype()) &lt;&lt; <span class="charliteral">&#39;:&#39;</span>;
<a name="l04906"></a>04906             NxsSetReader::WriteSetAsNexusValue(mIt-&gt;second, out);
<a name="l04907"></a>04907             }
<a name="l04908"></a>04908         out &lt;&lt; <span class="charliteral">&#39;)&#39;</span>;
<a name="l04909"></a>04909         <span class="keywordflow">if</span> (this-&gt;missing != <span class="charliteral">&#39;?&#39;</span>)
<a name="l04910"></a>04910             out &lt;&lt; <span class="stringliteral">&quot; Missing=&quot;</span> &lt;&lt; this-&gt;missing;
<a name="l04911"></a>04911         <span class="keywordflow">if</span> (this-&gt;gap != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l04912"></a>04912             out &lt;&lt; <span class="stringliteral">&quot;  Gap=&quot;</span> &lt;&lt; this-&gt;gap;
<a name="l04913"></a>04913         }
<a name="l04914"></a>04914     <span class="keywordflow">else</span>
<a name="l04915"></a>04915         mapper-&gt;WriteStartOfFormatCommand(out);
<a name="l04916"></a>04916 
<a name="l04917"></a>04917     <span class="keywordflow">if</span> (this-&gt;respectingCase)
<a name="l04918"></a>04918         out &lt;&lt; <span class="stringliteral">&quot; RespectCase&quot;</span>;
<a name="l04919"></a>04919 
<a name="l04920"></a>04920     <span class="keywordflow">if</span> (this-&gt;matchchar != <span class="charliteral">&#39;\0&#39;</span>)
<a name="l04921"></a>04921         out &lt;&lt; <span class="stringliteral">&quot;  MatchChar=&quot;</span> &lt;&lt; this-&gt;matchchar;
<a name="l04922"></a>04922     <span class="keywordflow">if</span> (this-&gt;datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">continuous</a>)
<a name="l04923"></a>04923         {
<a name="l04924"></a>04924         out &lt;&lt; <span class="stringliteral">&quot; Items = (&quot;</span>;
<a name="l04925"></a>04925         <span class="keywordflow">for</span> (vector&lt;std::string&gt;::const_iterator iIt = items.begin(); iIt != items.end(); ++iIt)
<a name="l04926"></a>04926             out &lt;&lt; *iIt &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l04927"></a>04927         out &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;
<a name="l04928"></a>04928         <span class="keywordflow">if</span> (this-&gt;statesFormat == STATES_PRESENT)
<a name="l04929"></a>04929             out &lt;&lt; <span class="stringliteral">&quot; StatesFormat=StatesPresent&quot;</span>;
<a name="l04930"></a>04930         }
<a name="l04931"></a>04931     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (this-&gt;statesFormat == INDIVIDUALS)
<a name="l04932"></a>04932             out &lt;&lt; <span class="stringliteral">&quot; StatesFormat=Individuals&quot;</span>;
<a name="l04933"></a>04933 
<a name="l04934"></a>04934     <span class="keywordflow">if</span> (this-&gt;tokens &amp;&amp; this-&gt;datatype != <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>) <span class="comment">/*TOKENS is the only choice for continuous data*/</span>
<a name="l04935"></a>04935         out &lt;&lt; <span class="stringliteral">&quot; Tokens&quot;</span>;
<a name="l04936"></a>04936     <span class="keywordflow">if</span> (this-&gt;writeInterleaveLen &gt; 1 &amp;&amp; (this-&gt;nChar &gt; (<span class="keywordtype">unsigned</span>)this-&gt;writeInterleaveLen ))
<a name="l04937"></a>04937         {
<a name="l04938"></a>04938         out &lt;&lt; <span class="stringliteral">&quot; Interleave&quot;</span>;
<a name="l04939"></a>04939         }
<a name="l04940"></a>04940     out &lt;&lt; <span class="stringliteral">&quot;;\n&quot;</span>;
<a name="l04941"></a>04941     }
<a name="l04942"></a>04942 
<a name="l04943"></a>04943 std::map&lt;char, NxsString&gt; NxsCharactersBlock::GetDefaultEquates(DataTypesEnum dt)
<a name="l04944"></a>04944     {
<a name="l04945"></a>04945     std::map&lt;char, NxsString&gt; defEquates;
<a name="l04946"></a>04946     <span class="keywordflow">if</span> (dt == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca0145b9755a4581acaabe1e4c458d7f73" title="indicates `matrix&amp;#39; holds characters with arbitrarily-assigned, discrete states...">NxsCharactersBlock::dna</a> || dt == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca9cb7e8ceb8521a96df0b81ecac913814" title="indicates `matrix&amp;#39; holds DNA sequences (states A, C, G, T)">NxsCharactersBlock::rna</a> || dt == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa9ca7e6de7b65840b97d9ecd42c0ad3a" title="indicates `matrix&amp;#39; holds RNA sequences (states A, C, G, U)">NxsCharactersBlock::nucleotide</a>)
<a name="l04947"></a>04947         {
<a name="l04948"></a>04948         defEquates[<span class="charliteral">&#39;R&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{AG}&quot;</span>);
<a name="l04949"></a>04949         defEquates[<span class="charliteral">&#39;M&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{AC}&quot;</span>);
<a name="l04950"></a>04950         defEquates[<span class="charliteral">&#39;S&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{CG}&quot;</span>);
<a name="l04951"></a>04951         defEquates[<span class="charliteral">&#39;V&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{ACG}&quot;</span>);
<a name="l04952"></a>04952         <span class="keywordflow">if</span> (dt == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca0145b9755a4581acaabe1e4c458d7f73" title="indicates `matrix&amp;#39; holds characters with arbitrarily-assigned, discrete states...">NxsCharactersBlock::dna</a> || dt == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa9ca7e6de7b65840b97d9ecd42c0ad3a" title="indicates `matrix&amp;#39; holds RNA sequences (states A, C, G, U)">NxsCharactersBlock::nucleotide</a>)
<a name="l04953"></a>04953             {
<a name="l04954"></a>04954             defEquates[<span class="charliteral">&#39;Y&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{CT}&quot;</span>);
<a name="l04955"></a>04955             defEquates[<span class="charliteral">&#39;K&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{GT}&quot;</span>);
<a name="l04956"></a>04956             defEquates[<span class="charliteral">&#39;W&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{AT}&quot;</span>);
<a name="l04957"></a>04957             defEquates[<span class="charliteral">&#39;H&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{ACT}&quot;</span>);
<a name="l04958"></a>04958             defEquates[<span class="charliteral">&#39;B&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{CGT}&quot;</span>);
<a name="l04959"></a>04959             defEquates[<span class="charliteral">&#39;D&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{AGT}&quot;</span>);
<a name="l04960"></a>04960             defEquates[<span class="charliteral">&#39;N&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{ACGT}&quot;</span>);
<a name="l04961"></a>04961             defEquates[<span class="charliteral">&#39;X&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{ACGT}&quot;</span>);
<a name="l04962"></a>04962             <span class="keywordflow">if</span> (dt == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa9ca7e6de7b65840b97d9ecd42c0ad3a" title="indicates `matrix&amp;#39; holds RNA sequences (states A, C, G, U)">NxsCharactersBlock::nucleotide</a>)
<a name="l04963"></a>04963                 defEquates[<span class="charliteral">&#39;U&#39;</span>] =<span class="charliteral">&#39;T&#39;</span>;
<a name="l04964"></a>04964             }
<a name="l04965"></a>04965         <span class="keywordflow">else</span>
<a name="l04966"></a>04966             {
<a name="l04967"></a>04967             defEquates[<span class="charliteral">&#39;Y&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{CU}&quot;</span>);
<a name="l04968"></a>04968             defEquates[<span class="charliteral">&#39;K&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{GU}&quot;</span>);
<a name="l04969"></a>04969             defEquates[<span class="charliteral">&#39;W&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{AU}&quot;</span>);
<a name="l04970"></a>04970             defEquates[<span class="charliteral">&#39;H&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{ACU}&quot;</span>);
<a name="l04971"></a>04971             defEquates[<span class="charliteral">&#39;B&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{CGU}&quot;</span>);
<a name="l04972"></a>04972             defEquates[<span class="charliteral">&#39;D&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{AGU}&quot;</span>);
<a name="l04973"></a>04973             defEquates[<span class="charliteral">&#39;N&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{ACGU}&quot;</span>);
<a name="l04974"></a>04974             defEquates[<span class="charliteral">&#39;X&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{ACGU}&quot;</span>);
<a name="l04975"></a>04975             }
<a name="l04976"></a>04976         }
<a name="l04977"></a>04977     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dt == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca6867b9b05a5ce824179b5bdf10c891fc" title="indicates `matrix&amp;#39; holds nucleotide sequences">NxsCharactersBlock::protein</a>)
<a name="l04978"></a>04978         {
<a name="l04979"></a>04979         defEquates[<span class="charliteral">&#39;B&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{DN}&quot;</span>);
<a name="l04980"></a>04980         defEquates[<span class="charliteral">&#39;Z&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{EQ}&quot;</span>);
<a name="l04981"></a>04981         defEquates[<span class="charliteral">&#39;X&#39;</span>] = <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a>(<span class="stringliteral">&quot;{ACDEFGHIKLMNPQRSTVWY*}&quot;</span>);
<a name="l04982"></a>04982         }
<a name="l04983"></a>04983     <span class="comment">/* molecular datatypes are the only datatypes with default equates and</span>
<a name="l04984"></a>04984 <span class="comment">        keys of either case are equivalent.</span>
<a name="l04985"></a>04985 <span class="comment">    */</span>
<a name="l04986"></a>04986     <a class="code" href="classNxsString.html" title="A string class for use with the Nexus Class Library.">NxsString</a> upperKeys;
<a name="l04987"></a>04987     <span class="keywordflow">for</span> (std::map&lt;char, NxsString&gt;::const_iterator k = defEquates.begin(); k != defEquates.end(); ++k)
<a name="l04988"></a>04988         {
<a name="l04989"></a>04989         upperKeys += k-&gt;first;
<a name="l04990"></a>04990         }
<a name="l04991"></a>04991     <span class="keywordflow">for</span> (std::string::const_iterator k = upperKeys.begin(); k != upperKeys.end(); ++k)
<a name="l04992"></a>04992         {
<a name="l04993"></a>04993         <span class="keyword">const</span> <span class="keywordtype">char</span> c = *k;
<a name="l04994"></a>04994         <span class="keyword">const</span> <span class="keywordtype">char</span> lc = (char)tolower(c);
<a name="l04995"></a>04995         defEquates[lc] = defEquates[c];
<a name="l04996"></a>04996         }
<a name="l04997"></a>04997 
<a name="l04998"></a>04998     <span class="keywordflow">return</span> defEquates;
<a name="l04999"></a>04999     }
<a name="l05000"></a>05000 
<a name="l05001"></a>05001 <span class="keyword">const</span> <span class="keywordtype">char</span> * NxsCharactersBlock::GetNameOfDatatype(DataTypesEnum datatype)
<a name="l05002"></a>05002     {
<a name="l05003"></a>05003     <span class="keywordflow">switch</span>(datatype)
<a name="l05004"></a>05004         {
<a name="l05005"></a>05005         <span class="keywordflow">case</span> <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa11d7fb339c6f83517338e0e6faac722" title="indicates `matrix&amp;#39; holds amino acid sequences">NxsCharactersBlock::codon</a>:
<a name="l05006"></a>05006         <span class="keywordflow">case</span> <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca0145b9755a4581acaabe1e4c458d7f73" title="indicates `matrix&amp;#39; holds characters with arbitrarily-assigned, discrete states...">NxsCharactersBlock::dna</a>:
<a name="l05007"></a>05007             <span class="keywordflow">return</span> <span class="stringliteral">&quot;DNA&quot;</span>;
<a name="l05008"></a>05008         <span class="keywordflow">case</span> <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca9cb7e8ceb8521a96df0b81ecac913814" title="indicates `matrix&amp;#39; holds DNA sequences (states A, C, G, T)">NxsCharactersBlock::rna</a>:
<a name="l05009"></a>05009             <span class="keywordflow">return</span> <span class="stringliteral">&quot;RNA&quot;</span>;
<a name="l05010"></a>05010         <span class="keywordflow">case</span> <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa9ca7e6de7b65840b97d9ecd42c0ad3a" title="indicates `matrix&amp;#39; holds RNA sequences (states A, C, G, U)">NxsCharactersBlock::nucleotide</a>:
<a name="l05011"></a>05011             <span class="keywordflow">return</span> <span class="stringliteral">&quot;Nucleotide&quot;</span>;
<a name="l05012"></a>05012         <span class="keywordflow">case</span> <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca6867b9b05a5ce824179b5bdf10c891fc" title="indicates `matrix&amp;#39; holds nucleotide sequences">NxsCharactersBlock::protein</a>:
<a name="l05013"></a>05013             <span class="keywordflow">return</span> <span class="stringliteral">&quot;Protein&quot;</span>;
<a name="l05014"></a>05014         <span class="keywordflow">case</span> <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">NxsCharactersBlock::continuous</a>:
<a name="l05015"></a>05015             <span class="keywordflow">return</span> <span class="stringliteral">&quot;Continuous&quot;</span>;
<a name="l05016"></a>05016         <span class="keywordflow">default</span>:
<a name="l05017"></a>05017             <span class="keywordflow">return</span> <span class="stringliteral">&quot;Standard&quot;</span>;
<a name="l05018"></a>05018         }
<a name="l05019"></a>05019     }
<a name="l05020"></a>05020 
<a name="l05024"></a><a class="code" href="classNxsCharactersBlock_a2e479f3c7a744057e5ee3e653f9061e9.html#a2e479f3c7a744057e5ee3e653f9061e9">05024</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_a2e479f3c7a744057e5ee3e653f9061e9.html#a2e479f3c7a744057e5ee3e653f9061e9" title="Returns NxsCharactersBlock object to the state it was in when first created.">NxsCharactersBlock::Reset</a>()
<a name="l05025"></a>05025     {
<a name="l05026"></a>05026     ResetSurrogate();
<a name="l05027"></a>05027     <a class="code" href="classNxsCharactersBlock_a2e479f3c7a744057e5ee3e653f9061e9.html#a2e479f3c7a744057e5ee3e653f9061e9" title="Returns NxsCharactersBlock object to the state it was in when first created.">NxsBlock::Reset</a>();
<a name="l05028"></a>05028     nTaxWithData = 0;
<a name="l05029"></a>05029     nChar = 0;
<a name="l05030"></a>05030     newtaxa             = <span class="keyword">false</span>;
<a name="l05031"></a>05031     interleaving        = <span class="keyword">false</span>;
<a name="l05032"></a>05032     transposing         = <span class="keyword">false</span>;
<a name="l05033"></a>05033     respectingCase      = <span class="keyword">false</span>;
<a name="l05034"></a>05034     labels              = <span class="keyword">true</span>;
<a name="l05035"></a>05035     tokens              = <span class="keyword">false</span>;
<a name="l05036"></a>05036     datatype            = NxsCharactersBlock::standard;
<a name="l05037"></a>05037     originalDatatype    = NxsCharactersBlock::standard;
<a name="l05038"></a>05038     datatypeReadFromFormat = <span class="keyword">false</span>;
<a name="l05039"></a>05039     missing             = <span class="charliteral">&#39;?&#39;</span>;
<a name="l05040"></a>05040     gap                 = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l05041"></a>05041     gapMode = GAP_MODE_MISSING;
<a name="l05042"></a>05042     matchchar           = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l05043"></a>05043     symbols.clear();
<a name="l05044"></a>05044     <a class="code" href="classNxsCharactersBlock_a60329b2e678a91ca6cd46957093e6f56.html#a60329b2e678a91ca6cd46957093e6f56" title="Resets standard symbol set after a change in `datatype&amp;#39; is made.">ResetSymbols</a>();
<a name="l05045"></a>05045 
<a name="l05046"></a>05046     ucCharLabelToIndex.clear();
<a name="l05047"></a>05047     indToCharLabel.clear();
<a name="l05048"></a>05048     charSets.clear();
<a name="l05049"></a>05049     charPartitions.clear();
<a name="l05050"></a>05050     codonPosPartitions.clear();
<a name="l05051"></a>05051     defCodonPosPartitionName.clear();
<a name="l05052"></a>05052     exSets.clear();
<a name="l05053"></a>05053     charStates.clear();
<a name="l05054"></a>05054     globalStateLabels.clear();
<a name="l05055"></a>05055     userEquates.clear();
<a name="l05056"></a>05056     defaultEquates.clear();
<a name="l05057"></a>05057     eliminated.clear();
<a name="l05058"></a>05058     datatypeMapperVec.clear();
<a name="l05059"></a>05059     discreteMatrix.clear();
<a name="l05060"></a>05060     continuousMatrix.clear();
<a name="l05061"></a>05061     items = std::vector&lt;std::string&gt;(1, std::string(<span class="stringliteral">&quot;STATES&quot;</span>));
<a name="l05062"></a>05062     statesFormat = STATES_PRESENT;
<a name="l05063"></a>05063     restrictionDataype = <span class="keyword">false</span>;
<a name="l05064"></a>05064     }
<a name="l05065"></a>05065 
<a name="l05066"></a>05066 std::string NxsCharactersBlock::GetDefaultSymbolsForType(<a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290c" title="values used to represent different basic types of data stored in a CHARACTERS block...">NxsCharactersBlock::DataTypesEnum</a> dt)
<a name="l05067"></a>05067     {
<a name="l05068"></a>05068     <span class="keywordflow">switch</span>(dt)
<a name="l05069"></a>05069         {
<a name="l05070"></a>05070         <span class="keywordflow">case</span> <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290caa9ca7e6de7b65840b97d9ecd42c0ad3a" title="indicates `matrix&amp;#39; holds RNA sequences (states A, C, G, U)">NxsCharactersBlock::nucleotide</a>:
<a name="l05071"></a>05071         <span class="keywordflow">case</span> <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca0145b9755a4581acaabe1e4c458d7f73" title="indicates `matrix&amp;#39; holds characters with arbitrarily-assigned, discrete states...">NxsCharactersBlock::dna</a>:
<a name="l05072"></a>05072             <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ACGT&quot;</span>);
<a name="l05073"></a>05073         <span class="keywordflow">case</span> <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca9cb7e8ceb8521a96df0b81ecac913814" title="indicates `matrix&amp;#39; holds DNA sequences (states A, C, G, T)">NxsCharactersBlock::rna</a>:
<a name="l05074"></a>05074             <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ACGU&quot;</span>);
<a name="l05075"></a>05075         <span class="keywordflow">case</span> <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca6867b9b05a5ce824179b5bdf10c891fc" title="indicates `matrix&amp;#39; holds nucleotide sequences">NxsCharactersBlock::protein</a>:
<a name="l05076"></a>05076             <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;ACDEFGHIKLMNPQRSTVWY*&quot;</span>);
<a name="l05077"></a>05077         <span class="keywordflow">case</span> NxsCharactersBlock::standard:
<a name="l05078"></a>05078             <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;01&quot;</span>);
<a name="l05079"></a>05079         <span class="keywordflow">default</span>:
<a name="l05080"></a>05080             <span class="keywordflow">return</span> std::string();
<a name="l05081"></a>05081 
<a name="l05082"></a>05082         }
<a name="l05083"></a>05083     <span class="keywordflow">return</span> std::string();
<a name="l05084"></a>05084     }
<a name="l05089"></a><a class="code" href="classNxsCharactersBlock_a60329b2e678a91ca6cd46957093e6f56.html#a60329b2e678a91ca6cd46957093e6f56">05089</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_a60329b2e678a91ca6cd46957093e6f56.html#a60329b2e678a91ca6cd46957093e6f56" title="Resets standard symbol set after a change in `datatype&amp;#39; is made.">NxsCharactersBlock::ResetSymbols</a>()
<a name="l05090"></a>05090     {
<a name="l05091"></a>05091     symbols = GetDefaultSymbolsForType(datatype);
<a name="l05092"></a>05092     userEquates.clear();
<a name="l05093"></a>05093     defaultEquates = GetDefaultEquates(datatype);
<a name="l05094"></a>05094     datatypeMapperVec.clear();
<a name="l05095"></a>05095     }
<a name="l05096"></a>05096 
<a name="l05103"></a><a class="code" href="classNxsCharactersBlock_a5579db52d7a55f7f32d7716f93f7913d.html#a5579db52d7a55f7f32d7716f93f7913d">05103</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_a5579db52d7a55f7f32d7716f93f7913d.html#a5579db52d7a55f7f32d7716f93f7913d" title="Looks up the state(s) at row `i&amp;#39;, column `charNum&amp;#39; of matrix and writes it...">NxsCharactersBlock::ShowStateLabels</a>(
<a name="l05104"></a>05104   std::ostream &amp;out,                <span class="comment">/* the output stream on which to write */</span>
<a name="l05105"></a>05105   <span class="keywordtype">unsigned</span> taxInd,              <span class="comment">/* the taxon, in range [0..`ntax&#39;) */</span>
<a name="l05106"></a>05106   <span class="keywordtype">unsigned</span> charInd,             <span class="comment">/* the character, in range [0..`nChar&#39;) */</span>
<a name="l05107"></a>05107   <span class="keywordtype">unsigned</span> ) const      <span class="comment">/* the index of the first taxon (if UINT_MAX, don&#39;t use matchchar) */</span>
<a name="l05108"></a>05108     {
<a name="l05109"></a>05109     <span class="keywordflow">if</span> (datatype == <a class="code" href="classNxsCharactersBlock_ad81b69dd477d09c9c8d37b958819290c.html#ad81b69dd477d09c9c8d37b958819290ca052c8b5fc3128e5878e802de077b9aae" title="AAA=&amp;gt;0, AAC=1, AAAG=&amp;gt;2, AAU=&amp;gt;3, ACA=&amp;gt;4.">continuous</a>)
<a name="l05110"></a>05110         {
<a name="l05111"></a>05111         <span class="keyword">const</span> ContinuousCharCell &amp; cell = continuousMatrix.at(taxInd).at(charInd);
<a name="l05112"></a>05112         std::vector&lt;std::string&gt;::const_iterator itemIt = items.begin();
<a name="l05113"></a>05113         <span class="keywordtype">bool</span> parensNeeded = items.size() &gt; 1;
<a name="l05114"></a>05114         <span class="keywordflow">if</span> (items.size() == 1)
<a name="l05115"></a>05115             {
<a name="l05116"></a>05116             ContinuousCharCell::const_iterator oit = cell.find(*itemIt);
<a name="l05117"></a>05117             <span class="keywordflow">if</span> (oit != cell.end() &amp;&amp; oit-&gt;second.size() &gt; 1)
<a name="l05118"></a>05118                 parensNeeded = <span class="keyword">true</span>;
<a name="l05119"></a>05119             }
<a name="l05120"></a>05120         <span class="keywordflow">if</span> (parensNeeded)
<a name="l05121"></a>05121             out  &lt;&lt; <span class="charliteral">&#39;(&#39;</span>;
<a name="l05122"></a>05122         <span class="keywordflow">for</span> (; itemIt != items.end(); ++itemIt)
<a name="l05123"></a>05123             {
<a name="l05124"></a>05124             ContinuousCharCell::const_iterator cit = cell.find(*itemIt);
<a name="l05125"></a>05125             <span class="keywordflow">if</span> (cit == cell.end())
<a name="l05126"></a>05126                 out &lt;&lt; missing &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l05127"></a>05127             <span class="keywordflow">else</span>
<a name="l05128"></a>05128                 {
<a name="l05129"></a>05129                 <span class="keywordflow">if</span> (cit-&gt;second.empty())
<a name="l05130"></a>05130                     out &lt;&lt; missing &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l05131"></a>05131                 <span class="keywordflow">else</span>
<a name="l05132"></a>05132                     {
<a name="l05133"></a>05133                     vector&lt;double&gt;::const_iterator vIt = cit-&gt;second.begin();
<a name="l05134"></a>05134                     <span class="keywordflow">for</span>(; vIt != cit-&gt;second.end(); ++vIt)
<a name="l05135"></a>05135                         {
<a name="l05136"></a>05136                         <span class="keywordflow">if</span> (*vIt == DBL_MAX)
<a name="l05137"></a>05137                             out &lt;&lt; missing &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l05138"></a>05138                         <span class="keywordflow">else</span>
<a name="l05139"></a>05139                             out &lt;&lt; *vIt &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l05140"></a>05140                         }
<a name="l05141"></a>05141                     }
<a name="l05142"></a>05142                 }
<a name="l05143"></a>05143             }
<a name="l05144"></a>05144         <span class="keywordflow">if</span> (parensNeeded)
<a name="l05145"></a>05145             out  &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>;
<a name="l05146"></a>05146         <span class="keywordflow">else</span>
<a name="l05147"></a>05147             out &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l05148"></a>05148         <span class="keywordflow">return</span>;
<a name="l05149"></a>05149         }
<a name="l05150"></a>05150     <span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * mapper = GetDatatypeMapperForChar(charInd);
<a name="l05151"></a>05151     NCL_ASSERT(mapper != NULL);
<a name="l05152"></a>05152     <span class="keyword">const</span> NxsDiscreteStateCell currStateCode = discreteMatrix.at(taxInd).at(charInd);
<a name="l05153"></a>05153     <span class="keywordflow">if</span> (tokens)
<a name="l05154"></a>05154         {
<a name="l05155"></a>05155         out &lt;&lt; <span class="charliteral">&#39; &#39;</span>;
<a name="l05156"></a>05156         <span class="keywordflow">if</span> (currStateCode &gt;= 0 &amp;&amp; currStateCode &lt; (NxsDiscreteStateCell) mapper-&gt;GetNumStates())
<a name="l05157"></a>05157             {
<a name="l05158"></a>05158             NxsStringVectorMap::const_iterator ci = charStates.find(charInd);
<a name="l05159"></a>05159             <span class="keywordflow">if</span> (ci != charStates.end() &amp;&amp; ((NxsDiscreteStateCell) ci-&gt;second.size()) &gt; currStateCode)
<a name="l05160"></a>05160                 out &lt;&lt; ci-&gt;second[currStateCode];
<a name="l05161"></a>05161             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currStateCode &lt; 0)
<a name="l05162"></a>05162                 {
<a name="l05163"></a>05163                 <span class="keywordflow">if</span> (currStateCode == NXS_MISSING_CODE)
<a name="l05164"></a>05164                     out &lt;&lt; this-&gt;<a class="code" href="classNxsCharactersBlock_a092c1a9ed05525b76467ad9b8028adef.html#a092c1a9ed05525b76467ad9b8028adef" title="Returns the missing data symbol currently in effect.">GetMissingSymbol</a>();
<a name="l05165"></a>05165                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (currStateCode == NXS_GAP_STATE_CODE)
<a name="l05166"></a>05166                     out &lt;&lt; this-&gt;<a class="code" href="classNxsCharactersBlock_a25f1d2be3465fd9dafb97be50d8e2601.html#a25f1d2be3465fd9dafb97be50d8e2601" title="Returns the gap symbol currently in effect.">GetGapSymbol</a>();
<a name="l05167"></a>05167                 <span class="keywordflow">else</span>
<a name="l05168"></a>05168                     out &lt;&lt; <span class="charliteral">&#39;_&#39;</span>;
<a name="l05169"></a>05169                 }
<a name="l05170"></a>05170             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (globalStateLabels.size() &gt; (unsigned) currStateCode)
<a name="l05171"></a>05171                 out &lt;&lt; globalStateLabels[currStateCode];
<a name="l05172"></a>05172             <span class="keywordflow">else</span>
<a name="l05173"></a>05173                 out &lt;&lt; <span class="charliteral">&#39;_&#39;</span>;
<a name="l05174"></a>05174             <span class="keywordflow">return</span>;
<a name="l05175"></a>05175             }
<a name="l05176"></a>05176         }
<a name="l05177"></a>05177     mapper-&gt;<a class="code" href="classNxsDiscreteDatatypeMapper_a60f67a89207c16b0f5e297c6d43a313a.html#a60f67a89207c16b0f5e297c6d43a313a" title="Returns the NEXUS reperesenation of the state code `scode` which may be a multiple...">WriteStateCodeAsNexusString</a>(out, currStateCode);
<a name="l05178"></a>05178     }
<a name="l05179"></a>05179 
<a name="l05186"></a><a class="code" href="classNxsCharactersBlock_adde4eb7fa536c3a18c5654605f17bef6.html#adde4eb7fa536c3a18c5654605f17bef6">05186</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_adde4eb7fa536c3a18c5654605f17bef6.html#adde4eb7fa536c3a18c5654605f17bef6" title="Writes out the state (or states) stored in this NxsDiscreteDatum object to the buffer...">NxsCharactersBlock::WriteStates</a>(
<a name="l05187"></a>05187   <a class="code" href="classNxsDiscreteDatum.html" title="Reference to a cell in a DiscreteMatrix.">NxsDiscreteDatum</a> &amp;d,  <span class="comment">/* the datum to be queried */</span>
<a name="l05188"></a>05188   <span class="keywordtype">char</span> *s,              <span class="comment">/* the buffer to which to print */</span>
<a name="l05189"></a>05189   <span class="keywordtype">unsigned</span> slen) NCL_COULD_BE_CONST <span class="comment">/* the length of the buffer `s&#39; */</span> <span class="comment">/*v2.1to2.2 1 */</span>
<a name="l05190"></a>05190     {
<a name="l05191"></a>05191     std::ostringstream outs;
<a name="l05192"></a>05192     ShowStates(outs, d.taxInd, d.charInd);
<a name="l05193"></a>05193     std::string sfo = outs.str();
<a name="l05194"></a>05194     <span class="keywordflow">if</span> (s == NULL || sfo.length() &gt; slen)
<a name="l05195"></a>05195         <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(<span class="stringliteral">&quot;Char buffer too small in NxsCharactersBlock::WriteStates&quot;</span>);
<a name="l05196"></a>05196     strcpy(s, sfo.c_str());
<a name="l05197"></a>05197     }
<a name="l05198"></a>05198 
<a name="l05205"></a><a class="code" href="classNxsCharactersBlock_ad04cb5515e9d67d0bc3f8953f78f6439.html#ad04cb5515e9d67d0bc3f8953f78f6439">05205</a> <span class="keywordtype">unsigned</span> <a class="code" href="classNxsCharactersBlock_ad04cb5515e9d67d0bc3f8953f78f6439.html#ad04cb5515e9d67d0bc3f8953f78f6439" title="This function is no longer the most efficient way to access parsed data (see notes...">NxsCharactersBlock::GetNumStates</a>(
<a name="l05206"></a>05206   <span class="keywordtype">unsigned</span> taxInd,  <span class="comment">/* the taxon in range [0..`ntax&#39;) */</span>
<a name="l05207"></a>05207   <span class="keywordtype">unsigned</span> charInd) NCL_COULD_BE_CONST <span class="comment">/* the character in range [0..`nChar&#39;) */</span> <span class="comment">/*v2.1to2.2 1 */</span>
<a name="l05208"></a>05208     {
<a name="l05209"></a>05209     <span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * mapper = GetDatatypeMapperForChar(charInd);
<a name="l05210"></a>05210     NCL_ASSERT(mapper != NULL);
<a name="l05211"></a>05211     <span class="keyword">const</span> NxsDiscreteStateCell currStateCode = discreteMatrix.at(taxInd).at(charInd);
<a name="l05212"></a>05212     <span class="keywordflow">return</span> mapper-&gt;GetNumStatesInStateCode(currStateCode);
<a name="l05213"></a>05213     }
<a name="l05214"></a>05214 
<a name="l05217"></a><a class="code" href="classNxsCharactersBlock_a5c12fb5d3295cce9292839d9fe774e1b.html#a5c12fb5d3295cce9292839d9fe774e1b">05217</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_a5c12fb5d3295cce9292839d9fe774e1b.html#a5c12fb5d3295cce9292839d9fe774e1b" title="excludes character `i`">NxsCharactersBlock::ExcludeCharacter</a>(
<a name="l05218"></a>05218   <span class="keywordtype">unsigned</span> i)   <span class="comment">/* index of character to exclude in range [0..`nChar&#39;) */</span>
<a name="l05219"></a>05219     {
<a name="l05220"></a>05220     <span class="keywordflow">if</span> (i &gt;= nChar)
<a name="l05221"></a>05221         {
<a name="l05222"></a>05222         errormsg  = <span class="stringliteral">&quot;Character index is ExcludeCharacter out-of-range.   Must be &lt; &quot;</span>;
<a name="l05223"></a>05223         errormsg &lt;&lt; nChar;
<a name="l05224"></a>05224         <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(errormsg);
<a name="l05225"></a>05225         }
<a name="l05226"></a>05226     excluded.insert(i);
<a name="l05227"></a>05227     }
<a name="l05230"></a><a class="code" href="classNxsCharactersBlock_a77cae32fe241edccb568c974f84f4d6e.html#a77cae32fe241edccb568c974f84f4d6e">05230</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_a77cae32fe241edccb568c974f84f4d6e.html#a77cae32fe241edccb568c974f84f4d6e" title="includes character `i`">NxsCharactersBlock::IncludeCharacter</a>(
<a name="l05231"></a>05231   <span class="keywordtype">unsigned</span> i)   <span class="comment">/* index of character to include in range [0..`nChar&#39;) */</span>
<a name="l05232"></a>05232     {
<a name="l05233"></a>05233     <span class="keywordflow">if</span> (i &gt;= nChar)
<a name="l05234"></a>05234         {
<a name="l05235"></a>05235         errormsg  = <span class="stringliteral">&quot;Character index is ExcludeCharacter out-of-range.   Must be &lt; &quot;</span>;
<a name="l05236"></a>05236         errormsg &lt;&lt; nChar;
<a name="l05237"></a>05237         <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(errormsg);
<a name="l05238"></a>05238         }
<a name="l05239"></a>05239     excluded.erase(i);
<a name="l05240"></a>05240     }
<a name="l05241"></a>05241 
<a name="l05242"></a><a class="code" href="classNxsCharactersBlock_a844c584f989e09fafd25893973751ade.html#a844c584f989e09fafd25893973751ade">05242</a> <span class="keywordtype">bool</span> <a class="code" href="classNxsCharactersBlock_a844c584f989e09fafd25893973751ade.html#a844c584f989e09fafd25893973751ade" title="Returns true iff taxon `taxInd` has a gap for character `charInd` (both indices 0-based)...">NxsCharactersBlock::IsGapState</a>(
<a name="l05243"></a>05243   <span class="keywordtype">unsigned</span> taxInd,  <span class="comment">/* the taxon, in range [0..`ntax&#39;) */</span>
<a name="l05244"></a>05244   <span class="keywordtype">unsigned</span> charInd) NCL_COULD_BE_CONST <span class="comment">/* the character, in range [0..`nChar&#39;) */</span> <span class="comment">/*v2.1to2.2 1 */</span>
<a name="l05245"></a>05245     {
<a name="l05246"></a>05246     <span class="keywordflow">if</span> (this-&gt;datatype == continuous)
<a name="l05247"></a>05247         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05248"></a>05248     <span class="keyword">const</span> NxsDiscreteStateRow &amp; row = discreteMatrix.at(taxInd);
<a name="l05249"></a>05249     <span class="keywordflow">return</span> (row.size() &gt; charInd &amp;&amp; row[charInd] == NXS_GAP_STATE_CODE);
<a name="l05250"></a>05250     }
<a name="l05251"></a>05251 
<a name="l05252"></a><a class="code" href="classNxsCharactersBlock_a26a2f859f7b8c0d45a753675cf53d942.html#a26a2f859f7b8c0d45a753675cf53d942">05252</a> <span class="keywordtype">bool</span> <a class="code" href="classNxsCharactersBlock_a26a2f859f7b8c0d45a753675cf53d942.html#a26a2f859f7b8c0d45a753675cf53d942" title="Returns true iff taxon `taxInd` has is missing for character `charInd` (both indices...">NxsCharactersBlock::IsMissingState</a>(
<a name="l05253"></a>05253   <span class="keywordtype">unsigned</span> taxInd,  <span class="comment">/* the taxon, in range [0..`ntax&#39;) */</span>
<a name="l05254"></a>05254   <span class="keywordtype">unsigned</span> charInd) NCL_COULD_BE_CONST <span class="comment">/* the character, in range [0..`nChar&#39;) */</span> <span class="comment">/*v2.1to2.2 1 */</span>
<a name="l05255"></a>05255     {
<a name="l05256"></a>05256     <span class="keywordflow">if</span> (this-&gt;datatype == continuous)
<a name="l05257"></a>05257         {
<a name="l05258"></a>05258         <span class="keywordflow">return</span> !continuousMatrix.at(taxInd).empty();
<a name="l05259"></a>05259         }
<a name="l05260"></a>05260     <span class="keyword">const</span> NxsDiscreteStateRow &amp; row = discreteMatrix.at(taxInd);
<a name="l05261"></a>05261     <span class="keywordflow">return</span> (row.size() &lt;= charInd || (row[charInd] == NXS_MISSING_CODE));
<a name="l05262"></a>05262     }
<a name="l05263"></a>05263 
<a name="l05264"></a>05264 
<a name="l05265"></a>05265 <span class="keywordtype">void</span> NxsCharactersBlock::FindConstantCharacters(NxsUnsignedSet &amp;c)<span class="keyword"> const</span>
<a name="l05266"></a>05266 <span class="keyword">    </span>{
<a name="l05267"></a>05267     vector&lt;NxsDiscreteStateCell&gt; iv;
<a name="l05268"></a>05268     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> colIndex = 0; colIndex &lt; nChar; ++colIndex)
<a name="l05269"></a>05269         {
<a name="l05270"></a>05270         <span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * mapper = GetDatatypeMapperForChar(colIndex);
<a name="l05271"></a>05271         <span class="keywordflow">if</span> (mapper == NULL)
<a name="l05272"></a>05272             <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(<span class="stringliteral">&quot;No DatatypeMapper in FindConstantCharacters&quot;</span>);
<a name="l05273"></a>05273 
<a name="l05274"></a>05274         std::set&lt;NxsDiscreteStateCell&gt; intersectionSet = mapper-&gt;<a class="code" href="classNxsDiscreteDatatypeMapper_ad39cdce419be460c3a197dfa07a96c80.html#ad39cdce419be460c3a197dfa07a96c80" title="Returns the set of state indices that correspond to the states of state code `c`...">GetStateSetForCode</a>(NXS_MISSING_CODE);
<a name="l05275"></a>05275         <span class="keywordflow">for</span> (NxsDiscreteStateMatrix::const_iterator rowIt = discreteMatrix.begin(); rowIt != discreteMatrix.end(); ++rowIt)
<a name="l05276"></a>05276             {
<a name="l05277"></a>05277             <span class="keyword">const</span> NxsDiscreteStateRow &amp; row = *rowIt;
<a name="l05278"></a>05278             <span class="keywordflow">if</span> (row.size() &gt; colIndex)
<a name="l05279"></a>05279                 {
<a name="l05280"></a>05280                 <span class="keyword">const</span> NxsDiscreteStateCell sc = row[colIndex];
<a name="l05281"></a>05281                 std::set&lt;NxsDiscreteStateCell&gt; currSet = mapper-&gt;<a class="code" href="classNxsDiscreteDatatypeMapper_ad39cdce419be460c3a197dfa07a96c80.html#ad39cdce419be460c3a197dfa07a96c80" title="Returns the set of state indices that correspond to the states of state code `c`...">GetStateSetForCode</a>(sc);
<a name="l05282"></a>05282                 iv.clear();
<a name="l05283"></a>05283                 set_intersection(currSet.begin(), currSet.end(), intersectionSet.begin(), intersectionSet.end(), back_inserter(iv));
<a name="l05284"></a>05284                 intersectionSet.clear();
<a name="l05285"></a>05285                 <span class="keywordflow">if</span> (iv.empty())
<a name="l05286"></a>05286                     <span class="keywordflow">break</span>;
<a name="l05287"></a>05287                 intersectionSet.insert(iv.begin(), iv.end());
<a name="l05288"></a>05288                 }
<a name="l05289"></a>05289             }
<a name="l05290"></a>05290         <span class="keywordflow">if</span> (!intersectionSet.empty())
<a name="l05291"></a>05291             c.insert(colIndex);
<a name="l05292"></a>05292         }
<a name="l05293"></a>05293     }
<a name="l05294"></a>05294 
<a name="l05295"></a>05295 <span class="keywordtype">void</span> NxsCharactersBlock::FindGappedCharacters(NxsUnsignedSet &amp;c)<span class="keyword"> const</span>
<a name="l05296"></a>05296 <span class="keyword">    </span>{
<a name="l05297"></a>05297     vector&lt;NxsDiscreteStateCell&gt; iv;
<a name="l05298"></a>05298     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> colIndex = 0; colIndex &lt; nChar; ++colIndex)
<a name="l05299"></a>05299         {
<a name="l05300"></a>05300         <span class="keywordflow">for</span> (NxsDiscreteStateMatrix::const_iterator rowIt = discreteMatrix.begin(); rowIt != discreteMatrix.end(); ++rowIt)
<a name="l05301"></a>05301             {
<a name="l05302"></a>05302             <span class="keyword">const</span> NxsDiscreteStateRow &amp; row = *rowIt;
<a name="l05303"></a>05303             <span class="keywordflow">if</span> (row.size() &gt; colIndex &amp;&amp; row[colIndex] == NXS_GAP_STATE_CODE)
<a name="l05304"></a>05304                 {
<a name="l05305"></a>05305                 c.insert(colIndex);
<a name="l05306"></a>05306                 <span class="keywordflow">break</span>;
<a name="l05307"></a>05307                 }
<a name="l05308"></a>05308             }
<a name="l05309"></a>05309         }
<a name="l05310"></a>05310     }
<a name="l05311"></a>05311 
<a name="l05312"></a>05312 <span class="comment">/* Behaves like GetMaximalStateSetOfColumn except that missing data columns do not increase</span>
<a name="l05313"></a>05313 <span class="comment">    size of the returned state set.</span>
<a name="l05314"></a>05314 <span class="comment">    If GapMode is missing, then gaps are not counted.</span>
<a name="l05315"></a>05315 <span class="comment">*/</span>
<a name="l05316"></a><a class="code" href="classNxsCharactersBlock_abfbe1a4ecf6cd80703e0979473d0fcb6.html#abfbe1a4ecf6cd80703e0979473d0fcb6">05316</a> std::set&lt;NxsDiscreteStateCell&gt; <a class="code" href="classNxsCharactersBlock_abfbe1a4ecf6cd80703e0979473d0fcb6.html#abfbe1a4ecf6cd80703e0979473d0fcb6" title="Behaves like GetMaximalStateSetOfColumn except that missing data columns do not increase...">NxsCharactersBlock::GetNamedStateSetOfColumn</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> colIndex)<span class="keyword"> const</span>
<a name="l05317"></a>05317 <span class="keyword">    </span>{
<a name="l05318"></a>05318     <span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * mapper = GetDatatypeMapperForChar(colIndex);
<a name="l05319"></a>05319     <span class="keywordflow">if</span> (mapper == NULL)
<a name="l05320"></a>05320         <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(<span class="stringliteral">&quot;No DatatypeMapper in GetNamedStateSetOfColumn&quot;</span>);
<a name="l05321"></a>05321 
<a name="l05322"></a>05322     std::set&lt;NxsDiscreteStateCell&gt; sset;
<a name="l05323"></a>05323     std::set&lt;NxsDiscreteStateCell&gt; scodes;
<a name="l05324"></a>05324     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> maxnstates = mapper-&gt;GetNumStatesIncludingGap();
<a name="l05325"></a>05325     <span class="keywordflow">for</span> (NxsDiscreteStateMatrix::const_iterator rowIt = discreteMatrix.begin(); rowIt != discreteMatrix.end(); ++rowIt)
<a name="l05326"></a>05326         {
<a name="l05327"></a>05327         <span class="keyword">const</span> NxsDiscreteStateRow &amp; row = *rowIt;
<a name="l05328"></a>05328         <span class="keywordflow">if</span> (row.size() &gt; colIndex)
<a name="l05329"></a>05329             {
<a name="l05330"></a>05330             <span class="keyword">const</span> NxsDiscreteStateCell sc = row[colIndex];
<a name="l05331"></a>05331             <span class="keyword">const</span> <span class="keywordtype">bool</span> isIgnoredGap = (sc == NXS_GAP_STATE_CODE) &amp;&amp; (this-&gt;gapMode == GAP_MODE_MISSING);
<a name="l05332"></a>05332             <span class="keyword">const</span> <span class="keywordtype">bool</span> toBeCounted = !(sc == NXS_MISSING_CODE || isIgnoredGap);
<a name="l05333"></a>05333             <span class="keywordflow">if</span> (toBeCounted &amp;&amp; scodes.count(sc) == 0)
<a name="l05334"></a>05334                 {
<a name="l05335"></a>05335                 scodes.insert(sc);
<a name="l05336"></a>05336                 <span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt;    &amp; ts = mapper-&gt;<a class="code" href="classNxsDiscreteDatatypeMapper_ad39cdce419be460c3a197dfa07a96c80.html#ad39cdce419be460c3a197dfa07a96c80" title="Returns the set of state indices that correspond to the states of state code `c`...">GetStateSetForCode</a>(sc);
<a name="l05337"></a>05337                 sset.insert(ts.begin(), ts.end());
<a name="l05338"></a>05338                 <span class="keywordflow">if</span> (sset.size() == maxnstates)
<a name="l05339"></a>05339                     <span class="keywordflow">break</span>;
<a name="l05340"></a>05340                 }
<a name="l05341"></a>05341             }
<a name="l05342"></a>05342         }
<a name="l05343"></a>05343     <span class="keywordflow">return</span> sset;
<a name="l05344"></a>05344     }
<a name="l05345"></a>05345 <span class="comment">/* Returns the union of all states that are consistent with a column */</span>
<a name="l05346"></a><a class="code" href="classNxsCharactersBlock_a89060fd036ccd27e3c8333056a6535a2.html#a89060fd036ccd27e3c8333056a6535a2">05346</a> std::set&lt;NxsDiscreteStateCell&gt; <a class="code" href="classNxsCharactersBlock_a89060fd036ccd27e3c8333056a6535a2.html#a89060fd036ccd27e3c8333056a6535a2" title="Returns the set of &amp;quot;fundamental&amp;quot; states seen in a column (possibly including...">NxsCharactersBlock::GetMaximalStateSetOfColumn</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> colIndex)<span class="keyword"> const</span>
<a name="l05347"></a>05347 <span class="keyword">    </span>{
<a name="l05348"></a>05348     <span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * mapper = GetDatatypeMapperForChar(colIndex);
<a name="l05349"></a>05349     <span class="keywordflow">if</span> (mapper == NULL)
<a name="l05350"></a>05350         <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(<span class="stringliteral">&quot;No DatatypeMapper in GetMaximalStateSetOfColumn&quot;</span>);
<a name="l05351"></a>05351 
<a name="l05352"></a>05352     std::set&lt;NxsDiscreteStateCell&gt; sset;
<a name="l05353"></a>05353     std::set&lt;NxsDiscreteStateCell&gt; scodes;
<a name="l05354"></a>05354     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> maxnstates = mapper-&gt;GetNumStatesIncludingGap();
<a name="l05355"></a>05355     <span class="keywordflow">for</span> (NxsDiscreteStateMatrix::const_iterator rowIt = discreteMatrix.begin(); rowIt != discreteMatrix.end(); ++rowIt)
<a name="l05356"></a>05356         {
<a name="l05357"></a>05357         <span class="keyword">const</span> NxsDiscreteStateRow &amp; row = *rowIt;
<a name="l05358"></a>05358         <span class="keywordflow">if</span> (row.size() &gt; colIndex)
<a name="l05359"></a>05359             {
<a name="l05360"></a>05360             <span class="keyword">const</span> NxsDiscreteStateCell sc = row[colIndex];
<a name="l05361"></a>05361             <span class="keywordflow">if</span> (scodes.count(sc) == 0)
<a name="l05362"></a>05362                 {
<a name="l05363"></a>05363                 scodes.insert(sc);
<a name="l05364"></a>05364                 <span class="keyword">const</span> std::set&lt;NxsDiscreteStateCell&gt;    &amp; ts = mapper-&gt;<a class="code" href="classNxsDiscreteDatatypeMapper_ad39cdce419be460c3a197dfa07a96c80.html#ad39cdce419be460c3a197dfa07a96c80" title="Returns the set of state indices that correspond to the states of state code `c`...">GetStateSetForCode</a>(sc);
<a name="l05365"></a>05365                 sset.insert(ts.begin(), ts.end());
<a name="l05366"></a>05366                 <span class="keywordflow">if</span> (sset.size() == maxnstates)
<a name="l05367"></a>05367                     <span class="keywordflow">break</span>;
<a name="l05368"></a>05368                 }
<a name="l05369"></a>05369             }
<a name="l05370"></a>05370         }
<a name="l05371"></a>05371     <span class="keywordflow">return</span> sset;
<a name="l05372"></a>05372     }
<a name="l05373"></a>05373 
<a name="l05374"></a><a class="code" href="classNxsCharactersBlock_ae86148be4403ce70ab5c23b01a7130ee.html#ae86148be4403ce70ab5c23b01a7130ee">05374</a>  <span class="keywordtype">bool</span> <a class="code" href="classNxsCharactersBlock_ae86148be4403ce70ab5c23b01a7130ee.html#ae86148be4403ce70ab5c23b01a7130ee" title="Returns true iff taxon `taxInd` has is missing for character `charInd` (both indices...">NxsCharactersBlock::IsPolymorphic</a>(
<a name="l05375"></a>05375   <span class="keywordtype">unsigned</span> taxInd,  <span class="comment">/* the taxon in range [0..`ntax&#39;) */</span>
<a name="l05376"></a>05376   <span class="keywordtype">unsigned</span> charInd) NCL_COULD_BE_CONST <span class="comment">/* the character in range [0..`nChar&#39;) */</span> <span class="comment">/*v2.1to2.2 1 */</span>
<a name="l05377"></a>05377     {
<a name="l05378"></a>05378     <span class="keyword">const</span> <a class="code" href="classNxsDiscreteDatatypeMapper.html" title="This class stores the information needed to map the internal storage for a cell of...">NxsDiscreteDatatypeMapper</a> * mapper = GetDatatypeMapperForChar(charInd);
<a name="l05379"></a>05379     NCL_ASSERT(mapper);
<a name="l05380"></a>05380     <span class="keywordflow">if</span> (taxInd &gt;= discreteMatrix.size())
<a name="l05381"></a>05381         <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(<span class="stringliteral">&quot;Taxon index out of range of NxsCharactersBlock::IsPolymorphic&quot;</span>);
<a name="l05382"></a>05382     <span class="keyword">const</span> NxsDiscreteStateRow &amp; row = discreteMatrix[taxInd];
<a name="l05383"></a>05383     <span class="keywordflow">if</span> (row.size() &lt;= charInd)
<a name="l05384"></a>05384         <span class="keywordflow">throw</span> <a class="code" href="classNxsNCLAPIException.html" title="Thrown when a programming error (a violation of one of the APIs used in NCL) is revealed...">NxsNCLAPIException</a>(<span class="stringliteral">&quot;Character index out of range of NxsCharactersBlock::IsPolymorphic&quot;</span>);
<a name="l05385"></a>05385     <span class="keywordflow">return</span> mapper-&gt;<a class="code" href="classNxsDiscreteDatatypeMapper_afe4f8b3edb65863211bcd5a2746215e3.html#afe4f8b3edb65863211bcd5a2746215e3" title="Returns true if the state code maps to a collection of states that were flagged as...">IsPolymorphic</a>(row[charInd]);
<a name="l05386"></a>05386     }
<a name="l05387"></a>05387 
<a name="l05388"></a>05388 
<a name="l05394"></a><a class="code" href="classNxsCharactersBlock_a6fc06f4e671133702333af8aa3d5614d.html#a6fc06f4e671133702333af8aa3d5614d">05394</a> <span class="keywordtype">void</span> <a class="code" href="classNxsCharactersBlock_a6fc06f4e671133702333af8aa3d5614d.html#a6fc06f4e671133702333af8aa3d5614d" title="Shows the states for taxon `i&amp;#39;, character `j&amp;#39;, on the stream `out&amp;#39;.">NxsCharactersBlock::ShowStates</a>(
<a name="l05395"></a>05395   std::ostream &amp;out, <span class="comment">/* the stream on which to show the state(s) */</span>
<a name="l05396"></a>05396   <span class="keywordtype">unsigned</span> taxInd,  <span class="comment">/* the (0-offset) index of the taxon in question */</span>
<a name="l05397"></a>05397   <span class="keywordtype">unsigned</span> charInd) NCL_COULD_BE_CONST <span class="comment">/* the (0-offset) index of the character in question */</span> <span class="comment">/*v2.1to2.2 1 */</span>
<a name="l05398"></a>05398     {
<a name="l05399"></a>05399     <span class="keywordtype">bool</span> ft = tokens;
<a name="l05400"></a>05400     tokens = <span class="keyword">false</span>;
<a name="l05401"></a>05401     ShowStateLabels(out, taxInd, charInd, UINT_MAX);
<a name="l05402"></a>05402     tokens = ft;
<a name="l05403"></a>05403     }
<a name="l05404"></a>05404 
<a name="l05405"></a>05405 <span class="comment">/*---------------------------------------------------------------------------------------</span>
<a name="l05406"></a>05406 <span class="comment"> Results in aliasing of the taxa, assumptionsBlock blocks!</span>
<a name="l05407"></a>05407 <span class="comment">*/</span>
<a name="l05408"></a>05408 <span class="keywordtype">void</span> NxsCharactersBlock::CopyCharactersContents(<span class="keyword">const</span> <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> &amp;other)
<a name="l05409"></a>05409     {
<a name="l05410"></a>05410     assumptionsBlock = other.assumptionsBlock;
<a name="l05411"></a>05411     nChar = other.nChar;
<a name="l05412"></a>05412     nTaxWithData = other.nTaxWithData;
<a name="l05413"></a>05413     matchchar = other.matchchar;
<a name="l05414"></a>05414     respectingCase = other.respectingCase;
<a name="l05415"></a>05415     transposing = other.transposing;
<a name="l05416"></a>05416     interleaving = other.interleaving;
<a name="l05417"></a>05417     tokens = other.tokens;
<a name="l05418"></a>05418     labels = other.labels;
<a name="l05419"></a>05419     missing = other.missing;
<a name="l05420"></a>05420     gap = other.gap;
<a name="l05421"></a>05421     gapMode = other.gapMode;
<a name="l05422"></a>05422     symbols = other.symbols;
<a name="l05423"></a>05423     userEquates = other.userEquates;
<a name="l05424"></a>05424     datatypeMapperVec = other.datatypeMapperVec;
<a name="l05425"></a>05425     discreteMatrix = other.discreteMatrix;
<a name="l05426"></a>05426     continuousMatrix = other.continuousMatrix;
<a name="l05427"></a>05427     eliminated = other.eliminated;
<a name="l05428"></a>05428     excluded = other.excluded;
<a name="l05429"></a>05429     ucCharLabelToIndex = other.ucCharLabelToIndex;
<a name="l05430"></a>05430     indToCharLabel = other.indToCharLabel;
<a name="l05431"></a>05431     charStates = other.charStates;
<a name="l05432"></a>05432     globalStateLabels = other.globalStateLabels;
<a name="l05433"></a>05433     items = other.items;
<a name="l05434"></a>05434     charSets = other.charSets;
<a name="l05435"></a>05435     exSets = other.exSets;
<a name="l05436"></a>05436     charPartitions = other.charPartitions;
<a name="l05437"></a>05437     codonPosPartitions = other.codonPosPartitions;
<a name="l05438"></a>05438     defCodonPosPartitionName = other.defCodonPosPartitionName;
<a name="l05439"></a>05439     transfMgr = other.transfMgr;
<a name="l05440"></a>05440     datatype = other.datatype;
<a name="l05441"></a>05441     statesFormat = other.statesFormat;
<a name="l05442"></a>05442     supportMixedDatatype = other.supportMixedDatatype;
<a name="l05443"></a>05443     convertAugmentedToMixed = other.convertAugmentedToMixed;
<a name="l05444"></a>05444     allowAugmentingOfSequenceSymbols = other.allowAugmentingOfSequenceSymbols;
<a name="l05445"></a>05445     restrictionDataype = other.restrictionDataype;
<a name="l05446"></a>05446     writeInterleaveLen = other.writeInterleaveLen;
<a name="l05447"></a>05447     }
<a name="l05448"></a>05448 
<a name="l05449"></a>05449 
<a name="l05450"></a>05450 <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> *NxsCharactersBlockFactory::GetBlockReaderForID(<span class="keyword">const</span> std::string &amp; idneeded, <a class="code" href="classNxsReader.html" title="This is the class that orchestrates the reading of a NEXUS data file, and so is the...">NxsReader</a> *reader, <a class="code" href="classNxsToken.html">NxsToken</a> *)
<a name="l05451"></a>05451     {
<a name="l05452"></a>05452     <span class="keywordflow">if</span> (reader == NULL || idneeded != <span class="stringliteral">&quot;CHARACTERS&quot;</span>)
<a name="l05453"></a>05453         <span class="keywordflow">return</span> NULL;
<a name="l05454"></a>05454     <a class="code" href="classNxsCharactersBlock.html" title="This class handles reading and storage for the NEXUS block CHARACTERS.">NxsCharactersBlock</a> * nb  = <span class="keyword">new</span> <a class="code" href="classNxsCharactersBlock_aecbd5a9f87d5966c8a63acd77a507b67.html#aecbd5a9f87d5966c8a63acd77a507b67" title="In v2.1 of the API, the NxsTaxaBlockAPI and NxsAssumptionsBlockAPI pointers are usually...">NxsCharactersBlock</a>(NULL, NULL);
<a name="l05455"></a>05455     nb-&gt;SetCreateImpliedBlock(<span class="keyword">true</span>);
<a name="l05456"></a>05456     nb-&gt;<a class="code" href="classNxsBlock_a1c26882db165367dcb8e7ada8d5b1aea.html#a1c26882db165367dcb8e7ada8d5b1aea" title="Should be called with SetImplementsLinkAPI(true) by all blocks that overload both:...">SetImplementsLinkAPI</a>(<span class="keyword">true</span>);
<a name="l05457"></a>05457     <span class="keywordflow">return</span> nb;
<a name="l05458"></a>05458     }
<a name="l05459"></a>05459 
<a name="l05460"></a>05460 <span class="comment">// returns a vector of vectors of  the states for each state code.</span>
<a name="l05461"></a>05461 <span class="comment">//  The second to the last element will be empty to correspond to  NXS_GAP_STATE_CODE = -2</span>
<a name="l05462"></a>05462 <span class="comment">//  The last element will be empty to correspond to NXS_MISSING_CODE = -1</span>
<a name="l05463"></a>05463 
<a name="l05464"></a>05464 std::vector&lt;std::vector&lt;int&gt; &gt; NxsDiscreteDatatypeMapper::GetPythonicStateVectors()<span class="keyword"> const</span>
<a name="l05465"></a>05465 <span class="keyword">    </span>{
<a name="l05466"></a>05466 
<a name="l05467"></a>05467     std::vector&lt;std::vector&lt;int&gt; &gt; pv(this-&gt;<a class="code" href="classNxsDiscreteDatatypeMapper_a5c4a4c64c5a1fc2484c48134912471b6.html#a5c4a4c64c5a1fc2484c48134912471b6">GetNumStateCodes</a>());
<a name="l05468"></a>05468 
<a name="l05469"></a>05469     <span class="keyword">const</span> <span class="keywordtype">int</span> endIndex = (((int) stateSetsVec.size()) + sclOffset);
<a name="l05470"></a>05470     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; endIndex; ++i)
<a name="l05471"></a>05471         {
<a name="l05472"></a>05472         NxsDiscreteStateRow r = this-&gt;<a class="code" href="classNxsDiscreteDatatypeMapper_a6e298a0157e729dd2f9fa437c9cac749.html#a6e298a0157e729dd2f9fa437c9cac749" title="Returns the set of state indices that correspond to the states of state code `c`...">GetStateVectorForCode</a>(i);
<a name="l05473"></a>05473         pv[i].reserve(r.size());
<a name="l05474"></a>05474         <span class="keywordflow">for</span> (NxsDiscreteStateRow::const_iterator rIt = r.begin(); rIt != r.end(); ++rIt)
<a name="l05475"></a>05475             pv[i].push_back((<span class="keywordtype">int</span>)*rIt);
<a name="l05476"></a>05476         }
<a name="l05477"></a>05477     <span class="keywordflow">return</span> pv;
<a name="l05478"></a>05478     }
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Sat Mar 27 13:49:19 2010 for NCL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
